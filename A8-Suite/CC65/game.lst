ca65 V2.17 - Git d13d068
Main file   : game.asm
Current file: game.asm

000000r 1               ;----------------------------------------------
000000r 1               ; Common AGD engine
000000r 1               ; Z80 conversion by Kees van Oss 2017
000000r 1               ;----------------------------------------------
000000r 1               	.DEFINE asm_code $2000
000000r 1               	.include "game.cfg"
000000r 2               ; Flags saved by AGD Compiler
000000r 2               
000000r 2               mflag   = 0 ;
000000r 2               pflag   = 0 ;
000000r 2               sflag   = 0 ;
000000r 2               dflag   = 0 ;
000000r 2               cflag   = 0 ;
000000r 2               oflag   = 0 ;
000000r 2               lflag   = 0 ;
000000r 2               crflag  = 0 ;
000000r 2               clwflag = 0 ;
000000r 2               bigflag = 1 ;
000000r 2               
000000r 1               
000000r 1               .segment "ZEROPAGE"
000000r 1               	.include "z80-zp.inc"
000000r 2               ;.segment "ZEROPAGE"
000000r 2               
000000r 2               ws	 = $60
000000r 2               
000000r 2               z80_f	 = ws+$00
000000r 2               z80_a	 = ws+$01
000000r 2               z80_af	 = z80_f
000000r 2               
000000r 2               z80_c	 = ws+$02
000000r 2               z80_b	 = ws+$03
000000r 2               z80_bc	 = z80_c
000000r 2               
000000r 2               z80_e	 = ws+$04
000000r 2               z80_d	 = ws+$05
000000r 2               z80_de	 = z80_e
000000r 2               
000000r 2               z80_l	 = ws+$06
000000r 2               z80_h	 = ws+$07
000000r 2               z80_hl	 = z80_l
000000r 2               
000000r 2               z80_x    = ws+$08
000000r 2               z80_i    = ws+$09
000000r 2               z80_ix	 = z80_x
000000r 2               
000000r 2               z80_iy	 = ws+$0a
000000r 2               
000000r 2               z80_fp	 = ws+$0c
000000r 2               z80_ap	 = ws+$0d
000000r 2               
000000r 2               z80_cp	 = ws+$0e
000000r 2               z80_bp	 = ws+$0f
000000r 2               z80_bcp	 = z80_cp
000000r 2               
000000r 2               z80_ep	 = ws+$10
000000r 2               z80_dp	 = ws+$11
000000r 2               z80_dep	 = z80_ep
000000r 2               
000000r 2               z80_lp	 = ws+$12
000000r 2               z80_hp	 = ws+$13
000000r 2               z80_hlp	 = z80_lp
000000r 2               
000000r 2               z80_sp   = ws+$14
000000r 2               
000000r 2               z80_reg0 = ws+$16
000000r 2               z80_reg1 = ws+$17
000000r 2               z80_reg2 = ws+$18
000000r 2               z80_reg3 = ws+$19
000000r 2               
000000r 2               z80_r	 = ws+$1a
000000r 2               
000000r 2               
000000r 1               	.include "engine-zp.inc"
000000r 2               ;----------------------------------------------------------------------
000000r 2               ; AGD 6502 Engine Zero Page Variables
000000r 2               ;----------------------------------------------------------------------
000000r 2               
000000r 2               ; Variables start here.
000000r 2               
000000r 2  xx           scno:	.res 1			; present screen number.
000001r 2  xx           numlif:	.res 1			; number of lives.
000002r 2               
000002r 2  xx           vara:	.res 1			; general-purpose variable.
000003r 2  xx           varb:	.res 1			; general-purpose variable.
000004r 2  xx           varc:	.res 1			; general-purpose variable.
000005r 2  xx           vard:	.res 1			; general-purpose variable.
000006r 2  xx           vare:	.res 1			; general-purpose variable.
000007r 2  xx           varf:	.res 1			; general-purpose variable.
000008r 2  xx           varg:	.res 1			; general-purpose variable.
000009r 2  xx           varh:	.res 1			; general-purpose variable.
00000Ar 2  xx           vari:	.res 1			; general-purpose variable.
00000Br 2  xx           varj:	.res 1			; general-purpose variable.
00000Cr 2  xx           vark:	.res 1			; general-purpose variable.
00000Dr 2  xx           varl:	.res 1			; general-purpose variable.
00000Er 2  xx           varm:	.res 1			; general-purpose variable.
00000Fr 2  xx           varn:	.res 1			; general-purpose variable.
000010r 2  xx           varo:	.res 1			; general-purpose variable.
000011r 2  xx           varp:	.res 1			; general-purpose variable.
000012r 2  xx           varq:	.res 1			; general-purpose variable.
000013r 2  xx           varr:	.res 1			; general-purpose variable.
000014r 2  xx           vars:	.res 1			; general-purpose variable.
000015r 2  xx           vart:	.res 1			; general-purpose variable.
000016r 2  xx           varu:	.res 1			; general-purpose variable.
000017r 2  xx           varv:	.res 1			; general-purpose variable.
000018r 2  xx           varw:	.res 1			; general-purpose variable.
000019r 2  xx           varz:	.res 1			; general-purpose variable.
00001Ar 2               
00001Ar 2  xx           charx:	.res 1			; cursor x position.
00001Br 2  xx           chary:	.res 1			; cursor y position.
00001Cr 2               
00001Cr 2  xx           clock:	.res 1			; last clock reading.
00001Dr 2  xx           varrnd:	.res 1	        	; last random number.
00001Er 2  xx           varobj:	.res 1  	   	; last object number.
00001Fr 2  xx           varopt:	.res 1     		; last option chosen from menu.
000020r 2  xx           varblk:	.res 1  		; block type.
000021r 2  xx           nexlev:	.res 1			; next level flag.
000022r 2  xx           restfl:	.res 1			; restart screen flag.
000023r 2  xx           deadf:	.res 1			; dead flag.
000024r 2  xx           gamwon:	.res 1			; game won flag.
000025r 2  xx           dispx:	.res 1			; cursor x position.
000026r 2  xx           dispy:	.res 1			; cursor y position.
000027r 2               
000027r 2  xx           contrl:	.res 1			; control = keyboard, 1 = Kempston, 2 = Sinclair, 3 = Mouse.
000028r 2  xx           joyval:	.res 1			; joystick reading.
000029r 2  xx           frmno:	.res 1			; selected frame.
00002Ar 2               
00002Ar 2               ;----------------------------------------------------
00002Ar 2               ; Missing vars
00002Ar 2               ;----------------------------------------------------
00002Ar 2               
00002Ar 2  xx           loopa:	    .res 1
00002Br 2  xx           loopb:	    .res 1
00002Cr 2  xx           loopc:	    .res 1
00002Dr 2  xx xx        FontPtr:    .res 2
00002Fr 2               
00002Fr 2               ; Local vars
00002Fr 2               
00002Fr 2  xx xx        scraddr:    .res 2
000031r 2  xx xx        fntaddr:    .res 2
000033r 2  xx xx        tileaddr:   .res 2
000035r 2  xx xx        bufaddr:    .res 2
000037r 2  xx xx        advbuff:    .res 2
000039r 2               
000039r 2  xx xx        tmp:        .res 2
00003Br 2  xx xx        scr_l:      .res 2
00003Dr 2  xx xx        scr_r:      .res 2
00003Fr 2  xx xx        scr_txt:    .res 2
000041r 2               
000041r 2  xx           xtmp:	    .res 1
000042r 2  xx           ytmp:	    .res 1
000043r 2  xx           spcnt:	    .res 1
000044r 2  xx xx        spptr:	    .res 2		; spawned sprite pointer.
000046r 2  xx           seed:	    .res 1		; seed for random numbers.
000047r 2               
000047r 2  xx           ccnt:       .res 1
000048r 2  xx           flag:	    .res 1
000049r 2  xx           rcol:	    .res 1
00004Ar 2  xx           rrow:	    .res 1
00004Br 2               
00004Br 2  xx           combyt:	    .res 1		; byte type compressed.
00004Cr 2  xx           comcnt:	    .res 1		; compression counter.
00004Dr 2  xx           prtmod:	    .res 1      	; print mode, 0 = standard, 1 = double-height.
00004Er 2  xx           qscnt:	    .res 1
00004Fr 2               
00004Fr 2  xx           sprptr:	    .res 1      	; not a ptr
000050r 2  xx           sprcnt:	    .res 1
000051r 2               
000051r 2  xx xx        skptr:	    .res 2		; search pointer.
000053r 2  xx           sktptr:	    .res 1      	; not a ptr
000054r 2  xx           tmproom:    .res 1
000055r 2  xx xx        ogptr:	    .res 2		; original sprite pointer.
000057r 2               
000057r 2               .if mflag
000057r 2               TmpAddr:    .res 2
000057r 2               bwid:	    .res 1     		; box/menu width.
000057r 2               blen:	    .res 1     		; box/menu height.
000057r 2               btop:	    .res 1    	 	; box coordinates.
000057r 2               blft:	    .res 1
000057r 2               .endif
000057r 2               
000057r 2               .if sflag .or pflag
000057r 2               shrctr:	    .res 1
000057r 2               .endif
000057r 2               .if pflag
000057r 2               explcnt:    .res 1
000057r 2               seed3:	    .res 1
000057r 2               .endif
000057r 2               
000057r 2               .if aflag
000057r 2               pbptr:       .res 2
000057r 2               pbbuf:	     .res 2
000057r 2               .endif
000057r 2               
000057r 2               ;sndtyp:     .res 1
000057r 2               
000057r 2               .if rflag
000057r 2               sprshft:     .res 1
000057r 2               .endif
000057r 2               
000057r 1               
000057r 1               .segment "CODE"
000000r 1               .org asm_code-6
001FFA  1  FF FF        	.word $ffff
001FFC  1  00 20        	.word start_asm
001FFE  1  EC 38        	.word eind_asm - 1
002000  1               
002000  1               
002000  1               
002000  1               exec:
002000  1               start_asm:
002000  1               	.include "game.inc"
002000  2               .include "testclock.inc"
002000  3               ;--------------------------------------------------------------
002000  3               ; Arcade Game Designer.
002000  3               ; (C) 2008 Jonathan Cauldwell.
002000  3               ; ZX Spectrum Next Engine v0.7.
002000  3               ; Acorn Atom port by K.v.Oss 2018
002000  3               ;--------------------------------------------------------------
002000  3               
002000  3               ; Conditional compilation flags
002000  3               ; Code is installed if flag is set
002000  3               ; Flags are set in commandline assembly or by the compiler
002000  3               
002000  3               ; Flags set by AGD compiler
002000  3               ;	mflag  			; MENU + INV
002000  3               ;	pflag 			; particle engine
002000  3               ;	sflag 			; scrollytext
002000  3               ;	dflag 			; digging mode
002000  3               ;	cflag			; collectable blocks
002000  3               ;	oflag			; objects
002000  3               ;	lflag			; ladders
002000  3               ;
002000  3               ; Flags set manually
002000  3               ;	aflag			; adventure mode
002000  3               ;	bflag			; big sprites (16x24)
002000  3               ;	iflag			; invert mode
002000  3               
002000  3               .if mflag
002000  3               	.out "- MEN/INV enabled"
002000  3               .endif
002000  3               .if pflag
002000  3               	.out "- Particles enabled"
002000  3               .endif
002000  3               .if sflag
002000  3               	.out "- Scrolling enabled"
002000  3               .endif
002000  3               .if dflag
002000  3               	.out "- Digging enabled"
002000  3               .endif
002000  3               .if cflag
002000  3               	.out "- Collectable blocks enabled"
002000  3               .endif
002000  3               .if oflag
002000  3               	.out "- Objects enabled"
002000  3               .endif
002000  3               .if lflag
002000  3               	.out "- Ladders enabled"
002000  3               .endif
002000  3               .if aflag
002000  3               	.out "- Adventure mode enabled"
002000  3               .endif
002000  3               .if bflag
002000  3               	.out "- Big Sprites (16x24) enabled"
002000  3               .endif
002000  3               .if iflag
002000  3               	.out "- Invert mode enabled"
002000  3               .endif
002000  3               
002000  3               ; Global definitions ------------------------------------------------------------
002000  3               
002000  3               	FONT = font		; Font address
002000  3               
002000  3               	green	= $00		; Colour definition filters
002000  3               	yellow	= $55
002000  3               	blue	= $aa
002000  3               	red	= $ff
002000  3               
002000  3               ; Block characteristics.
002000  3               
002000  3               	PLATFM	= 1		; platform.
002000  3               	WALL	= PLATFM + 1	; solid wall.
002000  3               	LADDER	= WALL + 1	; ladder.
002000  3               	FODDER	= LADDER + 1	; fodder block.
002000  3               	DEADLY	= FODDER + 1	; deadly block.
002000  3               	CUSTOM	= DEADLY + 1	; custom block.
002000  3               	WATER	= CUSTOM + 1	; water block.
002000  3                       COLECT	= WATER + 1	; collectable block.
002000  3                       NUMTYP	= COLECT + 1	; number of types.
002000  3               
002000  3               ; Sprites.
002000  3               
002000  3               .if bflag
002000  3               	SPR_HGT	= 24		; Sprite height
002000  3               	SPR_WID = 16		; Sprite width
002000  3               	NUMSPR	= 8		; number of sprites.
002000  3               .else				; 16x16 sprites
002000  3               	SPR_HGT = 16		; Sprite height
002000  3               	SPR_WID = 16		; Sprite width
002000  3               	NUMSPR	= 12		; number of sprites.
002000  3               .endif
002000  3               
002000  3               	TABSIZ = 17		; size of each entry.
002000  3               	SPRBUF = NUMSPR * TABSIZ; size of entire table.
002000  3               	NMESIZ = 4		; bytes stored in nmetab for each sprite.
002000  3               	var_X  = 8		; new x coordinate of sprite.
002000  3               	var_Y  = var_X + 1	; new y coordinate of sprite.
002000  3               	PAM1ST = 5		; first sprite parameter, old x (ix+5).
002000  3               
002000  3               ; Particle engine.
002000  3               
002000  3               	NUMSHR = 55		; pieces of shrapnel.
002000  3               	SHRSIZ = 6		; bytes per particle.
002000  3               
002000  3               ; System constants
002000  3               
002000  3               	ScreenAddr  = $8000	; Startaddress video RAM
002000  3               	ScrSelAddr  = $b000	; Screen selection address
002000  3               	KeyRowAddr  = $b000	; PIA key matrix row
002000  3               	KeyColAddr  = $b001	; PIA key matrix column
002000  3               	SpeakerBit  = $b002	; Speaker bit
002000  3               	CmdReg      = $b400	; Command register AtoMMC
002000  3               	DatReg      = $b401	; Data register AtoMMC
002000  3               	Timer2_Low  = $b808	; Timer 2 low byte
002000  3               	Timer2_High = $b809	; Timer 2 high byte
002000  3               
002000  3               ; System calls
002000  3               
002000  3               	SCRSYNC	 = $fe66	; wait for next CRT field flyback 60 Hz
002000  3               	SCRSYNC1 = $fe6b	; wait for CRT field flyback 60 Hz
002000  3               	OSRDCH   = $fe94	; get key subroutine
002000  3                       READKEY  = $fe71	; scan key matrix subroutine
002000  3               	OSWRCH	 = $fff4	; write character
002000  3               
002000  3               
002000  3               .if iflag
002000  3               	TxtInvert   = $ff	; Invert byte for character printing
002000  3               	ScrFillByte = $ff	; Screen fill byte for CLS
002000  3               .else
002000  3               	TxtInvert   = $00	; Invert byte for character printing
002000  3               	ScrFillByte = $00	; Screen fill byte for CLS
002000  3               .endif
002000  3               
002000  3               	ScrMode     = $f0	;  $f0 = CLEAR4  mono
002000  3               
002000  3               ;===============================================================
002000  3               ; Game starts here
002000  3               ;===============================================================
002000  3               
002000  3               ;.segment "CODE"
002000  3               
002000  3  78           	sei
002001  3  A2 00        	ldx #0
002003  3               testloop:
002003  3  BD 15 20     	lda teststring,x
002006  3  F0 0A        	beq endtest
002008  3  38           	sec
002009  3  E9 20        	sbc #32
00200B  3  9D 40 9C     	sta $9c40,x
00200E  3  E8           	inx
00200F  3  4C 03 20     	jmp testloop
002012  3               endtest:
002012  3  4C 12 20     	jmp endtest
002015  3               
002015  3  48 45 4C 4C  teststring:	.byte "HELLO WORLD",0
002019  3  4F 20 57 4F  
00201D  3  52 4C 44 00  
002021  3               
002021  3               
002021  3               ; Clear variables
002021  3               
002021  3  A9 00        	lda #0
002023  3  A2 00        	ldx #0
002025  3               clrloop:
002025  3  95 00        	sta 0,x
002027  3  E8           	inx
002028  3  D0 FB        	bne clrloop
00202A  3               
00202A  3  20 22 21     	jsr game	 	; start the game.
00202D  3  A9 0C        	lda #12			; Clear screen + exit to Basic
00202F  3  20 F4 FF     	jsr OSWRCH
002032  3  4C B2 C2     	jmp $C2B2		; Back to Basic
002035  3               
002035  3               ; Definition of variables
002035  3               ; Make sure pointers are arranged in the same order as the data itself.
002035  3               
002035  3  BE 34        msgptr:		.word msgdat	; messages
002037  3  EC 34        blkptr:		.word chgfx	; block graphics.
002039  3  F4 34        proptr:		.word bprop	; address of char properties.
00203B  3  F5 34        sptptr:		.word sprgfx	; sprite graphics
00203D  3  75 35        frmptr:		.word frmlst	; sprite frames.
00203F  3  79 35        scrptr:		.word scdat	; address of screens.
002041  3  85 35        nmeptr:		.word nmedat	; enemy start positions.
002043  3  8A 35        objptr:		.word objdta	; object graphics
002045  3               
002045  3               ;TxtFilter:	.byte $ff
002045  3  00 55 AA FF  txtcol:		.byte green,yellow,blue,red
002049  3               
002049  3               ; Don't change the order of these four.
002049  3               ; Menu routine relies on winlft following wintop.
002049  3               
002049  3  01           wintop:		.byte WINDOWTOP	; top of window.
00204A  3  01           winlft:		.byte WINDOWLFT	; left edge.
00204B  3  16           winhgt:		.byte WINDOWHGT	; window height.
00204C  3  1E           winwid:		.byte WINDOWWID	; window width.
00204D  3  01           numob:		.byte NUMOBJ	; number of objects in game.
00204E  3               
00204E  3               ; Variables start here.
00204E  3               ; Pixel versions of wintop, winlft, winhgt, winwid.
00204E  3               
00204E  3  08           wntopx:		.byte (8 * WINDOWTOP)
00204F  3  08           wnlftx:		.byte (8 * WINDOWLFT)
002050  3  A8           wnbotx:		.byte ((WINDOWTOP * 8) + (WINDOWHGT * 8) - 16)
002051  3  E6           wnrgtx:		.byte ((WINDOWLFT * 8) + (WINDOWWID * 8) - 16)-2
002052  3               
002052  3               ; Assorted game routines which can go in contended memory.
002052  3               
002052  3               ;--------------------------------------------------------------
002052  3               ; Entry for inventory called by the INV command
002052  3               ;
002052  3               ; Input:
002052  3               ;  X   = message nr with objects seperated with ,
002052  3               ;
002052  3               ; Output:
002052  3               ;  OPT = selected objectnr of INV menu
002052  3               ;--------------------------------------------------------------
002052  3               
002052  3               .if mflag
002052  3               minve:
002052  3               	lda #<(invdis)		; routine address.
002052  3               	sta mod0+1		; set up menu routine.
002052  3               	sta mod2+1		; set up count routine.
002052  3               	lda #>(invdis)
002052  3               	sta mod0+2
002052  3               	sta mod2+2
002052  3               	lda #<(fopt)		; find option from available objects.
002052  3               	sta mod1+1		; set up routine.
002052  3               	lda #>(fopt)
002052  3               	sta mod1+1+1
002052  3               	jmp dbox		; do menu routine.
002052  3               
002052  3               ;--------------------------------------------------------------
002052  3               ; Entry for menu called by the MENU command
002052  3               ;
002052  3               ; Input:
002052  3               ;  X   = message nr with menu items seperated with ,
002052  3               ;
002052  3               ; Output:
002052  3               ;  OPT = selected line nr of MENU menu
002052  3               ;--------------------------------------------------------------
002052  3               
002052  3               mmenu:
002052  3               	lda #<(always)		; routine address.
002052  3               	sta mod0+1		; set up routine.
002052  3               	sta mod2+1		; set up count routine.
002052  3               	lda #>(always)
002052  3               	sta mod0+2
002052  3               	sta mod2+2
002052  3               
002052  3               	lda #<(fstd)		; standard option selection.
002052  3               	sta mod1+1		; set up routine.
002052  3               	lda #>(fstd)
002052  3               	sta mod1+2
002052  3               
002052  3               ; Drop through into box routine.
002052  3               
002052  3               ;--------------------------------------------------------------
002052  3               ; Work out size of box for message or menu.
002052  3               ;--------------------------------------------------------------
002052  3               
002052  3               dbox:
002052  3               	lda #<(msgdat)		; pointer to messages.
002052  3               	sta z80_l
002052  3               	lda #>(msgdat)
002052  3               	sta z80_h
002052  3               
002052  3               	jsr getwrd		; get message number.
002052  3               
002052  3               	lda z80_h		; store pointer to message.
002052  3               	sta TmpAddr
002052  3               	lda z80_l
002052  3               	sta TmpAddr+1
002052  3               
002052  3               	lda #1			; height.
002052  3               	sta z80_d
002052  3               	lda #0			; start at object zero.
002052  3               	sta combyt		; store number of object in combyt.
002052  3               	sta z80_e		; maximum width.
002052  3               dbox5:
002052  3               	lda #0			; this line"s width.
002052  3               	sta z80_b
002052  3               mod2:
002052  3               	jsr always		; item in player"s possession?
002052  3               	cmp #255
002052  3               	bne dbox6		; not in inventory, skip this line.
002052  3               	inc z80_d		; add to tally.
002052  3               dbox6:
002052  3               	ldy #0			; get character.
002052  3               	lda (z80_hl),y
002052  3               	sta z80_a
002052  3               	inc z80_l		; next character.
002052  3               	bne :+
002052  3               	inc z80_h
002052  3               :
002052  3               	lda z80_a		; reached end of line?
002052  3               	cmp #','
002052  3               	beq dbox3		; yes.
002052  3               	cmp #13
002052  3               	beq dbox3		; yes.
002052  3               	inc z80_b		; add to this line"s width.
002052  3               	lda z80_a
002052  3               	bmi dbox4		; end of message? yes, end count.
002052  3               	jmp dbox6		; repeat until we find the end.
002052  3               dbox3:
002052  3               	lda z80_e		; maximum line width.
002052  3               	cmp z80_b		; have we exceeded longest so far?
002052  3               	bpl dbox5		; no, carry on looking.
002052  3               	lda z80_b		; make this the widest so far.
002052  3               	sta z80_e
002052  3               	jmp dbox5		; keep looking.
002052  3               dbox4:
002052  3               	lda z80_e		; maximum line width.
002052  3               	cmp z80_b		; have we exceeded longest so far?
002052  3               	bpl dbox8		; no, carry on looking.
002052  3               	lda z80_b		; final line is the longest so far.
002052  3               	sta z80_e
002052  3               dbox8:
002052  3               	dec z80_d		; decrement items found.
002052  3               	bne :+			; total was zero.
002052  3               	lda #255
002052  3               	sta varopt
002052  3               	jmp dbox15
002052  3               :
002052  3               	lda z80_e		; longest line.
002052  3               	bne :+			; was it zero?
002052  3               	jmp dbox15		; total was zero.
002052  3               :
002052  3               	sta bwid		; set up size.
002052  3               	lda z80_d
002052  3               	sta blen
002052  3               
002052  3               ;--------------------------------------------------------------
002052  3               ; That's set up our box size.
002052  3               ;--------------------------------------------------------------
002052  3               
002052  3               	lda winhgt		; window height in characters.
002052  3               	sec
002052  3               	sbc z80_d		; subtract height of box.
002052  3               	lsr a			; divide by 2.
002052  3               	clc
002052  3               	adc wintop		; add top edge of window.
002052  3               	sta btop		; set up box top.
002052  3               
002052  3               	lda winwid		; window width in characters.
002052  3               	sec
002052  3               	sbc z80_e		; subtract box width.
002052  3               	lsr a			; divide by 2.
002052  3               	clc
002052  3               	adc winlft		; add left edge of window.
002052  3               	sta blft		; box left.
002052  3               
002052  3               	lda #<(FONT-256)		; font.
002052  3               	sta grbase		; set up for text display.
002052  3               	lda #>(FONT-256)
002052  3               	sta grbase+1
002052  3               
002052  3               	lda TmpAddr+1		; restore message pointer.
002052  3               	sta z80_l
002052  3               	lda TmpAddr
002052  3               	sta z80_h
002052  3               
002052  3               	lda btop		; box top.
002052  3               	sta dispy		; set display coordinate.
002052  3               	lda #0			; start at object zero.
002052  3               	sta combyt		; store number of object in combyt.
002052  3               dbox2:
002052  3               	lda combyt		; get object number.
002052  3               	sta z80_a
002052  3               mod0:
002052  3               	jsr always		; check inventory for display.
002052  3               	cmp #255
002052  3               	beq :+
002052  3               	jmp dbox13		; not in inventory, skip this line.
002052  3               :
002052  3               	lda blft		; box left.
002052  3               	sta dispx		; set left display position.
002052  3               	lda bwid		; box width.
002052  3               	sta z80_b		; store width.
002052  3               dbox0:
002052  3               	ldy #0
002052  3               	lda (z80_hl),y		; get character.
002052  3               	cmp #','		; end of line?
002052  3               	beq dbox1		; yes, next one.
002052  3               	cmp #13			; end of line?
002052  3               	beq dbox1		; yes, next one.
002052  3               
002052  3               	cmp #141			; end of line?
002052  3               	bne :+
002052  3               	dec bwid
002052  3               	jmp dbox7		; yes, next one.
002052  3               :
002052  3               	dec z80_b		; one less to display.
002052  3               	and #127		; remove terminator.
002052  3               
002052  3               	jsr pchr		; display on screen.
002052  3               
002052  3               	ldy #0
002052  3               	lda (z80_hl),y		; get character.
002052  3               	sta z80_a
002052  3               	inc z80_l		; next character.
002052  3               	bne :+
002052  3               	inc z80_h
002052  3               :
002052  3               	lda z80_a
002052  3               	cmp #128		; end of message?
002052  3               	bmi :+
002052  3               	jmp dbox7		; yes, job done.
002052  3               :
002052  3               	lda z80_b		; chars remaining.
002052  3               	beq :+			; are any left?
002052  3               	jmp dbox0		; yes, continue.
002052  3               :
002052  3               ;---------------------------------------------------
002052  3               ; Reached limit of characters per line.
002052  3               ;---------------------------------------------------
002052  3               
002052  3               dbox9:
002052  3               	ldy #0
002052  3               	lda (z80_hl),y		; get character.
002052  3               	inc z80_l		; next one.
002052  3               	bne :+
002052  3               	inc z80_h
002052  3               :
002052  3               	cmp #','		; another line?
002052  3               	beq dbox10		; yes, do next line.
002052  3               	cmp #13			; another line?
002052  3               	beq dbox10		; yes, do next line.
002052  3               	cmp #128		; end of message?
002052  3               	bcs :+
002052  3               	jmp dbox11		; yes, finish message.
002052  3               :
002052  3               	jmp dbox9
002052  3               
002052  3               ;---------------------------------------------------
002052  3               ; Fill box to end of line.
002052  3               ;---------------------------------------------------
002052  3               
002052  3               dboxf:
002052  3               	lda #32			; space character.
002052  3               	jsr pchr		; display character.
002052  3               	dec z80_b
002052  3               	beq :+
002052  3               	jmp dboxf		; repeat for remaining chars on line.
002052  3               :
002052  3               	rts
002052  3               dbox1:
002052  3               	inc z80_l		; skip character.
002052  3               	bne :+
002052  3               	inc z80_h
002052  3               :
002052  3               	jsr dboxf		; fill box out to right side.
002052  3               dbox10:
002052  3               	inc dispy		; y coordinate down a line next position.
002052  3               	jmp dbox2		; next line.
002052  3               dbox7:
002052  3               	lda z80_b		; chars remaining.
002052  3               	bne :+			; are any left?
002052  3               	jmp dbox11		; no, nothing to draw.
002052  3               :
002052  3               	jsr dboxf		; fill message to line.
002052  3               
002052  3               ;------------------------------------------------------
002052  3               ; Drawn the box menu, now select option.
002052  3               ;------------------------------------------------------
002052  3               
002052  3               dbox11:
002052  3               	lda btop		; box top.
002052  3               	sta dispy		; set bar position.
002052  3               dbox14:
002052  3               	jsr joykey		; get controls.
002052  3               	cmp #$7f		; anything pressed?
002052  3               	bne dbox14		; yes, debounce it.
002052  3               	jsr dbar		; draw bar.
002052  3               dbox12:
002052  3               	jsr joykey		; get controls.
002052  3               	cmp #$7f		; anything pressed?
002052  3               	beq dbox12		; no, nothing.
002052  3               	and #16			; fire button pressed?
002052  3               	bne :+
002052  3               mod1:
002052  3               	jmp fstd		; yes, job done.
002052  3               :
002052  3               	jsr dbar		; delete bar.
002052  3               
002052  3               	lda joyval		; joystick reading.
002052  3               	and #8			; going up?
002052  3               	beq dboxu		; yes, go up.
002052  3               
002052  3               	ldx dispy		; vertical position of bar.
002052  3               	inx			; look down.
002052  3               	txa
002052  3               	sec
002052  3               	sbc btop		; find distance from top.
002052  3               	cmp blen		; top of box.
002052  3               	bne :+
002052  3               	jmp dbox14		; yes, go no further.
002052  3               :
002052  3               	inc dispy		; move bar.
002052  3               	jmp dbox14		; continue.
002052  3               dboxu:
002052  3               	lda dispy		; vertical position of bar.
002052  3               	cmp btop		; are we at the top?
002052  3               	bne :+
002052  3               	jmp dbox14		; yes, go no further.
002052  3               :
002052  3               	dec dispy		; move bar.
002052  3               	jmp dbox14		; continue.
002052  3               fstd:
002052  3               	lda dispy		; bar position.
002052  3               	sec
002052  3               	sbc btop		; find selected option.
002052  3               	sta varopt		; store the option.
002052  3               	jmp redraw		; redraw the screen.
002052  3               
002052  3               ;------------------------------------------------------
002052  3               ; Option not available.  Skip this line.
002052  3               ;------------------------------------------------------
002052  3               
002052  3               dbox13:
002052  3               	ldy #0
002052  3               	lda (z80_hl),y		; get character.
002052  3               	inc z80_l		; next one.
002052  3               	bne :+
002052  3               	inc z80_h
002052  3               :
002052  3               	cmp #','		; another line?
002052  3               	bne :+
002052  3               	jmp dbox2		; yes, do next line.
002052  3               :
002052  3               	cmp #13			; another line?
002052  3               	bne :+
002052  3               	jmp dbox2		; yes, do next line.
002052  3               :
002052  3               
002052  3               	bpl :+			; end of message?
002052  3               	jmp dbox11		; yes, finish message.
002052  3               :
002052  3               	jmp dbox13
002052  3               dbox15:
002052  3               	lda TmpAddr		; pop message pointer from the stack.
002052  3               	sta z80_h
002052  3               	lda TmpAddr+1
002052  3               	sta z80_l
002052  3               	rts
002052  3               
002052  3               ;------------------------------------------------------
002052  3               ; Invert bar
002052  3               ;------------------------------------------------------
002052  3               
002052  3               dbar:
002052  3               	lda blft		; box left.
002052  3               	sta dispx		; set display coordinate.
002052  3               	jsr gprad		; get printing address.
002052  3               
002052  3               	lda bwid		; box width.
002052  3               	sta z80_c		; loop counter in c.
002052  3               	lda z80_h
002052  3               	sta z80_d		; store screen address high byte.
002052  3               dbar1:
002052  3               	ldx #7			; pixel height in b.
002052  3               dbar0:
002052  3               	ldy scrtab,x
002052  3               	lda (scraddr),y		; get screen byte.
002052  3               	eor #255		; reverse all bits.
002052  3               	sta (scraddr),y		; write back to screen.
002052  3               	dex			; next line down.
002052  3               	bpl dbar0		; draw rest of character.
002052  3               
002052  3               	inc scraddr		; one char right.
002052  3               	dec z80_c		; decrement character counter.
002052  3               	bne dbar1		; repeat for whole line.
002052  3               	rts
002052  3               
002052  3               ;------------------------------------------------------
002052  3               ; Point to object
002052  3               ;
002052  3               ; Input:
002052  3               ;  combyt
002052  3               ;
002052  3               ; Output:
002052  3               ;  A = object number, A=255 if already in possession
002052  3               ;------------------------------------------------------
002052  3               
002052  3               invdis:
002052  3               	lda z80_l		; store message text pointer.
002052  3               	pha
002052  3               	lda z80_h
002052  3               	pha
002052  3               	lda combyt		; object number.
002052  3               	inc combyt		; ready for next one.
002052  3               	jsr gotob		; check if we have object.
002052  3               	tay
002052  3               	pla
002052  3               	sta z80_h
002052  3               	pla
002052  3               	sta z80_l
002052  3               	tya
002052  3               	rts
002052  3               
002052  3               ;------------------------------------------------------
002052  3               ; Find option selected.
002052  3               ;
002052  3               ; Input:
002052  3               ;  -
002052  3               ;
002052  3               ; Output:
002052  3               ;  OPT = selected object
002052  3               ;------------------------------------------------------
002052  3               
002052  3               fopt:
002052  3               	lda dispy
002052  3               	sec
002052  3               	sbc btop		; find selected option.
002052  3               	sta tmp+2		; option selected in b register.
002052  3               	inc tmp+2
002052  3               
002052  3               	lda #0			; set to first item.
002052  3               	sta combyt		; object number.
002052  3               fopt0:
002052  3               	jsr fobj		; find next object in inventory.
002052  3               	dec tmp+2
002052  3               	bne fopt0		; repeat for relevant steps down the list.
002052  3               
002052  3               	lda combyt		; get option.
002052  3               	sta varopt		; store the option.
002052  3               	dec varopt		; one less, due to where we increment combyt.
002052  3               	jmp redraw		; redraw the screen.
002052  3               fobj:
002052  3               	ldy combyt		; object number.
002052  3               	inc combyt		; ready for next item.
002052  3               	tya
002052  3               	jsr gotob		; do we have this item?
002052  3               	cmp #255
002052  3               	bne :+
002052  3               	rts
002052  3               :
002052  3               	jmp fobj		; yes, it's on the list.
002052  3               
002052  3               ;bwid:	.byte 0              ; box/menu width.
002052  3               ;blen:	.byte 0              ; box/menu height.
002052  3               ;btop:	.byte 0              ; box coordinates.
002052  3               ;blft:	.byte 0
002052  3               .endif
002052  3               
002052  3               ;----------------------------------------------------
002052  3               ; Wait for keypress.
002052  3               ;----------------------------------------------------
002052  3               
002052  3               prskey:
002052  3  98           	tya
002053  3  48           	pha
002054  3               prsloop:
002054  3  20 86 20     	jsr vsync
002057  3  20 71 FE     	jsr READKEY
00205A  3  C0 FF        	cpy #255
00205C  3  F0 F6        	beq prsloop		; wait until key pressed
00205E  3  20 DB 29     	jsr joykey
002061  3  68           	pla
002062  3  A8           	tay
002063  3  60           	rts
002064  3               
002064  3               ;----------------------------------------------------
002064  3               ; Delay routine 1/50 sec
002064  3               ;
002064  3               ; Wait 1/60 sec = 16666 usec
002064  3               ; Wait 208 x 16 =  3328 usec
002064  3               ;                 19994 usec
002064  3               ; rts           =     6 usec
002064  3               ; Total         = 20000 usec
002064  3               ;----------------------------------------------------
002064  3               
002064  3               delay:
002064  3  85 rr        	sta xtmp
002066  3               del_loop:
002066  3  20 66 FE     	jsr SCRSYNC		; wait for flyback
002069  3               
002069  3  A0 D0        	ldy #208		; wait 208 x 16 = 3328 usec
00206B  3               delay1:
00206B  3  61 80        	adc ($80,x)		;	 6 usec
00206D  3  61 80        	adc ($80,x)		;	 6 usec
00206F  3  88           	dey			;	 2 usec
002070  3  D0 F9        	bne delay1		;	 2 usec
002072  3  EA           	nop			; 2 usec
002073  3  EA           	nop			; 2 usec
002074  3               				; tot: 20000 usec
002074  3  C6 rr        	dec xtmp
002076  3  D0 EE        	bne del_loop
002078  3  60           	rts
002079  3               
002079  3               ;----------------------------------------------------
002079  3               ; Clear sprite table.
002079  3               ;
002079  3               ; sprtab[0] - sprtab[SPRBUF-1] = 255
002079  3               ;----------------------------------------------------
002079  3               
002079  3               xspr:
002079  3  A9 FF        	lda #255		; clear byte.
00207B  3  A2 00        	ldx #0			; length of table.
00207D  3               xspr0:
00207D  3  9D 33 33     	sta sprtab,x		; sprite table.
002080  3  E8           	inx			; move to next byte.
002081  3  E0 CC        	cpx #SPRBUF
002083  3  D0 F8        	bne xspr0		; repeat for rest of table.
002085  3  60           	rts
002086  3               
002086  3               ;-------------------------------------------------------------
002086  3               ; Initialise all objects.
002086  3               ;
002086  3               ; Reset current room,y,x to start room,y,x for all objects
002086  3               ;-------------------------------------------------------------
002086  3               
002086  3               .if oflag
002086  3               iniob:
002086  3               	lda #<objdta 		; objects table.
002086  3               	sta z80_x
002086  3               	lda #>objdta
002086  3               	sta z80_i
002086  3               
002086  3               	ldx numob 		; number of objects in the game.
002086  3               iniob0:
002086  3               	ldy #35
002086  3               	lda (z80_ix),y 		; start screen.
002086  3               	ldy #32
002086  3               	sta (z80_ix),y 		; set start screen.
002086  3               
002086  3               	ldy #36
002086  3               	lda (z80_ix),y 		; find start y.
002086  3               	ldy #33
002086  3               	sta (z80_ix),y 		; set start y.
002086  3               
002086  3               	ldy #37
002086  3               	lda (z80_ix),y 		; get initial x.
002086  3               	ldy #34
002086  3               	sta (z80_ix),y 		; set x coord.
002086  3               
002086  3               	clc 			; point to next object.
002086  3               	lda z80_x
002086  3               	adc #38			; distance between objects.
002086  3               	sta z80_x
002086  3               	bcc :+
002086  3               	inc z80_i
002086  3               :
002086  3               	dex 			; repeat.
002086  3               	bne iniob0
002086  3               
002086  3               	rts
002086  3               .endif
002086  3               
002086  3               ;-------------------------------------------------------------
002086  3               ; Screen synchronisation.
002086  3               ;
002086  3               ;  - read joystick/keyboard
002086  3               ;  - handle sound
002086  3               ;  - sync framerate with clock
002086  3               ;  - handle shrapnel every even frame
002086  3               ;-------------------------------------------------------------
002086  3               
002086  3               vsync:
002086  3  48           	pha
002087  3  98           	tya
002088  3  48           	pha
002089  3  8A           	txa
00208A  3  48           	pha
00208B  3  20 DB 29     	jsr joykey		; read joystick/keyboard.
00208E  3               vsync1:
00208E  3  AD 09 B8     	lda Timer2_High		; sync framerate with clock
002091  3  C9 FF        	cmp #$ff
002093  3  D0 F9        	bne vsync1
002095  3  A9 C3        	lda #>50000
002097  3  8D 09 B8     	sta Timer2_High
00209A  3  A9 50        	lda #<50000
00209C  3  8D 08 B8     	sta Timer2_Low
00209F  3               
00209F  3  A5 rr        	lda clock
0020A1  3  29 01        	and #1
0020A3  3  D0 03        	bne:+
0020A5  3  20 21 21     	jsr proshr		; handle shrapnel every even frame
0020A8  3               :
0020A8  3  AD C6 20     	lda sndtyp
0020AB  3  F0 13        	beq sndskip
0020AD  3               sndloop:
0020AD  3  AD 02 B0     	lda SpeakerBit		; handle sound
0020B0  3  AC C6 20     	ldy sndtyp
0020B3  3               sndwait:
0020B3  3  88           	dey
0020B4  3  D0 FD        	bne sndwait
0020B6  3  49 04        	eor #4
0020B8  3  8D 02 B0     	sta SpeakerBit
0020BB  3  CE C6 20     	dec sndtyp
0020BE  3  D0 ED        	bne sndloop
0020C0  3               sndskip:
0020C0  3  68           	pla
0020C1  3  AA           	tax
0020C2  3  68           	pla
0020C3  3  A8           	tay
0020C4  3  68           	pla
0020C5  3  60           	rts
0020C6  3               
0020C6  3  00           sndtyp:	.byte 0
0020C7  3               
0020C7  3               ;-----------------------------------------------
0020C7  3               ; Redraw the screen.
0020C7  3               ;
0020C7  3               ; Remove old copy of all sprites for redraw.
0020C7  3               ;-----------------------------------------------
0020C7  3               
0020C7  3               redraw:
0020C7  3  A5 69        	lda z80_i 		; place sprite pointer on stack.
0020C9  3  48           	pha
0020CA  3  A5 68        	lda z80_x
0020CC  3  48           	pha
0020CD  3               
0020CD  3  20 3D 26     	jsr droom		; show screen layout.
0020D0  3               .if oflag
0020D0  3               	jsr shwob		; draw objects.
0020D0  3               .endif
0020D0  3               numsp0:
0020D0  3  A9 0C        	lda #NUMSPR		; sprites to draw.
0020D2  3  85 rr        	sta tmp
0020D4  3               
0020D4  3  A9 33        	lda #<sprtab		; sprite table.
0020D6  3  85 68        	sta z80_x
0020D8  3  A9 33        	lda #>sprtab
0020DA  3  85 69        	sta z80_i
0020DC  3               redrw0:
0020DC  3  A0 00        	ldy #0
0020DE  3  B1 68        	lda (z80_ix),y		; old sprite type.
0020E0  3  C9 FF        	cmp #255		; is it enabled?
0020E2  3  F0 0B        	beq redrw1 		; no, find next one.
0020E4  3               
0020E4  3  A0 03        	ldy #3
0020E6  3  B1 68        	lda (z80_ix),y 		; sprite y.
0020E8  3  C9 B1        	cmp #177		; beyond maximum?
0020EA  3  B0 03        	bcs redrw1		; yes, nothing to draw.
0020EC  3               
0020EC  3  20 FC 2D     	jsr sspria		; show single sprite.
0020EF  3               redrw1:
0020EF  3  18           	clc			; next sprite.
0020F0  3  A5 68        	lda z80_x
0020F2  3  69 11        	adc #TABSIZ		; distance to next odd/even entry.
0020F4  3  85 68        	sta z80_x
0020F6  3  90 02        	bcc :+
0020F8  3  E6 69        	inc z80_i
0020FA  3               :
0020FA  3  C6 rr        	dec tmp			; repeat for remaining sprites.
0020FC  3  D0 DE        	bne redrw0
0020FE  3               rpblc1:
0020FE  3               ;	jsr dshrp		; redraw shrapnel.
0020FE  3               
0020FE  3               .if aflag
0020FE  3               	jsr rbloc		; draw blocks for this screen
0020FE  3               .endif
0020FE  3  68           	pla			; retrieve sprite pointer.
0020FF  3  85 68        	sta z80_x
002101  3  68           	pla
002102  3  85 69        	sta z80_i
002104  3               
002104  3  60           	rts
002105  3               
002105  3               ;----------------------------------------------------------------------
002105  3               ; Clear screen routine.
002105  3               ;
002105  3               ; Fill screenmem $8000-$97ff with ScrFillByte
002105  3               ;----------------------------------------------------------------------
002105  3               
002105  3               cls:
002105  3  A9 80        	lda #>ScreenAddr		; screen address.
002107  3  8D 11 21     	sta clsloop+2
00210A  3  AD 36 34     	lda andeor+1
00210D  3               .if iflag
00210D  3               	eor #$ff
00210D  3               .endif
00210D  3  A0 00        	ldy #0
00210F  3               clsloop:
00210F  3  99 00 80     	sta ScreenAddr,y
002112  3  C8           	iny
002113  3  D0 FA        	bne clsloop
002115  3  EE 11 21     	inc clsloop+2
002118  3  AE 11 21     	ldx clsloop+2
00211B  3  E0 98        	cpx #>(ScreenAddr+$1800)
00211D  3  D0 F0        	bne clsloop
00211F  3  60           	rts
002120  3               
002120  3               ;----------------------------------------------------------------------
002120  3               ; Atomic palette is static
002120  3               ;----------------------------------------------------------------------
002120  3               
002120  3               setpal:
002120  3  60           	rts
002121  3               
002121  3               ;----------------------------------------------------------------------
002121  3               ; FODDER check
002121  3               ;----------------------------------------------------------------------
002121  3               
002121  3               .if pflag .or dflag
002121  3               fdchk:
002121  3               	cmp #FODDER 		; is it fodder?
002121  3               	beq :+
002121  3               	rts 			; no.
002121  3               :
002121  3               	lda #0			; wipe fodder in MAP
002121  3               	ldy #0
002121  3               	sta (bufaddr),y 	; rewrite block type.
002121  3               
002121  3               	lda dispx		; x=x/8
002121  3               	pha
002121  3               	lsr a
002121  3               	lsr a
002121  3               	lsr a
002121  3               	sta dispx
002121  3               
002121  3               	lda dispy		; y=y/8
002121  3               	pha
002121  3               	lsr a
002121  3               	lsr a
002121  3               	lsr a
002121  3               	sta dispy
002121  3               
002121  3               	lda #0 			; block to write.
002121  3               	jsr pattr 		; write block.
002121  3               
002121  3               	pla
002121  3               	sta dispy
002121  3               	pla
002121  3               	sta dispx
002121  3               	rts
002121  3               .endif
002121  3               
002121  3               ;----------------------------------------------------
002121  3               ; Scrolly text and puzzle variables.
002121  3               ;----------------------------------------------------
002121  3               
002121  3               .if sflag
002121  3               txtbit:	.byte 128		; bit to write.
002121  3               txtwid:	.byte 16		; width of ticker message.
002121  3               txtpos:	.word msgdat
002121  3               txtini:	.word msgdat
002121  3               txtscr:	.word ScreenAddr
002121  3               .endif
002121  3               
002121  3               ;----------------------------------------------------
002121  3               ; Specialist routines.
002121  3               ; Process shrapnel.
002121  3               ;----------------------------------------------------
002121  3               proshr:
002121  3               .if pflag
002121  3               	lda #<SHRAPN		; table.
002121  3               	sta z80_x
002121  3               	lda #>SHRAPN
002121  3               	sta z80_i
002121  3               
002121  3               	lda #NUMSHR		; shrapnel pieces to process.
002121  3               	sta shrctr
002121  3               prosh0:
002121  3               	ldy #0
002121  3               	lda (z80_ix),y		; on/off marker.
002121  3               	asl a
002121  3               proshx:
002121  3               	bcs :+
002121  3               	jsr prosh1 		; on, so process it.
002121  3               :
002121  3               	clc
002121  3               	lda z80_x
002121  3               	adc #SHRSIZ
002121  3               	sta z80_x
002121  3               	bcc :+
002121  3               	inc z80_i
002121  3               :
002121  3               	dec shrctr		; round again.
002121  3               	bne prosh0
002121  3               .endif
002121  3               .if sflag
002121  3               	jsr scrly
002121  3               .endif
002121  3  60           	rts
002122  3               
002122  3               .if pflag
002122  3               ;shrctr:	.byte 0
002122  3               
002122  3               ;----------------------------------------------------
002122  3               ; Proces shrapnel piece
002122  3               ;----------------------------------------------------
002122  3               
002122  3               prosh1:
002122  3               	jsr plot 		; delete the pixel.
002122  3               
002122  3               	lda #<shrptr		; shrapnel routine pointers.
002122  3               	sta z80_l
002122  3               	lda #>shrptr
002122  3               	sta z80_h
002122  3               
002122  3               	ldy #0
002122  3               	lda (z80_ix),y		; restore shrapnel type.
002122  3               	jsr prosh2 		; run the routine.
002122  3               	jsr chkxy		; check x and y are good before we redisplay.
002122  3               
002122  3               	lda #<SHRSIZ 		; distance to next.
002122  3               	sta z80_e
002122  3               	lda #>SHRSIZ
002122  3               	sta z80_d
002122  3               	rts
002122  3               
002122  3               ;----------------------------------------------------
002122  3               ; Run the routine
002122  3               ;----------------------------------------------------
002122  3               
002122  3               prosh2:
002122  3               	asl a 			; 2 bytes per address.
002122  3               	tay
002122  3               	lda shrptr,y
002122  3               	sta z80_l
002122  3               	lda shrptr+1,y 		; fetch high byte from table.
002122  3               	sta z80_h
002122  3               	jmp (z80_hl) 		; jump to routine.
002122  3               
002122  3               ;----------------------------------------------------
002122  3               ; Paricle routine table
002122  3               ;----------------------------------------------------
002122  3               
002122  3               shrptr:	.word laser		; laser.
002122  3               	.word trail		; vapour trail.
002122  3               	.word shrap		; shrapnel from explosion.
002122  3               	.word dotl		; horizontal starfield left.
002122  3               	.word dotr		; horizontal starfield right.
002122  3               	.word dotu		; vertical starfield up.
002122  3               	.word dotd		; vertical starfield down.
002122  3               	.word ptcusr		; user particle.
002122  3               
002122  3               ;----------------------------------------------------
002122  3               ; Explosion shrapnel.
002122  3               ;----------------------------------------------------
002122  3               
002122  3               shrap:
002122  3               	ldy #1
002122  3               	lda (z80_ix),y 		; get the angle.
002122  3               	clc
002122  3               	adc #<shrsin		; shrapnel sine table.
002122  3               	sta z80_l
002122  3               	lda #>shrsin
002122  3               	adc #0
002122  3               	sta z80_h
002122  3               
002122  3               	ldy #0
002122  3               	lda (z80_hl),y 		; fetch value from table.
002122  3               	sta z80_e
002122  3               	inc z80_l 		; next byte of table.
002122  3               	bne :+
002122  3               	inc z80_h
002122  3               :
002122  3               	ldy #0
002122  3               	lda (z80_hl),y		; fetch value from table.
002122  3               	sta z80_d
002122  3               	inc z80_l		; next byte of table.
002122  3               	bne :+
002122  3               	inc z80_h
002122  3               :
002122  3               	ldy #0
002122  3               	lda (z80_hl),y 		; fetch value from table.
002122  3               	sta z80_c
002122  3               	inc z80_l 		; next byte of table.
002122  3               	bne :+
002122  3               	inc z80_h
002122  3               :
002122  3               	ldy #0
002122  3               	lda (z80_hl),y 		; fetch value from table.
002122  3               	sta z80_b
002122  3               
002122  3               	ldy #2
002122  3               	lda (z80_ix),y 		; x coordinate in hl.
002122  3               	clc
002122  3               	adc z80_e		; add sine lb
002122  3               	sta (z80_ix),y		; store new coordinate lb.
002122  3               	ldy #3
002122  3               	lda (z80_ix),y
002122  3               	adc z80_d		; add sine hb
002122  3               	sta (z80_ix),y		; store new coordinate hb.
002122  3               
002122  3               	ldy #4
002122  3               	lda (z80_ix),y	 	; y coordinate in hl.
002122  3               	clc
002122  3               	adc z80_c		; add cosine lb
002122  3               	sta (z80_ix),y		; store new coordinate lb.
002122  3               	ldy #5
002122  3               	lda (z80_ix),y
002122  3               	adc z80_b		; add cosine lb
002122  3               	sta (z80_ix),y		; store new coordinate hb.
002122  3               
002122  3               	rts
002122  3               
002122  3               ;----------------------------------------------------
002122  3               ; Move dots
002122  3               ;----------------------------------------------------
002122  3               
002122  3               dotl:
002122  3               	ldy #5
002122  3               	lda (z80_ix),y
002122  3               	sec
002122  3               	sbc #1		 	; move left.
002122  3               	sta (z80_ix),y
002122  3               	rts
002122  3               dotr:
002122  3               	ldy #5
002122  3               	lda (z80_ix),y
002122  3               	clc
002122  3               	adc #1		 	; move left.
002122  3               	sta (z80_ix),y
002122  3               	rts
002122  3               dotu:
002122  3               	ldy #3
002122  3               	lda (z80_ix),y
002122  3               	sec
002122  3               	sbc #1		 	; move up.
002122  3               	sta (z80_ix),y
002122  3               	rts
002122  3               dotd:
002122  3               	ldy #3
002122  3               	lda (z80_ix),y
002122  3               	clc
002122  3               	adc #1			; move down.
002122  3               	sta (z80_ix),y
002122  3               	rts
002122  3               
002122  3               ;----------------------------------------------------
002122  3               ; Check if coordinates are ok before redrawing at new position.
002122  3               ;
002122  3               ; left:   X>L		X=L	Ok
002122  3               ; right:  R+15>X	X=R	Ok
002122  3               ; top:    Y>T		Y=T	Ok
002122  3               ; bottom: B+15>Y	Y=B	Ok
002122  3               ;----------------------------------------------------
002122  3               
002122  3               chkxy:
002122  3               
002122  3               ; top:    Y>T		Y=T	Ok
002122  3               
002122  3               	ldy #3
002122  3               	lda (z80_ix),y	 	; fetch shrapnel coordinate.
002122  3               	cmp wntopx		; window top.
002122  3               	bcs :+			; compare with top window limit.
002122  3               	jmp kilshr		; out of window, kill shrapnel.
002122  3               :
002122  3               ; left:   X>L		X=L	Ok
002122  3               
002122  3               	ldy #5
002122  3               	lda (z80_ix),y	 	; fetch shrapnel coordinate.
002122  3               	cmp wnlftx		; left edge.
002122  3               	bcs :+			; compare with left window limit.
002122  3               	jmp kilshr		; out of window, kill shrapnel.
002122  3               :
002122  3               ; bottom: B+15>Y	Y=B	Ok
002122  3               
002122  3               	lda wnbotx		; point to bottom.
002122  3               	clc
002122  3               	adc #15
002122  3               	ldy #3
002122  3               	cmp (z80_ix),y	 	; fetch shrapnel coordinate.
002122  3               	bcs :+			; compare with shrapnel x coordinate.
002122  3               	jmp kilshr		; off screen, kill shrapnel..
002122  3               :
002122  3               ; right:  R+15>X	X=R	Ok
002122  3               
002122  3               	lda wnrgtx		; point to right edge.
002122  3               	clc
002122  3               	adc #15
002122  3               	ldy #5
002122  3               	cmp (z80_ix),y	 	; fetch shrapnel coordinate.
002122  3               	bcs :+			; compare with window limit.
002122  3               	jmp kilshr		; off screen, kill shrapnel.
002122  3               :
002122  3               
002122  3               ;----------------------------------------------------
002122  3               ; Drop through.
002122  3               ; Display shrapnel.
002122  3               ;----------------------------------------------------
002122  3               
002122  3               plot:
002122  3               	ldy #3
002122  3               	lda (z80_ix),y		; y integer.
002122  3               	sta dispy	 	; workspace coordinates.
002122  3               	ldy #5
002122  3               	lda (z80_ix),y	 	; x integer.
002122  3               	sta dispx 		; workspace coordinates.
002122  3               
002122  3               	ldy #0
002122  3               	lda (z80_ix),y 		; type.
002122  3               	bne :+			; is it a laser?
002122  3               	jmp plot1 		; yes, draw laser instead.
002122  3               :
002122  3               plot0:
002122  3               	lda dispx		; which pixel within byte do we
002122  3               	and #7			; want to set first?
002122  3               	tay
002122  3               	lda dots,y 		; table of small pixel positions.
002122  3               	sta z80_e 		; get value.
002122  3               
002122  3               	jsr scadd 		; screen address.
002122  3               	ldy #0
002122  3               	lda (scraddr),y		; see what's already there.
002122  3               	eor z80_e
002122  3               	sta (scraddr),y 	; put back on screen.
002122  3               	rts
002122  3               
002122  3               plot1:
002122  3               	jsr scadd 		; screen address.
002122  3               	ldy #0
002122  3               	lda (scraddr),y 	; fetch byte there.
002122  3               	eor #255 		; toggle all bits.
002122  3               	sta (scraddr),y 	; new byte.
002122  3               	rts
002122  3               
002122  3               ;----------------------------------------------------
002122  3               ; Switch off shrapnel
002122  3               ;----------------------------------------------------
002122  3               
002122  3               kilshr:
002122  3               	lda #128
002122  3               	ldy #0
002122  3               	sta (z80_ix),y	; switch off shrapnel.
002122  3               	rts
002122  3               
002122  3               ;----------------------------------------------------
002122  3               ; Sine/cosine table
002122  3               ;----------------------------------------------------
002122  3               
002122  3               shrsin:	.word 0,1024,391,946,724,724,946,391
002122  3               	.word 1024,0,946,65144,724,64811,391,64589
002122  3               	.word 0,64512,65144,64589,64811,64811,64589,65144
002122  3               	.word 64512,0,64589,391,64811,724,65144,946
002122  3               
002122  3               ;----------------------------------------------------
002122  3               ; Create trail
002122  3               ;----------------------------------------------------
002122  3               
002122  3               trail:
002122  3               	ldy #1
002122  3               	lda (z80_ix),y 	; time remaining.
002122  3               	sec
002122  3               	sbc #1
002122  3               	sta (z80_ix),y
002122  3               	bne :+
002122  3               	jmp trailk		; time to switch it off.
002122  3               :
002122  3               	jsr qrand		; get a random number.
002122  3               	lsr a 			; x or y axis?
002122  3               	bcc :+
002122  3               	jmp trailv		; use y.
002122  3               :
002122  3               ; Trail horizontal
002122  3               
002122  3               	lsr a 			; which direction?
002122  3               	bcc :+
002122  3               	jmp traill		; go left.
002122  3               :
002122  3               ; Trail right
002122  3               
002122  3               	ldy #5
002122  3               	lda (z80_ix),y
002122  3               	clc
002122  3               	adc #1	 		; go right.
002122  3               	sta (z80_ix),y
002122  3               	rts
002122  3               
002122  3               ; Trail left
002122  3               
002122  3               traill:
002122  3               	ldy #5
002122  3               	lda (z80_ix),y
002122  3               	sec
002122  3               	sbc #1 			; go left.
002122  3               	sta (z80_ix),y
002122  3               	rts
002122  3               
002122  3               ; Trail vertical
002122  3               
002122  3               trailv:
002122  3               	lsr a		 	; which direction?
002122  3               	bcc :+
002122  3               	jmp trailu		; go up.
002122  3               :
002122  3               ; Trail down
002122  3               
002122  3               	ldy #3
002122  3               	lda (z80_ix),y
002122  3               	clc
002122  3               	adc #1 			; go down.
002122  3               	sta (z80_ix),y
002122  3               	rts
002122  3               
002122  3               ; Trail up
002122  3               
002122  3               trailu:
002122  3               	ldy #3
002122  3               	lda (z80_ix),y
002122  3               	sec
002122  3               	sbc #1 			; go up.
002122  3               	sta (z80_ix),y
002122  3               	rts
002122  3               
002122  3               ; Kill trail
002122  3               
002122  3               trailk:
002122  3               	lda #200		; set off-screen to kill vapour trail.
002122  3               	ldy #3
002122  3               	sta (z80_ix),y
002122  3               	rts
002122  3               
002122  3               ;----------------------------------------------------
002122  3               ; Create laser beam
002122  3               ;----------------------------------------------------
002122  3               
002122  3               laser:
002122  3               	ldy #1
002122  3               	lda (z80_ix),y 		; direction.
002122  3               	ror a 			; left or right?
002122  3               	bcs :+
002122  3               	jmp laserl		; move left.
002122  3               :
002122  3               ; Laser right
002122  3               
002122  3               	lda #8			; distance to travel.
002122  3               	sta z80_b
002122  3               	jmp laserm		; move laser.
002122  3               
002122  3               ; Laser left
002122  3               
002122  3               laserl:
002122  3               	lda #248		; distance to travel.
002122  3               	sta z80_b
002122  3               laserm:
002122  3               	ldy #5
002122  3               	lda (z80_ix),y		; x position.
002122  3               	clc
002122  3               	adc z80_b		; add distance.
002122  3               	sta (z80_ix),y		; set new x coordinate.
002122  3               
002122  3               ; Test new block.
002122  3               
002122  3               	sta dispx 		; set x for block collision detection purposes.
002122  3               	ldy #3
002122  3               	lda (z80_ix),y 		; get y.
002122  3               	sta dispy		; set coordinate for collision test.
002122  3               	jsr tstbl 		; get block type there.
002122  3               	cmp #WALL		; is it solid?
002122  3               	bne :+
002122  3               	jmp trailk		; yes, it cannot pass.
002122  3               :
002122  3               .if pflag .or dflag
002122  3                       cmp #FODDER             ; is it fodder?
002122  3                       bne :+
002122  3                       jsr fdchk               ; remove fodder block.
002122  3                       jmp trailk              ; destroy laser.
002122  3               :
002122  3               .endif
002122  3                       rts                     ; no, ignore it.
002122  3               
002122  3               ;----------------------------------------------------
002122  3               ; Dots mask
002122  3               ;----------------------------------------------------
002122  3               
002122  3               dots:	.byte 128,64,32,16,8,4,2,1
002122  3               
002122  3               
002122  3               ;----------------------------------------------------
002122  3               ; Plot, preserving de.
002122  3               ;----------------------------------------------------
002122  3               
002122  3               plotde:
002122  3               	lda z80_d 		; put de on stack.
002122  3               	pha
002122  3               	lda z80_e
002122  3               	pha
002122  3               
002122  3               	jsr plot 		; plot pixel.
002122  3               
002122  3               	pla			; restore de from stack.
002122  3               	sta z80_e
002122  3               	pla
002122  3               	sta z80_d
002122  3               
002122  3               	rts
002122  3               
002122  3               ;----------------------------------------------------
002122  3               ; Shoot a laser.
002122  3               ;----------------------------------------------------
002122  3               
002122  3               shoot:
002122  3               	sta z80_c		; store direction in c register.
002122  3               	ldy #8
002122  3               	lda (z80_ix),y 		; y coordinate.
002122  3               	clc
002122  3               shoot1:
002122  3               	adc #(SPR_HGT/2-1)	; down 7 pixels.
002122  3               	sta z80_l 		; puty y coordinate in l.
002122  3               
002122  3               	ldy #9
002122  3               	lda (z80_ix),y 		; x coordinate in h.
002122  3               	sta z80_h
002122  3               
002122  3               	lda z80_i		; store pointer to sprite.
002122  3               	pha
002122  3               	lda z80_x
002122  3               	pha
002122  3               
002122  3               	jsr fpslot 		; find particle slot.
002122  3               	bcs :+
002122  3               	jmp vapou2		; failed, restore ix.
002122  3               :
002122  3               	lda #0
002122  3               	ldy #0
002122  3               	sta (z80_ix),y 		; set up a laser.
002122  3               
002122  3               	lda z80_c
002122  3               	ldy #1
002122  3               	sta (z80_ix),y 		; set the direction.
002122  3               
002122  3               	lda z80_l
002122  3               	ldy #3
002122  3               	sta (z80_ix),y		; set y coordinate.
002122  3               
002122  3               	ror z80_c		; check direction we want.
002122  3               	bcc :+
002122  3               	jmp shootr		; shoot right.
002122  3               :
002122  3               	lda z80_h		; X position.
002122  3               shoot0:
002122  3               	and #248		; align on character boundary.
002122  3               	ldy #5
002122  3               	sta (z80_ix),y		; set x coordinate.
002122  3               	jmp vapou0 		; draw first image.
002122  3               shootr:
002122  3               	lda z80_h		; x position.
002122  3               	clc
002122  3               	adc #15			; look right.
002122  3               	jmp shoot0		; align and continue.
002122  3               
002122  3               ;----------------------------------------------------
002122  3               ; Create a bit of vapour trail.
002122  3               ;----------------------------------------------------
002122  3               
002122  3               vapour:
002122  3               	lda z80_i		; store pointer to sprite.
002122  3               	pha
002122  3               	lda z80_x
002122  3               	pha
002122  3               
002122  3               	ldy #8
002122  3               	lda (z80_ix),y 		; y coordinate.
002122  3               	clc
002122  3               vapou3:
002122  3               	adc #(SPR_HGT/2-1)	; mid-point of sprite.
002122  3               	sta z80_l
002122  3               
002122  3               	ldy #9
002122  3               	lda (z80_ix),y 		; x coordinate.
002122  3               	adc #7
002122  3               	sta z80_h
002122  3               
002122  3               	jsr fpslot 		; find particle slot.
002122  3               	bcc :+
002122  3               	jmp vapou1		; no, we can use it.
002122  3               :
002122  3               vapou2:
002122  3               	pla
002122  3               	sta z80_x
002122  3               	pla
002122  3               	sta z80_i
002122  3               	rts
002122  3               vapou1:
002122  3               	lda z80_l
002122  3               	ldy #3
002122  3               	sta (z80_ix),y		; set up y.
002122  3               
002122  3               	lda z80_h
002122  3               	ldy #5
002122  3               	sta (z80_ix),y 		; set up x coordinate.
002122  3               
002122  3               	jsr qrand		; get quick random number.
002122  3               	and #15			; random time.
002122  3               	clc
002122  3               	adc #15			; minimum time on screen.
002122  3               	ldy #1
002122  3               	sta (z80_ix),y		; set time on screen.
002122  3               
002122  3               	lda #1
002122  3               	ldy #0
002122  3               	sta (z80_ix),y		; define particle as vapour trail.
002122  3               vapou0:
002122  3               	jsr chkxy		; plot first position.
002122  3               	jmp vapou2
002122  3               
002122  3               ;----------------------------------------------------
002122  3               ; Create a user particle.
002122  3               ;----------------------------------------------------
002122  3               
002122  3               ptusr:
002122  3               	sta z80_f		; store timer.
002122  3               
002122  3               	ldy #8
002122  3               	lda (z80_ix),y 		; y coordinate.
002122  3               	clc
002122  3               	adc #7			; mid-point of sprite.
002122  3               	sta z80_l
002122  3               
002122  3               	ldy #9
002122  3               	lda (z80_ix),y 		; x coordinate.
002122  3               	clc
002122  3               	adc #7			; mid-point of sprite.
002122  3               	sta z80_h
002122  3               
002122  3               	jsr fpslot 		; find particle slot.
002122  3               	bcs ptusr1
002122  3               	rts 			; out of slots, can't generate anything.
002122  3               ptusr1:
002122  3               	lda z80_l
002122  3               	ldy #3
002122  3               	sta (z80_ix),y 		; set up y.
002122  3               
002122  3               	lda z80_h
002122  3               	ldy #5
002122  3               	sta (z80_ix),y		; set up x coordinate.
002122  3               
002122  3               	lda z80_f 		; restore timer.
002122  3               	ldy #1
002122  3               	sta (z80_ix),y		; set time on screen.
002122  3               
002122  3               	lda #7
002122  3               	ldy #0
002122  3               	sta (z80_ix),y		; define particle as user particle.
002122  3               
002122  3               	jmp chkxy		; plot first position.
002122  3               
002122  3               ;----------------------------------------------------
002122  3               ; Create a vertical or horizontal star.
002122  3               ;----------------------------------------------------
002122  3               
002122  3               star:
002122  3               	lda z80_i		; store pointer to sprite.
002122  3               	pha
002122  3               	lda z80_x
002122  3               	pha
002122  3               
002122  3               	jsr fpslot 		; find particle slot.
002122  3               	bcs star7		; found one we can use.
002122  3               star0:
002122  3               	pla 			; restore sprite pointer.
002122  3               	sta z80_x
002122  3               	pla
002122  3               	sta z80_i
002122  3               	rts 			; out of slots, can't generate anything.
002122  3               star7:
002122  3               	lda z80_c		; direction.
002122  3               	and #3 			; is it left?
002122  3               	bne :+
002122  3               	jmp star1 		; yes, it's left.
002122  3               :
002122  3               	cmp #1 			; is it right?
002122  3               	bne :+
002122  3               	jmp star2 		; yes, it's right.
002122  3               :
002122  3               	cmp #2 			; is it up?
002122  3               	bne :+
002122  3               	jmp star3 		; yes, it's up.
002122  3               :
002122  3               	ldy wntopx 		; get edge of screen.
002122  3               	iny			; down one pixel.
002122  3               	tya
002122  3               star8:
002122  3               	ldy #3
002122  3               	sta (z80_ix),y 		; set y coord.
002122  3               	jsr qrand 		; get quick random number.
002122  3               star9:
002122  3               	ldy #5
002122  3               	sta (z80_ix),y		; set x position.
002122  3               
002122  3               	lda z80_c		; direction.
002122  3               	and #3			; zero to three.
002122  3               	clc
002122  3               	adc #3			; 3 to 6 for starfield.
002122  3               	ldy #0
002122  3               	sta (z80_ix),y		; define particle as star.
002122  3               	jsr chkxy		; plot first position.
002122  3               	jmp star0
002122  3               star1:
002122  3               	jsr qrand		; get quick random number.
002122  3               	ldy #3
002122  3               	sta (z80_ix),y 		; set y coord.
002122  3               
002122  3               	lda wnrgtx 		; get edge of screen.
002122  3               	clc
002122  3               	adc #15			; add width of sprite minus 1.
002122  3               	jmp star9
002122  3               star2:
002122  3               	jsr qrand 		; get quick random number.
002122  3               	ldy #3
002122  3               	sta (z80_ix),y		; set y coord.
002122  3               
002122  3               	lda wnlftx		; get edge of screen.
002122  3               	jmp star9
002122  3               star3:
002122  3               	lda wnbotx 		; get edge of screen.
002122  3               	clc
002122  3               	adc #15 		; height of sprite minus one pixel.
002122  3               	jmp star8
002122  3               
002122  3               ;----------------------------------------------------
002122  3               ; Find particle slot for lasers or vapour trail.
002122  3               ; can't use alternate accumulator.
002122  3               ;----------------------------------------------------
002122  3               
002122  3               fpslot:
002122  3               	lda #<SHRAPN 		; shrapnel table.
002122  3               	sta z80_x
002122  3               	lda #>SHRAPN
002122  3               	sta z80_i
002122  3               
002122  3               	lda #NUMSHR		; number of pieces in table.
002122  3               	sta z80_b
002122  3               fpslt0:
002122  3               	ldy #0
002122  3               	lda (z80_ix),y		; get type.
002122  3               	asl a  			; is this slot in use?
002122  3               	bcc :+
002122  3               	rts			; no, we can use it.
002122  3               :
002122  3               	clc			; point to more shrapnel.
002122  3               	lda z80_x
002122  3               	adc #SHRSIZ
002122  3               	sta z80_x
002122  3               	bcc :+
002122  3               	inc z80_i
002122  3               :
002122  3               	dec z80_b		; repeat for all shrapnel.
002122  3               	bne fpslt0
002122  3               
002122  3               	clc
002122  3               	rts 			; out of slots, can't generate anything.
002122  3               
002122  3               ;----------------------------------------------------
002122  3               ; Create an explosion at sprite position.
002122  3               ;----------------------------------------------------
002122  3               
002122  3               explod:
002122  3               	sta z80_c 		; particles to create.
002122  3               
002122  3               	lda z80_i 		; store pointer to sprite.
002122  3               	pha
002122  3               	lda z80_x
002122  3               	pha
002122  3               
002122  3               	ldy #8
002122  3               	lda (z80_ix),y 		; y coordinate.
002122  3               	sta z80_l
002122  3               	ldy #9
002122  3               	lda (z80_ix),y		; x coordinate.
002122  3               	sta z80_h
002122  3               
002122  3               	lda #<SHRAPN		; shrapnel table.
002122  3               	sta z80_x
002122  3               	lda #>SHRAPN
002122  3               	sta z80_i
002122  3               
002122  3               	lda #NUMSHR		; number of pieces in table.
002122  3               	sta explcnt
002122  3               expld0:
002122  3               	ldy #0
002122  3               	lda (z80_ix),y		; get type.
002122  3               	asl a 			; is this slot in use?
002122  3               	bcs expld1		; no, we can use it.
002122  3               expld2:
002122  3               	clc
002122  3               	lda z80_x
002122  3               	adc #SHRSIZ
002122  3               	sta z80_x
002122  3               	bcc :+
002122  3               	inc z80_i
002122  3               :
002122  3               	dec explcnt		; repeat for all shrapnel.
002122  3               	bne expld0
002122  3               expld3:
002122  3               	pla			; restore sprite pointer.
002122  3               	sta z80_x
002122  3               	pla
002122  3               	sta z80_i
002122  3               	rts 			; out of slots, can't generate any more.
002122  3               
002122  3               expld1:
002122  3               	lda z80_c		; shrapnel counter.
002122  3               	and #15			; 0 to 15.
002122  3               	clc			; add to x.
002122  3               	adc z80_l
002122  3               	ldy #3
002122  3               	sta (z80_ix),y		; y coord.
002122  3               
002122  3               	lda seed3 		; crap random number.
002122  3               	and #15			; 0 to 15.
002122  3               	clc 			; add to y.
002122  3               	adc z80_h
002122  3               	ldy #5
002122  3               	sta (z80_ix),y		; x coord.
002122  3               
002122  3               	lda #2
002122  3               	ldy #0
002122  3               	sta (z80_ix),y		; switch it on.
002122  3               
002122  3               	jsr chkxy		; plot first position.
002122  3               	jsr qrand		; quick random angle.
002122  3               	and #60 		; keep within range.
002122  3               	ldy #1
002122  3               	sta (z80_ix),y		; angle.
002122  3               
002122  3               	dec z80_c		; one less piece of shrapnel to generate.
002122  3               	bne expld2 		; back to main explosion loop.
002122  3               	jmp expld3 		; restore sprite pointer and exit.
002122  3               
002122  3               ;explcnt:	.byte 0
002122  3               
002122  3               ;----------------------------------------------------
002122  3               ; Quick random
002122  3               ;----------------------------------------------------
002122  3               
002122  3               qrand:
002122  3               	jsr random		; r register.
002122  3               	eor seed3		; combine with seed.
002122  3               	sta seed3 		; new seed.
002122  3               	rts
002122  3               
002122  3               ;seed3:	.byte 0
002122  3               
002122  3               ;----------------------------------------------------
002122  3               ; Display all shrapnel.
002122  3               ;----------------------------------------------------
002122  3               
002122  3               dshrp:
002122  3               	lda #<plotde		; display routine.
002122  3               	sta proshx+1
002122  3               	lda #>plotde
002122  3               	sta proshx+2
002122  3               	jsr proshr		; process shrapnel.
002122  3               
002122  3               	lda #<prosh1		; processing routine.
002122  3               	sta proshx+1
002122  3               	lda #>prosh1
002122  3               	sta proshx+2
002122  3               	rts
002122  3               
002122  3               ;------------------------------------------------------
002122  3               ; Particle engine.
002122  3               ;
002122  3               ; Init particle data for 55 particles in SHRAPN table.
002122  3               ; Every particle has 6 bytes.
002122  3               ;
002122  3               ; global:	-
002122  3               ; local:	x,y,hl
002122  3               ; calls:	-
002122  3               ;------------------------------------------------------
002122  3               
002122  3               inishr:
002122  3               	lda #<SHRAPN 		; table.
002122  3               	sta z80_l
002122  3               	lda #>SHRAPN
002122  3               	sta z80_h
002122  3               
002122  3               	ldy #0
002122  3               	ldx #NUMSHR		; shrapnel pieces to process.
002122  3               inish0:
002122  3               	lda #255 		; kill the shrapnel.
002122  3               	sta (z80_hl),y
002122  3               
002122  3               	clc 			; point there.
002122  3               	lda z80_l
002122  3               	adc #SHRSIZ		; distance to next.
002122  3               	sta z80_l
002122  3               	bcc :+
002122  3               	inc z80_h
002122  3               :
002122  3               	dex
002122  3               	bne inish0 		; round again.
002122  3               	rts
002122  3               
002122  3               ;------------------------------------------------------
002122  3               ; Check for collision between laser and sprite.
002122  3               ;------------------------------------------------------
002122  3               
002122  3               lcol:
002122  3               	lda #<SHRAPN		; shrapnel table.
002122  3               	sta z80_l
002122  3               	lda #>SHRAPN
002122  3               	sta z80_h
002122  3               
002122  3               	lda #NUMSHR		; number of pieces in table.
002122  3               	sta z80_b
002122  3               lcol0:
002122  3               	ldy #0
002122  3               	lda (z80_hl),y 		; get type.
002122  3               	beq lcol1		; yes, check collision.
002122  3               lcol3:
002122  3               	clc			; point to more shrapnel.
002122  3               	lda z80_l
002122  3               	adc #SHRSIZ
002122  3               	sta z80_l
002122  3               	bcc :+
002122  3               	inc z80_h
002122  3               :
002122  3               	dec z80_b		; repeat for all shrapnel.
002122  3               	bne lcol0
002122  3               	rts 			; no collision, carry not set.
002122  3               lcol1:
002122  3               	ldy #3
002122  3               	lda (z80_hl),y		; get y.
002122  3               	sec
002122  3               	ldy #8
002122  3               	sbc (z80_ix),y		; subtract sprite y.
002122  3               lcolh:
002122  3               	cmp #SPR_HGT 		; within range?
002122  3               	bcc :+
002122  3               	jmp lcol2		; no, missed.
002122  3               :
002122  3               	ldy #5
002122  3               	lda (z80_hl),y 		; get x.
002122  3               	sec
002122  3               	ldy #9
002122  3               	sbc (z80_ix),y 		; subtract sprite y.
002122  3               	cmp #16			; within range?
002122  3               	bcs :+
002122  3               	jmp lcol4 		; yes, collision occurred.
002122  3               :
002122  3               lcol2:
002122  3               	jmp lcol3
002122  3               lcol4:
002122  3               	sec
002122  3               	rts 			; return with carry set for collision.
002122  3               .endif
002122  3               
002122  3               ;------------------------------------------------------
002122  3               ; Main game engine code starts here.
002122  3               ; After initialisation, mloop is the main loop
002122  3               ;------------------------------------------------------
002122  3               
002122  3               game:
002122  3               
002122  3               ; Set up screen address table.
002122  3               
002122  3               setsat:
002122  3  A9 00        	lda #<ScreenAddr		; start of screen.
002124  3  85 rr        	sta scraddr
002126  3  A9 80        	lda #>ScreenAddr
002128  3  85 rr        	sta scraddr+1
00212A  3               
00212A  3  A0 00        	ldy #0			; vertical lines on screen.
00212C  3               setsa0:
00212C  3  A5 rr        	lda scraddr
00212E  3  99 00 9B     	sta SCADTB_lb,y		; write low byte.
002131  3  A5 rr        	lda scraddr+1
002133  3  C0 C0        	cpy #192		; vertical lines on screen.
002135  3  90 02        	bcc :+
002137  3  09 F0        	ora #$F0		; plot sprites in rom if of screen
002139  3               :
002139  3  99 00 9C     	sta SCADTB_hb,y		; write high byte.
00213C  3  20 E5 2E     	jsr nline		; next line down.
00213F  3  C8           	iny			; next position in table.
002140  3  D0 EA        	bne setsa0
002142  3               
002142  3               ; Init graphics mode
002142  3               
002142  3  A9 F0        	lda #ScrMode		; graphics mode
002144  3  8D 00 B0     	sta ScrSelAddr 		; screen selection address
002147  3  20 20 21     	jsr setpal 		; set up palette.
00214A  3               
00214A  3               ; Init AtoMMC joystick
00214A  3  20 15 2A     	jsr joyinit		; AtoMMC joystick on PORT B
00214D  3               
00214D  3               rpblc2:
00214D  3               .if pflag
00214D  3               	jsr inishr 		; initialise particle engine.
00214D  3               .endif
00214D  3               evintr:
00214D  3  20 B1 34     	jsr evnt12 		; call intro/menu event.
002150  3               
002150  3  A9 02        	lda #WALL 		; write default property.
002152  3  A2 00        	ldx #0
002154  3               clrmap:
002154  3  9D 00 98     	sta MAP,x 		; block properties.
002157  3  9D 00 99     	sta MAP+256,x
00215A  3  9D 00 9A     	sta MAP+512,x
00215D  3  E8           	inx			; next byte.
00215E  3  D0 F4        	bne clrmap
002160  3               .if oflag
002160  3               	jsr iniob 		; initialise objects.
002160  3               .endif
002160  3  A9 00        	lda #0			; put zero in accumulator.
002162  3  85 rr        	sta gamwon		; reset game won flag.
002164  3               
002164  3  20 CF 22     	jsr inisc 		; init the score.
002167  3               mapst:
002167  3  AD 44 34     	lda stmap 		; start position on map.
00216A  3  8D 10 34     	sta roomtb		; set up position in table, if there is one.
00216D  3               
00216D  3               inipbl:
00216D  3               .if aflag
00216D  3               	lda #<eop		; reset blockpointer
00216D  3               	sta pbptr
00216D  3               	lda #>eop
00216D  3               	sta pbptr+1
00216D  3               .endif
00216D  3  20 F8 2F     	jsr initsc 		; set up first screen.
002170  3               
002170  3  A9 FF        	lda #<ssprit 		; default to spare sprite in table.
002172  3  85 68        	sta z80_x
002174  3  A9 33        	lda #>ssprit
002176  3  85 69        	sta z80_i
002178  3               evini:
002178  3  20 B5 34     	jsr evnt13 		; initialisation.
00217B  3               
00217B  3               ; Two restarts.
00217B  3               ; First restart - clear all sprites and initialise everything.
00217B  3               
00217B  3               rstrt:
00217B  3  20 6F 22     	jsr rsevt 		; restart events.
00217E  3  20 79 20     	jsr xspr 		; clear sprite table.
002181  3  20 64 31     	jsr sprlst 		; fetch pointer to screen sprites.
002184  3  20 ED 31     	jsr ispr 		; initialise sprite table.
002187  3               
002187  3  4C 96 21     	jmp rstrt0
00218A  3               
00218A  3               ; Second restart - clear all but player, and don't initialise him.
00218A  3               
00218A  3               rstrtn:
00218A  3  20 6F 22     	jsr rsevt		; restart events.
00218D  3  20 91 31     	jsr nspr 		; clear all non-player sprites.
002190  3  20 64 31     	jsr sprlst 		; fetch pointer to screen sprites.
002193  3  20 2A 32     	jsr kspr 		; initialise sprite table, no more players.
002196  3               
002196  3               ; Set up the player and/or enemy sprites.
002196  3               
002196  3               rstrt0:
002196  3  A9 00        	lda #0 			; zero in accumulator.
002198  3  85 rr        	sta nexlev 		; reset next level flag.
00219A  3  85 rr        	sta restfl 		; reset restart flag.
00219C  3  85 rr        	sta deadf 		; reset dead flag.
00219E  3  20 3D 26     	jsr droom 		; show screen layout.
0021A1  3               rpblc0:
0021A1  3               .if pflag
0021A1  3               	jsr inishr 		; initialise particle engine.
0021A1  3               .endif
0021A1  3               .if aflag
0021A1  3               	jsr rbloc		; draw blocks for this screen
0021A1  3               .endif
0021A1  3               .if oflag
0021A1  3               	jsr shwob		; draw objects.
0021A1  3               .endif
0021A1  3               
0021A1  3  A9 33        	lda #<sprtab 		; address of sprite table, even sprites.
0021A3  3  85 68        	sta z80_x
0021A5  3  A9 33        	lda #>sprtab
0021A7  3  85 69        	sta z80_i
0021A9  3  20 D6 2C     	jsr dspr 		; display sprites.
0021AC  3               
0021AC  3  A9 44        	lda #<(sprtab+TABSIZ) 	; address of first odd sprite.
0021AE  3  85 68        	sta z80_x
0021B0  3  A9 33        	lda #>(sprtab+TABSIZ)
0021B2  3  85 69        	sta z80_i
0021B4  3  20 D6 2C     	jsr dspr 		; display sprites.
0021B7  3               mloop:
0021B7  3  20 86 20     	jsr vsync 		; synchronise with display.
0021BA  3  A9 33        	lda #<sprtab 		; address of sprite table, even sprites.
0021BC  3  85 68        	sta z80_x
0021BE  3  A9 33        	lda #>sprtab
0021C0  3  85 69        	sta z80_i
0021C2  3  20 D6 2C     	jsr dspr 		; display even sprites.
0021C5  3               
0021C5  3               ;	jsr plsnd 		; play sounds.
0021C5  3               
0021C5  3  20 21 21     	jsr proshr
0021C8  3  A9 44        	lda #<(sprtab+TABSIZ) 	; address of first odd sprite.
0021CA  3  85 68        	sta z80_x
0021CC  3  A9 33        	lda #>(sprtab+TABSIZ)
0021CE  3  85 69        	sta z80_i
0021D0  3  20 D6 2C     	jsr dspr 		; display odd sprites.
0021D3  3               
0021D3  3  A9 FF        	lda #<(ssprit) 		; point to spare sprite for spawning purposes.
0021D5  3  85 68        	sta z80_x
0021D7  3  A9 33        	lda #>(ssprit)
0021D9  3  85 69        	sta z80_i
0021DB  3               evlp1:
0021DB  3  20 4F 34     	jsr evnt10 		; called once per main loop.
0021DE  3  20 54 2C     	jsr pspr 		; process sprites.
0021E1  3               
0021E1  3               ; Main loop events.
0021E1  3               
0021E1  3  A9 FF        	lda #<ssprit 		; point to spare sprite for spawning purposes.
0021E3  3  85 68        	sta z80_x
0021E5  3  A9 33        	lda #>ssprit
0021E7  3  85 69        	sta z80_i
0021E9  3               evlp2:
0021E9  3  20 B0 34     	jsr evnt11 		; called once per main loop.
0021EC  3               bsortx:
0021EC  3  20 CA 2B     	jsr bsort 		; sort sprites.
0021EF  3               
0021EF  3  A5 rr        	lda nexlev		; finished level flag.
0021F1  3  F0 03        	beq :+
0021F3  3  4C 1B 22     	jmp newlev		; is set, go to next level.
0021F6  3               :
0021F6  3  A5 rr        	lda gamwon		; finished game flag.
0021F8  3  F0 03        	beq :+
0021FA  3  4C 2A 22     	jmp evwon		; is set, finish the game.
0021FD  3               :
0021FD  3  A5 rr        	lda restfl 		; finished level flag.
0021FF  3  C9 01        	cmp #1			; has it been set?
002201  3  D0 03        	bne :+
002203  3  4C 7B 21     	jmp rstrt		; yes, go to next level.
002206  3               :
002206  3  C9 02        	cmp #2			; has it been set?
002208  3  D0 03        	bne :+
00220A  3  4C 8A 21     	jmp rstrtn		; yes, go to next level.
00220D  3               :
00220D  3  A5 rr        	lda deadf 		; dead flag.
00220F  3  F0 03        	beq :+
002211  3  4C 30 22     	jmp pdead		; yes, player dead.
002214  3               :
002214  3               ; back to start of main loop.
002214  3               
002214  3  E6 rr        	inc frmno
002216  3  E6 rr        	inc clock
002218  3  4C B7 21     	jmp mloop		; switched to a jmp mloop during test mode.
00221B  3               
00221B  3               ;----------------------------------------------------------
00221B  3               ; Read blocks from list and update screen accordingly.
00221B  3               ;----------------------------------------------------------
00221B  3               
00221B  3               .if aflag
00221B  3               rbloc:
00221B  3               	lda #<eop		; reset temp blockpointer
00221B  3               	sta pbbuf
00221B  3               	lda #>eop
00221B  3               	sta pbbuf+1
00221B  3               
00221B  3               rbloc2:
00221B  3               	lda pbbuf			; check for last block
00221B  3               	cmp pbptr
00221B  3               	bne rbloc1
00221B  3               	lda pbbuf+1
00221B  3               	cmp pbptr+1
00221B  3               	bne rbloc1
00221B  3               	rts
00221B  3               rbloc1:
00221B  3               	ldy #0
00221B  3               	lda (pbbuf),y		; check if block for this scno
00221B  3               	cmp scno
00221B  3               	bne rbloc0		; if not, skip
00221B  3               	iny
00221B  3               	lda (pbbuf),y		; get y
00221B  3               	sta dispy
00221B  3               	iny
00221B  3               	lda (pbbuf),y		; get x
00221B  3               	sta dispx
00221B  3               	iny
00221B  3               	lda (pbbuf),y		; get blocknr
00221B  3               	jsr pattr2		; draw block
00221B  3               rbloc0:
00221B  3               	clc			; point to next block
00221B  3               	lda pbbuf
00221B  3               	adc #4
00221B  3               	sta pbbuf
00221B  3               	bcc rbloc2
00221B  3               	inc pbbuf+1
00221B  3               	jmp rbloc2
00221B  3               .endif
00221B  3               
00221B  3               ;----------------------------------------------------------
00221B  3               ; New level
00221B  3               ;----------------------------------------------------------
00221B  3               
00221B  3               ;.repeat 270
00221B  3               ;  .byte 0
00221B  3               ;.endrep
00221B  3               
00221B  3               newlev:
00221B  3  A5 rr        	lda scno 			; current screen.
00221D  3  18           	clc
00221E  3  69 01        	adc #1				; next screen.
002220  3  CD 84 35     	cmp numsc			; total number of screens.
002223  3  B0 05        	bcs evwon			; yes, game finished.
002225  3  85 rr        	sta scno			; set new level number.
002227  3  4C 7B 21     	jmp rstrt			; restart, clearing all aliens.
00222A  3               
00222A  3               evwon:
00222A  3  20 BA 34     	jsr evnt18		 	; game completed.
00222D  3  4C 44 22     	jmp tidyup			; tidy up and return to BASIC/calling routine.
002230  3               
002230  3               ;----------------------------------------------------------
002230  3               ; Player dead.
002230  3               ;----------------------------------------------------------
002230  3               
002230  3               ;.repeat 258
002230  3               ;  .byte 0
002230  3               ;.endrep
002230  3               
002230  3               pdead:
002230  3  A9 00        	lda #0				; zeroise accumulator.
002232  3  85 rr        	sta deadf			; reset dead flag.
002234  3               evdie:
002234  3  20 B8 34     	jsr evnt16 			; death subroutine.
002237  3  A5 rr        	lda numlif			; number of lives.
002239  3  F0 03        	beq :+
00223B  3  4C 7B 21     	jmp rstrt 			; restart game.
00223E  3               :
00223E  3               evfail:
00223E  3  20 B9 34     	jsr evnt17 			; failure event.
002241  3  4C 22 21     	jmp game			; restart game
002244  3               
002244  3               ;----------------------------------------------------------
002244  3               ; Tidy things up
002244  3               ;----------------------------------------------------------
002244  3               
002244  3               ;.repeat 291
002244  3               ;  .byte 0
002244  3               ;.endrep
002244  3               
002244  3               tidyup:
002244  3  A0 00        	ldy #0				; digits to check.
002246  3               tidyu2:
002246  3  B9 B8 23     	lda score,y 			; get score digit.
002249  3  CD BE 23     	cmp hiscor 			; are we larger than high score digit?
00224C  3  90 07        	bcc tidyu0			; high score is bigger.
00224E  3  D0 0E        	bne tidyu1			; score is greater, record new high score.
002250  3  C8           	iny				; next digit of high score.
002251  3  C0 06        	cpy #6
002253  3  D0 F1        	bne tidyu2			; repeat for all digits
002255  3               tidyu0:
002255  3  A9 B8        	lda #<score			; return pointing to score.
002257  3  85 62        	sta z80_c
002259  3  A9 23        	lda #>score
00225B  3  85 63        	sta z80_b
00225D  3  60           	rts
00225E  3               tidyu1:
00225E  3  A0 05        	ldy #5
002260  3               tidyu3:
002260  3  B9 B8 23     	lda score,y			; score.
002263  3  99 BE 23     	sta hiscor,y			; high score.
002266  3  88           	dey
002267  3  10 F7        	bpl tidyu3 			; copy score to high score.
002269  3               evnewh:
002269  3  20 BB 34     	jsr evnt19			; new high score event.
00226C  3  4C 55 22     	jmp tidyu0			; tidy up.
00226F  3               
00226F  3               ;--------------------------------------------------
00226F  3               ; Restart event.
00226F  3               ;--------------------------------------------------
00226F  3               
00226F  3               rsevt:
00226F  3  A9 FF        	lda #<ssprit 			; default to spare element in table.
002271  3  85 68        	sta z80_x
002273  3  A9 33        	lda #>ssprit
002275  3  85 69        	sta z80_i
002277  3               evrs:
002277  3  4C B6 34     	jmp evnt14	 		; call restart event.
00227A  3               
00227A  3               ;------------------------------------------------------------------
00227A  3               ; Copy number passed in a to string position bc, right-justified.
00227A  3               ;
00227A  3               ; Input:
00227A  3               ;  A  = number
00227A  3               ;  BC = string address
00227A  3               ;
00227A  3               ; Output:
00227A  3               ;  BC = string with number
00227A  3               ;-----------------------------------------------------------------
00227A  3               
00227A  3               num2ch:
00227A  3  85 65        	sta z80_d		; Save number
00227C  3               
00227C  3  A9 00        	lda #0
00227E  3  85 rr        	sta flag
002280  3               numdg3:
002280  3  A2 64        	ldx #100		; hundreds column.
002282  3  86 64        	stx z80_e
002284  3  20 94 22     	jsr numdg		; show digit.
002287  3               numdg2:
002287  3  A2 0A        	ldx #10			; tens column.
002289  3  86 64        	stx z80_e
00228B  3  20 94 22     	jsr numdg		; show digit.
00228E  3               
00228E  3  E6 rr        	inc flag
002290  3  A2 01        	ldx #1			; units column.
002292  3  86 64        	stx z80_e
002294  3               numdg:
002294  3  A9 30        	lda #48			; clear digit.
002296  3  85 61        	sta z80_a
002298  3               numdg1:
002298  3  A5 65        	lda z80_d
00229A  3  C5 64        	cmp z80_e
00229C  3  90 0E        	bcc numdg0		; nothing to show.
00229E  3  38           	sec
00229F  3  A5 65        	lda z80_d
0022A1  3  E5 64        	sbc z80_e		; subtract from column.
0022A3  3  85 65        	sta z80_d
0022A5  3  E6 61        	inc z80_a		; increment digit.
0022A7  3  E6 rr        	inc flag
0022A9  3  4C 98 22     	jmp numdg1		; repeat until column is zero.
0022AC  3               numdg0:
0022AC  3  A0 00        	ldy #0
0022AE  3  A5 61        	lda z80_a
0022B0  3  91 62        	sta (z80_bc),y		; write digit to buffer.
0022B2  3  A5 rr        	lda flag
0022B4  3  F0 06        	beq :+
0022B6  3  E6 62        	inc z80_c		; next buffer position.
0022B8  3  D0 02        	bne :+
0022BA  3  E6 63        	inc z80_b
0022BC  3               :
0022BC  3  60           	rts
0022BD  3               num2dd:
0022BD  3  85 65        	sta z80_d		; Save number
0022BF  3               
0022BF  3  A9 01        	lda #1
0022C1  3  85 rr        	sta flag
0022C3  3               
0022C3  3  4C 87 22     	jmp numdg2
0022C6  3               num2td:
0022C6  3  85 65        	sta z80_d		; Save number
0022C8  3               
0022C8  3  A9 01        	lda #1
0022CA  3  85 rr        	sta flag
0022CC  3  4C 80 22     	jmp numdg3
0022CF  3               
0022CF  3               ;flag:	.byte 0
0022CF  3               
0022CF  3               ;---------------------------------------------------------
0022CF  3               ; Reset score to "000000"
0022CF  3               ;---------------------------------------------------------
0022CF  3               
0022CF  3               inisc:
0022CF  3  A9 30        	lda #'0'
0022D1  3  A2 05        	ldx #5			; digits to initialise.
0022D3  3               inisc0:
0022D3  3  9D B8 23     	sta score,x 		; write zero digit.
0022D6  3  CA           	dex			; next column.
0022D7  3  10 FA        	bpl inisc0		; repeat for all digits.
0022D9  3               
0022D9  3  60           	rts
0022DA  3               
0022DA  3               ;-----------------------------------------------------
0022DA  3               ; Multiply h by d and return in hl.
0022DA  3               ;
0022DA  3               ; Input:
0022DA  3               ;  H = first number
0022DA  3               ;  D = second number
0022DA  3               ;
0022DA  3               ; Output:
0022DA  3               ;  HL = result H x D
0022DA  3               ;-----------------------------------------------------
0022DA  3               
0022DA  3               imul:
0022DA  3  A5 65        	lda z80_d		; HL = H * D
0022DC  3  85 64        	sta z80_e
0022DE  3  A5 67        	lda z80_h
0022E0  3  85 62        	sta z80_c		; make c first multiplier.
0022E2  3               imul0:
0022E2  3  A9 00        	lda #0			; zeroise total.
0022E4  3  85 66        	sta z80_l
0022E6  3  85 67        	sta z80_h
0022E8  3               
0022E8  3  A5 67        	lda z80_h
0022EA  3  85 65        	sta z80_d		; zeroise high byte.
0022EC  3               
0022EC  3  A9 08        	lda #8			; repeat 8 times.
0022EE  3  85 63        	sta z80_b
0022F0  3               imul1:
0022F0  3  46 62        	lsr z80_c		; rotate rightmost bit into carry.
0022F2  3  90 0E        	bcc imul2		; wasn't set.
0022F4  3  18           	clc			; bit was set, so add de.
0022F5  3  A5 66        	lda z80_l
0022F7  3  65 64        	adc z80_e
0022F9  3  85 66        	sta z80_l
0022FB  3  A5 67        	lda z80_h
0022FD  3  65 65        	adc z80_d
0022FF  3  85 67        	sta z80_h
002301  3  18           	clc 			; reset carry.
002302  3               imul2:
002302  3  06 64        	asl z80_e 		; shift de 1 bit left.
002304  3  26 65        	rol z80_d
002306  3  C6 63        	dec z80_b
002308  3  D0 E6        	bne imul1		; repeat 8 times.
00230A  3               
00230A  3  60           	rts
00230B  3               
00230B  3               ;-----------------------------------------------
00230B  3               ; Divide d by e and return in d, remainder in a.
00230B  3               ;
00230B  3               ; Input:
00230B  3               ;  D = first number
00230B  3               ;  E = second number
00230B  3               ;
00230B  3               ; Output:
00230B  3               ;  D = result D/E
00230B  3               ;  A = remainder
00230B  3               ;-----------------------------------------------
00230B  3               
00230B  3               idiv:
00230B  3  A9 00        	lda #0
00230D  3  A0 08        	ldy #8		 	; bits to shift.
00230F  3  06 65        	asl z80_d
002311  3               idiv0:
002311  3  2A           	rol a 			; multiply d by 2.
002312  3  C5 64        	cmp z80_e 		; test if e is smaller.
002314  3  90 02        	bcc idiv1		; e is greater, no division this time.
002316  3  E5 64        	sbc z80_e		; subtract it.
002318  3               idiv1:
002318  3  26 65        	rol z80_d		; rotate into d.
00231A  3  88           	dey
00231B  3  D0 F4        	bne idiv0		; repeat
00231D  3  60           	rts
00231E  3               
00231E  3               ;---------------------------------------------------
00231E  3               ; Play AY sound effect
00231E  3               ;---------------------------------------------------
00231E  3               
00231E  3               plsnd:
00231E  3  60           	rts
00231F  3               
00231F  3               ;---------------------------------------------------
00231F  3               ; Objects handling.
00231F  3               ; 32 bytes for image
00231F  3               ; 3 for room, y and x
00231F  3               ; 3 for starting room, y and x.
00231F  3               ; 254 = disabled.
00231F  3               ; 255 = object in player"s pockets.
00231F  3               ;---------------------------------------------------
00231F  3               
00231F  3               ;---------------------------------------------------
00231F  3               ; Show items present.
00231F  3               ;---------------------------------------------------
00231F  3               
00231F  3               .if oflag
00231F  3               shwob:
00231F  3               	lda #<objdta 			; objects table.
00231F  3               	sta z80_l
00231F  3               	lda #>objdta
00231F  3               	sta z80_h
00231F  3               
00231F  3               	lda numob 			; number of objects in the game.
00231F  3               	sta sprcnt
00231F  3               shwob0:
00231F  3               	ldy #32 			; distance to room number.
00231F  3               	lda (z80_hl),y 			; same as an item?
00231F  3               	cmp scno 			; current location.
00231F  3               	bne :+
00231F  3               	jsr dobj 			; yes, display object.
00231F  3               :
00231F  3               	clc
00231F  3               	lda z80_l
00231F  3               	adc #38 			; distance to next item.
00231F  3               	sta z80_l
00231F  3               	lda z80_h
00231F  3               	adc #0
00231F  3               	sta z80_h	 		; point to it.
00231F  3               	dec sprcnt
00231F  3               	bne shwob0 			; repeat for others.
00231F  3               	rts
00231F  3               
00231F  3               ;---------------------------------------------------
00231F  3               ; Display object.
00231F  3               ; hl must point to object's start address.
00231F  3               ;
00231F  3               ; Input:
00231F  3               ;  HL = object address
00231F  3               ;---------------------------------------------------
00231F  3               
00231F  3               dobj:
00231F  3               	ldy #33
00231F  3               	lda (z80_hl),y 			; point to y.
00231F  3               	sta dispy
00231F  3               	iny
00231F  3               	lda (z80_hl),y 			; point to x.
00231F  3               	sta dispx
00231F  3               dobj1:
00231F  3               	jmp sprite 			; draw this sprite.
00231F  3               
00231F  3               ;--------------------------------------
00231F  3               ; Remove an object.
00231F  3               ;
00231F  3               ; Input:
00231F  3               ;  A = object number
00231F  3               ;--------------------------------------
00231F  3               
00231F  3               remob:
00231F  3               	cmp numob			; number of objects in game.
00231F  3               	bcc :+				; are we checking past the end?
00231F  3               	rts				; yes, can't get non-existent item.
00231F  3               :
00231F  3               	pha				; remember object.
00231F  3               	jsr getob			; pick it up if we haven't already got it.
00231F  3               	pla				; retrieve object number.
00231F  3               	jsr gotob			; get its address.
00231F  3               	lda #254
00231F  3               	ldy #32
00231F  3               	sta (z80_hl),y			; remove it.
00231F  3               	rts
00231F  3               
00231F  3               ;---------------------------------------------------
00231F  3               ; Pick up object number held in the accumulator.
00231F  3               ;
00231F  3               ; Input:
00231F  3               ;  A = object number
00231F  3               ;---------------------------------------------------
00231F  3               
00231F  3               getob:
00231F  3               	cmp numob 		; number of objects in game.
00231F  3               	bcc :+			; are we checking past the end?
00231F  3               	rts			; yes, can't get non-existent item.
00231F  3               :
00231F  3               	jsr gotob 		; check if we already have it.
00231F  3               	cmp #255
00231F  3               	bne :+
00231F  3               	rts			; we already do.
00231F  3               :
00231F  3               	ldy #32
00231F  3               	lda (z80_hl),y		; is it on this screen?
00231F  3               	cmp scno 		; current screen.
00231F  3               	bne getob0		; not on screen, so nothing to delete.
00231F  3               
00231F  3               	lda #255
00231F  3               	sta (z80_hl),y		; pick it up.
00231F  3               	iny 			; point to y coord.
00231F  3               getob1:
00231F  3               	ldy #33
00231F  3               	lda (z80_hl),y		; y coord.
00231F  3               	sta dispy
00231F  3               	ldy #34
00231F  3               	lda (z80_hl),y 		; x coord.
00231F  3               	sta dispx
00231F  3               	jmp dobj1 		; delete object sprite.
00231F  3               getob0:
00231F  3               	lda #255
00231F  3               	sta (z80_hl),y 		; pick it up.
00231F  3               	rts
00231F  3               .endif
00231F  3               
00231F  3               ;-----------------------------------------------------------------
00231F  3               ; Got object check.
00231F  3               ; Call with object in accumulator, returns zero set if in pockets.
00231F  3               ;
00231F  3               ; Input:
00231F  3               ;  A = object number
00231F  3               ;-----------------------------------------------------------------
00231F  3               .if oflag .or mflag
00231F  3               gotob:
00231F  3               	cmp numob 		; number of objects in game.
00231F  3               	bcc :+ 			; are we checking past the end?
00231F  3               	jmp gotob0 		; yes, we can't have a non-existent object.
00231F  3               :
00231F  3               	jsr findob		; find the object.
00231F  3               gotob1:
00231F  3               	rts
00231F  3               
00231F  3               gotob0:
00231F  3               	lda #254 		; missing.
00231F  3               	jmp gotob1
00231F  3               
00231F  3               findob:
00231F  3               	pha			; save object number
00231F  3               	lda #<objdta 		; objects.
00231F  3               	sta z80_l
00231F  3               	lda #>objdta
00231F  3               	sta z80_h
00231F  3               	pla			; retreive object number
00231F  3               	beq fndob1 		; is it zero? yes, skip loop.
00231F  3               	tax 			; loop counter
00231F  3               fndob2:
00231F  3               	clc
00231F  3               	lda z80_l
00231F  3               	adc #38 		; size of each object.
00231F  3               	sta z80_l
00231F  3               	bcc :+
00231F  3               	inc z80_h
00231F  3               :
00231F  3               	dex 			; repeat until we find address.
00231F  3               	bne fndob2
00231F  3               fndob1:
00231F  3               	ldy #32			; distance to room it's in.
00231F  3               	lda (z80_hl),y		; fetch status.
00231F  3               	rts
00231F  3               .endif
00231F  3               
00231F  3               ;---------------------------------------------
00231F  3               ; Drop object number at (dispx, dispy).
00231F  3               ;
00231F  3               ; Input:
00231F  3               ;  A = object number
00231F  3               ;---------------------------------------------
00231F  3               
00231F  3               .if oflag
00231F  3               drpob:
00231F  3               	cmp numob 		; are we checking past the end?
00231F  3               	bcc :+
00231F  3               	rts			; yes, can't drop non-existent item.
00231F  3               :
00231F  3               	jsr gotob		; make sure object is in inventory.
00231F  3               	cmp scno		; already on this screen?
00231F  3               	bne :+
00231F  3               	rts			; yes, nothing to do.
00231F  3               :
00231F  3               	ldy #32
00231F  3               	lda scno
00231F  3               	sta (z80_hl),y		; bring onto screen.
00231F  3               	lda dispy		; sprite y coordinate.
00231F  3               	iny
00231F  3               	sta (z80_hl),y		; point to object y.
00231F  3               	lda dispx 		; sprite x coordinate.
00231F  3               	iny
00231F  3               	sta (z80_hl),y 		; point to object x
00231F  3               	jmp dobj		; draw the object sprite.
00231F  3               
00231F  3               ;-----------------------------------------------
00231F  3               ; Seek objects at sprite position.
00231F  3               ;
00231F  3               ; Output:
00231F  3               ;  A = object number, if not found A=255
00231F  3               ;-----------------------------------------------
00231F  3               
00231F  3               skobj:
00231F  3               	lda #<objdta 		; pointer to objects.
00231F  3               	sta z80_l
00231F  3               	lda #>objdta
00231F  3               	sta z80_h
00231F  3               
00231F  3               	lda numob 		; number of objects in game.
00231F  3               	sta z80_b 		; set up the loop counter.
00231F  3               skobj0:
00231F  3               	lda scno		; current room number.
00231F  3               	ldy #32
00231F  3               	cmp (z80_hl),y		; is object in here?
00231F  3               	bne :+
00231F  3               	jsr skobj1		; yes, check coordinates.
00231F  3               :
00231F  3               	clc			; point to next object in table.
00231F  3               	lda z80_l
00231F  3               	adc #38			; size of each object.
00231F  3               	sta z80_l
00231F  3               	bcc :+
00231F  3               	inc z80_h
00231F  3               :
00231F  3               	dec z80_b
00231F  3               	bne skobj0		; repeat for all objects.
00231F  3               
00231F  3               	lda #255		; end of list and nothing found, return 255.
00231F  3               	rts
00231F  3               
00231F  3               skobj1:
00231F  3               	ldy #33			; point to y coordinate.
00231F  3               	lda (z80_hl),y		; point to y coordinate.
00231F  3               	sec
00231F  3               	ldy #8
00231F  3               	sbc (z80_ix),y 		; subtract sprite y.
00231F  3               	clc
00231F  3               	adc #15			; add sprite height minus one.
00231F  3               	cmp #31			; within range?
00231F  3               	bcs skobj2		; no, ignore object.
00231F  3               
00231F  3               	ldy #34			; point to x coordinate now.
00231F  3               	lda (z80_hl),y 		; get coordinate.
00231F  3               	sec
00231F  3               	ldy #9
00231F  3               	sbc (z80_ix),y 		; subtract the sprite x.
00231F  3               	clc			; add sprite width minus one.
00231F  3               	adc #15
00231F  3               	cmp #31			; within range?
00231F  3               	bcs skobj2		; no, ignore object.
00231F  3               
00231F  3               	pla			; remove return address from stack.
00231F  3               	pla
00231F  3               
00231F  3               	lda numob 		; objects in game.
00231F  3               	sec
00231F  3               	sbc z80_b		; subtract loop counter.
00231F  3               skobj2:
00231F  3               	rts			; accumulator now points to object.
00231F  3               .endif
00231F  3               
00231F  3               ;---------------------------------------------------------------------
00231F  3               ; Spawn a new sprite.
00231F  3               ;---------------------------------------------------------------------
00231F  3               
00231F  3                 offset = 20
00231F  3               
00231F  3               ;.repeat 343
00231F  3               ;  .byte 0
00231F  3               ;.endrep
00231F  3               
00231F  3               spawn:
00231F  3  A9 33        	lda #<sprtab		; sprite table.
002321  3  85 66        	sta z80_l
002323  3  A9 33        	lda #>sprtab
002325  3  85 67        	sta z80_h
002327  3               numsp1:
002327  3  A9 0C        	lda #NUMSPR		; number of sprites.
002329  3  85 rr        	sta spcnt
00232B  3               spaw0:
00232B  3  A0 00        	ldy #0
00232D  3  B1 66        	lda (z80_hl),y		; get sprite type.
00232F  3  C9 FF        	cmp #255		; is it an unused slot?
002331  3  F0 0F        	beq spaw1 		; yes, we can use this one.
002333  3               
002333  3  18           	clc 			; point to next sprite in table.
002334  3  A5 66        	lda z80_l
002336  3  69 11        	adc #TABSIZ		; size of each entry.
002338  3  85 66        	sta z80_l
00233A  3  90 02        	bcc :+
00233C  3  E6 67        	inc z80_h
00233E  3               :
00233E  3  C6 rr        	dec spcnt		; one less iteration.
002340  3  D0 E9        	bne spaw0		; keep going until we find a slot.
002342  3               
002342  3               ; Didn't find one but drop through and set up a dummy sprite instead.
002342  3               
002342  3               spaw1:
002342  3  A5 69        	lda z80_i		; address of original sprite.
002344  3  48           	pha
002345  3  A5 68        	lda z80_x
002347  3  48           	pha
002348  3               
002348  3  A5 66        	lda z80_l		; store spawned sprite address.
00234A  3  85 rr        	sta spptr
00234C  3  A5 67        	lda z80_h
00234E  3  85 rr        	sta spptr+1
002350  3               
002350  3  A5 62        	lda z80_c
002352  3  A0 00        	ldy #0
002354  3  91 66        	sta (z80_hl),y 		; set the type.
002356  3  A0 05        	ldy #5
002358  3  91 66        	sta (z80_hl),y		; copy
00235A  3               
00235A  3  A5 63        	lda z80_b
00235C  3  A0 01        	ldy #1
00235E  3  91 66        	sta (z80_hl),y		; set the image.
002360  3  A0 06        	ldy #6
002362  3  91 66        	sta (z80_hl),y		; copy
002364  3               
002364  3  A9 00        	lda #0 			; frame zero.
002366  3  A0 02        	ldy #2
002368  3  91 66        	sta (z80_hl),y		; set frame.
00236A  3  A0 07        	ldy #7
00236C  3  91 66        	sta (z80_hl),y		; copy
00236E  3               
00236E  3  A0 08        	ldy #8
002370  3  B1 68        	lda (z80_ix),y 		; x coordinate.
002372  3  A0 03        	ldy #3
002374  3  91 66        	sta (z80_hl),y		; set sprite coordinate.
002376  3  A0 08        	ldy #8
002378  3  91 66        	sta (z80_hl),y		; copy
00237A  3               
00237A  3  A0 09        	ldy #9
00237C  3  B1 68        	lda (z80_ix),y 		; y coordinate.
00237E  3  A0 04        	ldy #4
002380  3  91 66        	sta (z80_hl),y		; set sprite coordinate.
002382  3  A0 09        	ldy #9
002384  3  91 66        	sta (z80_hl),y		; copy
002386  3               
002386  3  A0 0A        	ldy #10			; direction of original.
002388  3  B1 68        	lda (z80_ix),y
00238A  3  91 66        	sta (z80_hl),y		; direction
00238C  3               
00238C  3  A9 00        	lda #0
00238E  3  A0 0B        	ldy #11
002390  3  91 66        	sta (z80_hl),y		; reset parameter.
002392  3  C8           	iny
002393  3  91 66        	sta (z80_hl),y		; reset parameter.
002395  3  C8           	iny
002396  3  91 66        	sta (z80_hl),y		; reset parameter.
002398  3  C8           	iny
002399  3  91 66        	sta (z80_hl),y		; reset parameter.
00239B  3               rtssp:
00239B  3  A5 rr        	lda spptr		; address of new sprite.
00239D  3  85 68        	sta z80_x
00239F  3  A5 rr        	lda spptr+1
0023A1  3  85 69        	sta z80_i
0023A3  3               evis1:
0023A3  3  20 4E 34     	jsr evnt09 		; call sprite initialisation event.
0023A6  3               
0023A6  3  A5 rr        	lda spptr 		; address of new sprite.
0023A8  3  85 68        	sta z80_x
0023AA  3  A5 rr        	lda spptr+1
0023AC  3  85 69        	sta z80_i
0023AE  3  20 FC 2D     	jsr sspria 		; display the new sprite.
0023B1  3               
0023B1  3  68           	pla			; address of original sprite.
0023B2  3  85 68        	sta z80_x
0023B4  3  68           	pla
0023B5  3  85 69        	sta z80_i
0023B7  3               
0023B7  3  60           	rts
0023B8  3               
0023B8  3               ;spcnt:	.byte 0
0023B8  3               ;spptr:	.word 0			; spawned sprite pointer.
0023B8  3               ;seed:	.byte 0			; seed for random numbers.
0023B8  3  30 30 30 30  score:	.byte "000000"		; player"s score.
0023BC  3  30 30        
0023BE  3  30 30 30 30  hiscor:	.byte "000000"		; high score.
0023C2  3  30 30        
0023C4  3  30 30 30 30  bonus:	.byte "000000"		; bonus.
0023C8  3  30 30        
0023CA  3  00 80        grbase:	.word ScreenAddr	; graphics base address.
0023CC  3               
0023CC  3               ;----------------------------------------------------
0023CC  3               ; Check y-pos
0023CC  3               ;----------------------------------------------------
0023CC  3               
0023CC  3               checkx:
0023CC  3  A5 rr        	lda dispy		; y position.
0023CE  3  C9 18        	cmp #24			; off screen?
0023D0  3  B0 01        	bcs :+
0023D2  3  60           	rts			; no, it's okay.
0023D3  3               :
0023D3  3  68           	pla			; remove return address from stack.
0023D4  3  85 66        	sta z80_l
0023D6  3  68           	pla
0023D7  3  85 67        	sta z80_h
0023D9  3  60           	rts
0023DA  3               
0023DA  3               ;-----------------------------------------------
0023DA  3               ; Displays the current high score.
0023DA  3               ;-----------------------------------------------
0023DA  3               
0023DA  3               dhisc:
0023DA  3  A9 BE        	lda #<hiscor 		; high score text.
0023DC  3  8D 11 24     	sta dscor3+1
0023DF  3  8D 2C 24     	sta bscor3+1
0023E2  3  A9 23        	lda #>hiscor
0023E4  3  8D 12 24     	sta dscor3+2
0023E7  3  8D 2D 24     	sta bscor3+2
0023EA  3  4C FD 23     	jmp dscor1		; check in printable range then show 6 digits.
0023ED  3               
0023ED  3               ;------------------------------------------------------
0023ED  3               ; Displays the current score.
0023ED  3               ;------------------------------------------------------
0023ED  3               
0023ED  3               ;.repeat 322
0023ED  3               ;  .byte 0
0023ED  3               ;.endrep
0023ED  3               
0023ED  3               dscor:
0023ED  3  A9 B8        	lda #<score		; score text.
0023EF  3  8D 11 24     	sta dscor3+1
0023F2  3  8D 2C 24     	sta bscor3+1
0023F5  3  A9 23        	lda #>score
0023F7  3  8D 12 24     	sta dscor3+2
0023FA  3  8D 2D 24     	sta bscor3+2
0023FD  3               dscor1:
0023FD  3  8C 28 24     	sty tmpscr
002400  3  20 9E 2B     	jsr preprt		; set up font and print position.
002403  3  20 CC 23     	jsr checkx		; make sure we're in a printable range.
002406  3               
002406  3               ;	lda #6			; digits to display.
002406  3               ;	sta z80_b
002406  3  A5 rr        	lda prtmod		; get print mode.
002408  3  F0 03        	beq :+			; standard size text?
00240A  3  4C 29 24     	jmp bscor0		; no, show double-height.
00240D  3               :
00240D  3               dscor0:
00240D  3               ;	ldy #0
00240D  3               ;	lda (z80_hl),y 		; fetch character.
00240D  3  AC 28 24     	ldy tmpscr
002410  3               dscor3:
002410  3  B9 B8 23     	lda score,y
002413  3  20 60 25     	jsr pchar 		; display character.
002416  3  E6 rr        	inc dispx		; move along x coordinate
002418  3               
002418  3               ;	inc z80_l		; next score column.
002418  3               ;	bne :+
002418  3               ;	inc z80_h
002418  3               ;:
002418  3  EE 28 24     	inc tmpscr
00241B  3  C6 63        	dec z80_b
00241D  3  D0 EE        	bne dscor0 		; repeat for all digits.
00241F  3               dscor2:
00241F  3  A5 rr        	lda dispx 		; set up display coordinates.
002421  3  85 rr        	sta charx
002423  3  A5 rr        	lda dispy
002425  3  85 rr        	sta chary
002427  3  60           	rts
002428  3               
002428  3  00           tmpscr:	.byte 0
002429  3               ;------------------------------------------------------
002429  3               ; Displays the current score in double-height characters.
002429  3               ;
002429  3               ; Input:
002429  3               ;  B  = digit number
002429  3               ;  HL = score string
002429  3               ;------------------------------------------------------
002429  3               
002429  3               bscor0:
002429  3               ;	ldy #0
002429  3               
002429  3               ;	lda (z80_hl),y 		; fetch character.
002429  3  A4 rr        	ldy tmp
00242B  3               bscor3:
00242B  3  B9 B8 23     	lda score,y
00242E  3  20 25 2B     	jsr bchar 		; display big char.
002431  3               
002431  3               ;	inc z80_l 		; next score column.
002431  3               ;	bne :+
002431  3               ;	inc z80_h
002431  3               ;:
002431  3  E6 rr        	inc tmp
002433  3  C6 63        	dec z80_b
002435  3  F0 03        	beq :+
002437  3  4C 29 24     	jmp bscor0 		; repeat for all digits.
00243A  3               :
00243A  3  4C 1F 24     	jmp dscor2 		; tidy up line and column variables.
00243D  3               
00243D  3               ;-----------------------------------------------------
00243D  3               ; Adds number in the hl pair to the score.
00243D  3               ;-----------------------------------------------------
00243D  3               
00243D  3               addsc:
00243D  3  A9 B9        	lda #<(score+1) 	; ten thousands column.
00243F  3  85 64        	sta z80_e
002441  3  A9 23        	lda #>(score+1)
002443  3  85 65        	sta z80_d
002445  3  A9 10        	lda #<10000		; amount to add each time.
002447  3  85 62        	sta z80_c
002449  3  A9 27        	lda #>10000
00244B  3  85 63        	sta z80_b
00244D  3  20 91 24     	jsr incsc		; add to score.
002450  3               
002450  3  E6 64        	inc z80_e		; thousands column.
002452  3  D0 02        	bne :+
002454  3  E6 65        	inc z80_d
002456  3               :
002456  3  A9 E8        	lda #<1000		; amount to add each time.
002458  3  85 62        	sta z80_c
00245A  3  A9 03        	lda #>1000
00245C  3  85 63        	sta z80_b
00245E  3  20 91 24     	jsr incsc 		; add to score.
002461  3               
002461  3  E6 64        	inc z80_e		; hundreds column.
002463  3  D0 02        	bne :+
002465  3  E6 65        	inc z80_d
002467  3               :
002467  3  A9 64        	lda #<100		; amount to add each time.
002469  3  85 62        	sta z80_c
00246B  3  A9 00        	lda #>100
00246D  3  85 63        	sta z80_b
00246F  3  20 91 24     	jsr incsc		; add to score.
002472  3               
002472  3  E6 64        	inc z80_e 		; tens column.
002474  3  D0 02        	bne :+
002476  3  E6 65        	inc z80_d
002478  3               :
002478  3  A9 0A        	lda #<10		; amount to add each time.
00247A  3  85 62        	sta z80_c
00247C  3  A9 00        	lda #>10
00247E  3  85 63        	sta z80_b
002480  3  20 91 24     	jsr incsc 		; add to score.
002483  3               
002483  3  E6 64        	inc z80_e		; units column.
002485  3  D0 02        	bne :+
002487  3  E6 65        	inc z80_d
002489  3               :
002489  3  A9 01        	lda #<1			; units.
00248B  3  85 62        	sta z80_c
00248D  3  A9 00        	lda #>1
00248F  3  85 63        	sta z80_b
002491  3               incsc:
002491  3  A5 67        	lda z80_h		; store amount to add.
002493  3  48           	pha
002494  3  A5 66        	lda z80_l
002496  3  48           	pha
002497  3               
002497  3  38           	sec			; subtract from amount to add.
002498  3  A5 66        	lda z80_l
00249A  3  E5 62        	sbc z80_c
00249C  3  85 66        	sta z80_l
00249E  3  A5 67        	lda z80_h
0024A0  3  E5 63        	sbc z80_b
0024A2  3  85 67        	sta z80_h
0024A4  3  90 14        	bcc incsc0		; too much, restore value.
0024A6  3               
0024A6  3  68           	pla			; delete the previous amount from the stack.
0024A7  3  68           	pla
0024A8  3               
0024A8  3  A5 65        	lda z80_d 		; store column position.
0024AA  3  48           	pha
0024AB  3  A5 64        	lda z80_e
0024AD  3  48           	pha
0024AE  3  20 C1 24     	jsr incsc2		; do the increment.
0024B1  3               
0024B1  3  68           	pla			; restore column.
0024B2  3  85 64        	sta z80_e
0024B4  3  68           	pla
0024B5  3  85 65        	sta z80_d
0024B7  3  4C 91 24     	jmp incsc		; repeat until all added.
0024BA  3               
0024BA  3               incsc0:
0024BA  3  68           	pla			; restore previous value.
0024BB  3  85 66        	sta z80_l
0024BD  3  68           	pla
0024BE  3  85 67        	sta z80_h
0024C0  3  60           	rts
0024C1  3               incsc2:
0024C1  3  A0 00        	ldy #0
0024C3  3  B1 64        	lda (z80_de),y 		; get amount.
0024C5  3  18           	clc
0024C6  3  69 01        	adc #1			; add one to column.
0024C8  3  91 64        	sta (z80_de),y		; write new column total.
0024CA  3  C9 3A        	cmp #'9'+1		; gone beyond range of digits?
0024CC  3  B0 01        	bcs :+
0024CE  3  60           	rts			; no, carry on.
0024CF  3               :
0024CF  3  A9 30        	lda #'0'		; make it zero.
0024D1  3  91 64        	sta (z80_de),y		; write new column total.
0024D3  3  C6 64        	dec z80_e		; back one column.
0024D5  3  D0 02        	bne :+
0024D7  3  C6 65        	dec z80_d
0024D9  3               :
0024D9  3  4C C1 24     	jmp incsc2
0024DC  3               
0024DC  3               ;------------------------------------
0024DC  3               ; Add bonus to score and reset bonus
0024DC  3               ;------------------------------------
0024DC  3               
0024DC  3               addbo:
0024DC  3  A2 05        	ldx #5			; last digit.
0024DE  3  18           	clc
0024DF  3               addbo0:
0024DF  3  BD B8 23     	lda score,x		; get score.
0024E2  3  7D C4 23     	adc bonus,x		; add bonus.
0024E5  3  38           	sec			; 0 to 18.
0024E6  3  E9 30        	sbc #48
0024E8  3  48           	pha
0024E9  3  A9 30        	lda #'0'
0024EB  3  9D C4 23     	sta bonus,x
0024EE  3  68           	pla
0024EF  3  C9 3A        	cmp #58
0024F1  3  90 03        	bcc addbo1
0024F3  3  38           	sec
0024F4  3  E9 0A        	sbc #10
0024F6  3               addbo1:
0024F6  3  9D B8 23     	sta score,x		; zeroise bonus.
0024F9  3  CA           	dex			; next digit.
0024FA  3  10 E3        	bpl addbo0		; repeat for all 6 digits.
0024FC  3  60           	rts
0024FD  3               
0024FD  3               ;------------------------------------
0024FD  3               ; Swap score and bonus.
0024FD  3               ;------------------------------------
0024FD  3               
0024FD  3               swpsb:
0024FD  3  A2 05        	ldx #5			; digits to add.
0024FF  3               swpsb0:
0024FF  3  BD B8 23     	lda score,x 		; get score digits.
002502  3  48           	pha			; save digit
002503  3  BD C4 23     	lda bonus,x 		; get bonus digits.
002506  3  9D B8 23     	sta score,x		; switch score-bonus
002509  3  68           	pla
00250A  3  9D C4 23     	sta bonus,x
00250D  3  CA           	dex 			; repeat for all 6 digits.
00250E  3  10 EF        	bpl swpsb0
002510  3  60           	rts
002511  3               
002511  3               ;----------------------------------------------------
002511  3               ; Get print address.
002511  3               ;----------------------------------------------------
002511  3               
002511  3               gprad:
002511  3  A5 rr        	lda dispx		; get x
002513  3  85 rr        	sta scraddr		; store lb address
002515  3               
002515  3  2A           	rol a
002516  3  26 rr        	rol tmp
002518  3  2A           	rol a
002519  3  26 rr        	rol tmp
00251B  3  2A           	rol a
00251C  3  26 rr        	rol tmp
00251E  3  A5 rr        	lda tmp
002520  3  29 07        	and #7
002522  3  85 rr        	sta tmp
002524  3  A5 rr        	lda prtmod
002526  3  F0 02        	beq :+
002528  3  06 rr        	asl tmp
00252A  3               :
00252A  3  A5 rr        	lda tmp
00252C  3  18           	clc
00252D  3  65 rr        	adc dispy		; get y
00252F  3  09 80        	ora #$80		; add $80
002531  3  85 rr        	sta scraddr+1		; store hb address
002533  3  60           	rts
002534  3               
002534  3               ;--------------------------------------------------------------
002534  3               ; Get property buffer address of char at (dispx, dispy) in hl.
002534  3               ;
002534  3               ; Output:
002534  3               ;  bufaddr = MAP + dispy*32 + dispx
002534  3               ;--------------------------------------------------------------
002534  3               
002534  3               pradd:
002534  3  A5 rr        	lda dispy 		; y coordinate.
002536  3  85 rr        	sta bufaddr
002538  3  A9 00        	lda #0
00253A  3  85 rr        	sta bufaddr+1
00253C  3  06 rr        	asl bufaddr  		; multiply char by 32
00253E  3  26 rr        	rol bufaddr+1
002540  3  06 rr        	asl bufaddr
002542  3  26 rr        	rol bufaddr+1
002544  3  06 rr        	asl bufaddr
002546  3  26 rr        	rol bufaddr+1
002548  3  06 rr        	asl bufaddr
00254A  3  26 rr        	rol bufaddr+1
00254C  3  06 rr        	asl bufaddr
00254E  3  26 rr        	rol bufaddr+1
002550  3  18           	clc			; add address of MAP graphics.
002551  3  A5 rr        	lda bufaddr
002553  3  65 rr        	adc dispx
002555  3  69 00        	adc #<MAP
002557  3  85 rr        	sta bufaddr
002559  3  A5 rr        	lda bufaddr+1
00255B  3  69 98        	adc #>MAP
00255D  3  85 rr        	sta bufaddr+1
00255F  3  60           	rts
002560  3               
002560  3               ;----------------------------------------------------
002560  3               ; Display character in A at dispx,dispy.
002560  3               ;
002560  3               ; Input:
002560  3               ;  A 	   = character to print
002560  3               ;----------------------------------------------------
002560  3               
002560  3               pchar:
002560  3  85 rr        	sta fntaddr
002562  3  A9 00        	lda #0
002564  3  85 rr        	sta fntaddr+1
002566  3  06 rr        	asl fntaddr  		; multiply char by 8.
002568  3  26 rr        	rol fntaddr+1
00256A  3  06 rr        	asl fntaddr
00256C  3  26 rr        	rol fntaddr+1
00256E  3  06 rr        	asl fntaddr
002570  3  26 rr        	rol fntaddr+1
002572  3               
002572  3  A5 rr        	lda fntaddr
002574  3  18           	clc
002575  3  69 B0        	adc #<(FONT-256)
002577  3  85 rr        	sta fntaddr		; that's the low byte.
002579  3  A5 rr        	lda fntaddr+1
00257B  3  69 34        	adc #>(FONT-256)
00257D  3  85 rr        	sta fntaddr+1		; add displacement.
00257F  3               pchark:
00257F  3  20 11 25     	jsr gprad		; get screen address.
002582  3  A2 07        	ldx #7			; lines to write.
002584  3               pchar0:
002584  3  A0 00        	ldy #0
002586  3  B1 rr        	lda (fntaddr),y 	; get image byte.
002588  3  BC 97 25     	ldy scrtab,x		; Get rowoffset
00258B  3               .if iflag
00258B  3               	eor #$ff
00258B  3               .endif
00258B  3  91 rr        	sta (scraddr),y 	; copy to screen.
00258D  3  E6 rr        	inc fntaddr		; next image byte.
00258F  3  D0 02        	bne :+
002591  3  E6 rr        	inc fntaddr+1
002593  3               :
002593  3  CA           	dex			; next screen row down.
002594  3  10 EE        	bpl pchar0		; repeat.
002596  3  60           	rts
002597  3               
002597  3  E0 C0 A0 80  scrtab:		.byte $e0,$c0,$a0,$80,$60,$40,$20,$00
00259B  3  60 40 20 00  
00259F  3               
00259F  3               ;----------------------------------------------
00259F  3               
00259F  3               ; Print attributes, properties and pixels.
00259F  3               ;
00259F  3               ; Input:
00259F  3               ;  A	= tile number
00259F  3               ;----------------------------------------------
00259F  3               
00259F  3               ;.repeat 294
00259F  3               ;  .byte 0
00259F  3               ;.endrep
00259F  3               
00259F  3               pbpattr:			; entry PUTBLOCK command
00259F  3  A4 rr        	ldy charx
0025A1  3  84 rr        	sty dispx
0025A3  3  A4 rr        	ldy chary
0025A5  3  84 rr        	sty dispy
0025A7  3               pattr:
0025A7  3               .if aflag
0025A7  3               	pha
0025A7  3               	jsr wbloc		; save blockinfo
0025A7  3               	pla
0025A7  3               .endif
0025A7  3               
0025A7  3               pattr2:
0025A7  3  85 63        	sta z80_b		; store cell in b register for now.
0025A9  3  AA           	tax
0025AA  3  BD F4 34     	lda bprop,x 		; block properties.
0025AD  3  85 62        	sta z80_c
0025AF  3  C9 08        	cmp #COLECT
0025B1  3  D0 05        	bne :+
0025B3  3  A5 63        	lda z80_b
0025B5  3  8D C6 25     	sta colpatt
0025B8  3               :
0025B8  3  20 34 25     	jsr pradd 		; get property buffer address.
0025BB  3  A5 62        	lda z80_c
0025BD  3  A0 00        	ldy #0
0025BF  3  91 rr        	sta (bufaddr),y 	; write property.
0025C1  3  A5 63        	lda z80_b 		; restore cell.
0025C3  3  4C C7 25     	jmp panp
0025C6  3               ; Print attributes, no properties.
0025C6  3               
0025C6  3               ;.repeat 263
0025C6  3               ; .byte 0
0025C6  3               ;.endrep
0025C6  3               
0025C6  3  00           colpatt:	.byte 0
0025C7  3               
0025C7  3               panp:
0025C7  3  85 64        	sta z80_e		; displacement in e.
0025C9  3  A9 00        	lda #0
0025CB  3  85 65        	sta z80_d		; no high byte.
0025CD  3  06 64        	asl z80_e  		; multiply char by 8.
0025CF  3  26 65        	rol z80_d
0025D1  3  06 64        	asl z80_e
0025D3  3  26 65        	rol z80_d
0025D5  3  06 64        	asl z80_e
0025D7  3  26 65        	rol z80_d
0025D9  3  18           	clc
0025DA  3  A5 64        	lda z80_e
0025DC  3  69 EC        	adc #<chgfx 		; address of graphics.
0025DE  3  85 rr        	sta tileaddr
0025E0  3  A5 65        	lda z80_d
0025E2  3  69 34        	adc #>chgfx
0025E4  3  85 rr        	sta tileaddr+1
0025E6  3  20 11 25     	jsr gprad 		; get screen address.
0025E9  3  A2 07        	ldx #7			; number of pixel rows to write.
0025EB  3               panp0:
0025EB  3  A0 00        	ldy #0
0025ED  3  B1 rr        	lda (tileaddr),y 	; get image byte.
0025EF  3               .if iflag
0025EF  3               	eor #$ff		; Invert
0025EF  3               .endif
0025EF  3  BC 97 25     	ldy scrtab,x
0025F2  3  91 rr        	sta (scraddr),y 	; copy to screen.
0025F4  3  E6 rr        	inc tileaddr 		; next image byte.
0025F6  3  D0 02        	bne :+
0025F8  3  E6 rr        	inc tileaddr+1
0025FA  3               :
0025FA  3  CA           	dex	 		; repeat for 8 pixel rows.
0025FB  3  10 EE        	bpl panp0
0025FD  3  E6 rr        	inc dispx 		; move along one.
0025FF  3  E6 rr        	inc charx
002601  3  60           	rts
002602  3               
002602  3               ;----------------------------------------------
002602  3               ; Write block
002602  3               ;----------------------------------------------
002602  3               
002602  3               .if aflag
002602  3               wbloc:
002602  3               	ldy #3
002602  3               	sta (pbptr),y		; store block number
002602  3               	dey
002602  3               	lda dispx
002602  3               	sta (pbptr),y		; write x position of block.
002602  3               	dey
002602  3               	lda dispy
002602  3               	sta (pbptr),y		; write y position of block.
002602  3               	dey
002602  3               	lda scno
002602  3               	sta (pbptr),y		; write screen.
002602  3               	clc			; point to next free location
002602  3               	lda pbptr
002602  3               	adc #4
002602  3               	sta pbptr
002602  3               	bcc :+
002602  3               	inc pbptr+1
002602  3               :
002602  3               	rts
002602  3               .endif
002602  3               
002602  3               ;----------------------------------------------
002602  3               ; Print character pixels, no more.
002602  3               ;
002602  3               ; Input:
002602  3               ;  A	= character to print
002602  3               ;----------------------------------------------
002602  3               
002602  3               pchr:
002602  3  20 60 25     	jsr pchar 		; show character in accumulator.
002605  3  E6 rr        	inc dispx		; move along one.
002607  3  60           	rts
002608  3               
002608  3               ;----------------------------------------------------
002608  3               ; Shifter sprite routine for objects.
002608  3               ;----------------------------------------------------
002608  3               
002608  3               .if oflag
002608  3               sprit7:
002608  3               	lda z80_b
002608  3               	beq sprit0
002608  3               	sta z80_a
002608  3               sprit3:
002608  3               	lsr spr			; shift into position.
002608  3               	ror spr+1
002608  3               	ror spr+2
002608  3               	dec z80_a		; one less iteration.
002608  3               	bne sprit3
002608  3               sprit0:
002608  3               	rts 			; now apply to screen.
002608  3               
002608  3               ;----------------------------------------------------
002608  3               ; Draw sprite
002608  3               ;----------------------------------------------------
002608  3               
002608  3               sprite:
002608  3               	stx xtmp		; Save X-reg
002608  3               	jsr scadd 		; get screen address in scraddr.
002608  3               
002608  3               	lda dispx 		; x position.
002608  3               	and #7 			; position straddling cells.
002608  3               	sta z80_b		; store in b register.
002608  3               
002608  3               	lda z80_l		; store sprite graphic address.
002608  3               	sta sprit1+1
002608  3               	sta sprit2+1
002608  3               	lda z80_h
002608  3               	sta sprit1+2
002608  3               	sta sprit2+2
002608  3               
002608  3               	ldx #0			; pixel height.
002608  3               	ldy #0
002608  3               sprit1:
002608  3               	lda objdta,x		; fetch first byte.
002608  3               	sta spr
002608  3               	inx
002608  3               sprit2:
002608  3               	lda objdta,x
002608  3               	sta spr+1
002608  3               
002608  3               	lda #0
002608  3               	sta spr+2
002608  3               	jsr sprit7		; shift sprite
002608  3               
002608  3               	dex
002608  3               	lda spr			; fetch graphic.
002608  3               	ldy spritetab,x
002608  3               	eor (scraddr),y		; merge with screen image.
002608  3               	sta (scraddr),y		; write to screen.
002608  3               	inx			; next screen byte.
002608  3               
002608  3               	lda spr+1		; fetch graphic.
002608  3               	ldy spritetab,x
002608  3               	eor (scraddr),y		; merge with screen image.
002608  3               	sta (scraddr),y		; write to screen.
002608  3               	iny
002608  3               
002608  3               	lda spr+2		; fetch graphic.
002608  3               	eor (scraddr),y		; merge with screen image.
002608  3               	sta (scraddr),y		; write to screen.
002608  3               
002608  3               	inx			; next source byte.
002608  3               	cpx #16
002608  3               	bne :+
002608  3               	inc scraddr+1
002608  3               :
002608  3               	cpx #32
002608  3               	bne sprit1		; repeat
002608  3               
002608  3               	ldx xtmp		; retreive X-reg
002608  3               	rts
002608  3               
002608  3               spritetab:
002608  3               	.byte $00,$01,$20,$21,$40,$41,$60,$61
002608  3               	.byte $80,$81,$a0,$a1,$c0,$c1,$e0,$e1
002608  3               	.byte $00,$01,$20,$21,$40,$41,$60,$61
002608  3               	.byte $80,$81,$a0,$a1,$c0,$c1,$e0,$e1
002608  3               
002608  3               spr:	.byte 0,0,0
002608  3               
002608  3               ;xtmp:	.byte 0
002608  3               .endif
002608  3               
002608  3               ;-----------------------------------------------------------
002608  3               ; Get room address.
002608  3               ;-----------------------------------------------------------
002608  3               
002608  3               ;.repeat 273
002608  3               ;  .byte 0
002608  3               ;.endrep
002608  3               
002608  3               groom:
002608  3  A6 rr        	ldx scno 		; screen number.
00260A  3  A0 00        	ldy #0
00260C  3               groomx:
00260C  3  A9 79        	lda #<scdat 		; pointer to screens.
00260E  3  85 66        	sta z80_l
002610  3  A9 35        	lda #>scdat
002612  3  85 67        	sta z80_h
002614  3               groom1:
002614  3  E0 00        	cpx #0			; is it the first one?
002616  3  F0 15        	beq groom0 		; no more screens to skip.
002618  3               
002618  3  18           	clc
002619  3  A5 66        	lda z80_l
00261B  3  79 79 35     	adc scdat,y 		; low byte of screen size.
00261E  3  85 66        	sta z80_l
002620  3  C8           	iny			; point to high byte.
002621  3  A5 67        	lda z80_h
002623  3  79 79 35     	adc scdat,y 		; high byte of screen size.
002626  3  85 67        	sta z80_h
002628  3  C8           	iny			; next address.
002629  3               
002629  3  CA           	dex 			; one less iteration.
00262A  3  4C 14 26     	jmp groom1 		; loop until we reach the end.
00262D  3               groom0:
00262D  3  AD 84 35     	lda numsc 		; add displacement.
002630  3  0A           	asl a
002631  3  18           	clc			; add double displacement to address.
002632  3  65 66        	adc z80_l
002634  3  85 66        	sta z80_l
002636  3  A5 67        	lda z80_h
002638  3  69 00        	adc #0
00263A  3  85 67        	sta z80_h
00263C  3  60           	rts
00263D  3               
00263D  3               ;-----------------------------------------------------------
00263D  3               ; Draw present room.
00263D  3               ;-----------------------------------------------------------
00263D  3               
00263D  3               droom:
00263D  3  AD 49 20     	lda wintop 		; window top.
002640  3  85 rr        	sta dispy		; set cursor y position.
002642  3               droom2:
002642  3  20 08 26     	jsr groom 		; get address of current room.
002645  3  A9 00        	lda #0	 		; zero in accumulator.
002647  3  85 rr        	sta comcnt 		; reset compression counter.
002649  3  AD 4B 20     	lda winhgt 		; height of window.
00264C  3  85 rr        	sta rrow		; set row counter
00264E  3               droom0:
00264E  3  AD 4A 20     	lda winlft 		; window left edge.
002651  3  85 rr        	sta dispx 		; set cursor x position.
002653  3  AD 4C 20     	lda winwid 		; width of window.
002656  3  85 rr        	sta rcol		; set column counter
002658  3               droom1:
002658  3  20 69 26     	jsr flbyt 		; decompress next byte on the fly.
00265B  3  20 A7 25     	jsr pattr2 		; show attributes and block.
00265E  3  C6 rr        	dec rcol		; one less column.
002660  3  D0 F6        	bne droom1 		; repeat for entire line.
002662  3  E6 rr        	inc dispy		; move down one line.
002664  3  C6 rr        	dec rrow 		; one less row.
002666  3  D0 E6        	bne droom0 		; repeat for all rows.
002668  3  60           	rts
002669  3               
002669  3               ;rcol:	.byte 0
002669  3               ;rrow:	.byte 0
002669  3               
002669  3               ;----------------------------------------------
002669  3               ; Decompress bytes on-the-fly.
002669  3               ;----------------------------------------------
002669  3               
002669  3               flbyt:
002669  3  A5 rr        	lda comcnt 		; compression counter.
00266B  3  D0 21        	bne flbyt1		; any more to decompress?  yes.
00266D  3               
00266D  3  A0 00        	ldy #0
00266F  3  B1 66        	lda (z80_hl),y 		; fetch next byte.
002671  3  E6 66        	inc z80_l 		; point to next cell.
002673  3  D0 02        	bne :+
002675  3  E6 67        	inc z80_h
002677  3               :
002677  3  C9 FF        	cmp #255 		; is this byte a control code?
002679  3  F0 01        	beq :+
00267B  3  60           	rts 			; no, this byte is uncompressed.
00267C  3               :
00267C  3  B1 66        	lda (z80_hl),y 		; fetch byte type.
00267E  3  85 rr        	sta combyt 		; set up the type.
002680  3  E6 66        	inc z80_l 		; point to quantity.
002682  3  D0 02        	bne :+
002684  3  E6 67        	inc z80_h
002686  3               :
002686  3  B1 66        	lda (z80_hl),y 		; get quantity.
002688  3  E6 66        	inc z80_l 		; point to next byte.
00268A  3  D0 02        	bne :+
00268C  3  E6 67        	inc z80_h
00268E  3               :
00268E  3               flbyt1:
00268E  3  85 rr        	sta comcnt 		; store new quantity.
002690  3  C6 rr        	dec comcnt		; one less.
002692  3  A5 rr        	lda combyt 		; byte to expand.
002694  3  60           	rts
002695  3               
002695  3               ;combyt:	.byte 0			; byte type compressed.
002695  3               ;comcnt:	.byte 0			; compression counter.
002695  3               
002695  3               ;------------------------------------------
002695  3               ; Ladder down check.
002695  3               ;
002695  3               ; Input:
002695  3               ;  IX = sprite pointer
002695  3               ;------------------------------------------
002695  3               
002695  3               .if lflag
002695  3               laddd:
002695  3               	ldy #9
002695  3               	lda (z80_ix),y		; x coordinate.
002695  3               	sta dispx
002695  3               
002695  3               	ldy #8
002695  3               	lda (z80_ix),y		; y coordinate.
002695  3               	and #254		; make it even.
002695  3               	sta (z80_ix),y 		; reset it.
002695  3               	clc 			; look down 16 pixels.
002695  3               numsp5:
002695  3               	adc #SPR_HGT
002695  3               	sta dispy		; coords in dispx,dispy.
002695  3               	jmp laddv
002695  3               
002695  3               ;------------------------------------------
002695  3               ; Ladder up check.
002695  3               ;
002695  3               ; Input:
002695  3               ;  IX = sprite pointer
002695  3               ;
002695  3               ; Output:
002695  3               ;  A  = 0 is ok, A <>0 is not ok
002695  3               ;------------------------------------------
002695  3               
002695  3               laddu:
002695  3               	ldy #9
002695  3               	lda (z80_ix),y		; x coordinate.
002695  3               	sta dispx
002695  3               
002695  3               	ldy #8
002695  3               	lda (z80_ix),y		; y coordinate.
002695  3               	and #254 		; make it even.
002695  3               	sta (z80_ix),y		; reset it.
002695  3               	clc 			; look 2 pixels above feet.
002695  3               numsp6:
002695  3               	adc #SPR_HGT-2
002695  3               	sta dispy		; coords in dispx,dispy.
002695  3               laddv:
002695  3               	jsr tstbl 		; get map address.
002695  3               	jsr ldchk 		; standard ladder check.
002695  3               	beq :+
002695  3               	rts 			; no way through.
002695  3               :
002695  3               	inc bufaddr 		; look right one cell.
002695  3               	bne :+
002695  3               	inc bufaddr+1
002695  3               :
002695  3               	jsr ldchk 		; do the check.
002695  3               	beq :+
002695  3               	rts 			; impassable.
002695  3               :
002695  3               	lda dispx 		; y coordinate.
002695  3               	and #7 			; position straddling block cells.
002695  3               	bne :+
002695  3               	rts 			; no more checks needed.
002695  3               :
002695  3               	inc bufaddr 		; look to third cell.
002695  3               	bne :+
002695  3               	inc bufaddr+1
002695  3               :
002695  3               	jsr ldchk 		; do the check.
002695  3               	rts  			; return with zero flag set accordingly.
002695  3               .endif
002695  3               
002695  3               ;---------------------------------------------------------
002695  3               ; Can go up check.
002695  3               ;
002695  3               ; Input:
002695  3               ;  IX = sprite pointer
002695  3               ;
002695  3               ; Output:
002695  3               ;  A  = 0 is ok, A <>0 is not ok
002695  3               ;---------------------------------------------------------
002695  3               
002695  3               cangu:
002695  3  A0 09        	ldy #9
002697  3  B1 68        	lda (z80_ix),y		; x coordinate.
002699  3  85 rr        	sta dispx
00269B  3  A0 08        	ldy #8
00269D  3  B1 68        	lda (z80_ix),y 		; y coordinate.
00269F  3  38           	sec
0026A0  3  E9 02        	sbc #2
0026A2  3  85 rr        	sta dispy		; coords in dispx,dispy.
0026A4  3  20 3F 29     	jsr tstbl 		; get map address.
0026A7  3  20 57 28     	jsr lrchk 		; standard left/right check.
0026AA  3  F0 01        	beq :+
0026AC  3  60           	rts			; no way through.
0026AD  3               :
0026AD  3  E6 rr        	inc bufaddr		; look right one cell.
0026AF  3  D0 02        	bne :+
0026B1  3  E6 rr        	inc bufaddr+1
0026B3  3               :
0026B3  3  20 57 28     	jsr lrchk 		; do the check.
0026B6  3  F0 01        	beq :+
0026B8  3  60           	rts			; impassable.
0026B9  3               :
0026B9  3  A5 rr        	lda dispx		; x coordinate.
0026BB  3  29 07        	and #7			; position straddling block cells.
0026BD  3  D0 01        	bne :+
0026BF  3  60           	rts			; no more checks needed.
0026C0  3               :
0026C0  3  E6 rr        	inc bufaddr		; look to third cell.
0026C2  3  D0 02        	bne :+
0026C4  3  E6 rr        	inc bufaddr+1
0026C6  3               :
0026C6  3  20 57 28     	jsr lrchk		; do the check.
0026C9  3  60           	rts 			; return with zero flag set accordingly.
0026CA  3               
0026CA  3               ;---------------------------------------------------------
0026CA  3               ; Can go down check.
0026CA  3               ;
0026CA  3               ; Input:
0026CA  3               ;  IX = sprite pointer
0026CA  3               ;
0026CA  3               ; Output:
0026CA  3               ;  A  = 0 is ok, A <>0 is not ok
0026CA  3               ;---------------------------------------------------------
0026CA  3               
0026CA  3               ;.repeat 264
0026CA  3               ;  .byte 0
0026CA  3               ;.endrep
0026CA  3               
0026CA  3               cangd:
0026CA  3  A0 09        	ldy #9
0026CC  3  B1 68        	lda (z80_ix),y 		; x coordinate.
0026CE  3  85 rr        	sta dispx
0026D0  3  A0 08        	ldy #8
0026D2  3  B1 68        	lda (z80_ix),y		; y coordinate.
0026D4  3  18           	clc
0026D5  3               numsp3:
0026D5  3  69 10        	adc #SPR_HGT 		; look down 16 pixels.
0026D7  3  85 rr        	sta dispy		; coords in dispx,dispy.
0026D9  3  20 3F 29     	jsr tstbl 		; get map address.
0026DC  3  20 6C 28     	jsr plchk 		; block, platform check.
0026DF  3  F0 01        	beq :+
0026E1  3  60           	rts			; no way through.
0026E2  3               :
0026E2  3  E6 rr        	inc bufaddr		; look right one cell.
0026E4  3  D0 02        	bne :+
0026E6  3  E6 rr        	inc bufaddr+1
0026E8  3               :
0026E8  3  20 6C 28     	jsr plchk		; block, platform check.
0026EB  3  F0 01        	beq :+
0026ED  3  60           	rts			; impassable.
0026EE  3               :
0026EE  3  A5 rr        	lda dispx		; x coordinate.
0026F0  3  29 07        	and #7			; position straddling block cells.
0026F2  3  D0 01        	bne :+
0026F4  3  60           	rts			; no more checks needed.
0026F5  3               :
0026F5  3  E6 rr        	inc bufaddr		; look to third cell.
0026F7  3  D0 02        	bne :+
0026F9  3  E6 rr        	inc bufaddr+1
0026FB  3               :
0026FB  3  20 6C 28     	jsr plchk		; block, platform check.
0026FE  3  60           	rts			; return with zero flag set accordingly.
0026FF  3               
0026FF  3               ;---------------------------------------------------------
0026FF  3               ; Can go left check.
0026FF  3               ;
0026FF  3               ; Input:
0026FF  3               ;  IX = sprite pointer
0026FF  3               ;
0026FF  3               ; Output:
0026FF  3               ;  A  = 0 is ok, A <>0 is not ok
0026FF  3               ;---------------------------------------------------------
0026FF  3               
0026FF  3               cangl:
0026FF  3  A0 08        	ldy #8
002701  3  B1 68        	lda (z80_ix),y 		; y coordinate.
002703  3  85 rr        	sta dispy
002705  3  A0 09        	ldy #9
002707  3  B1 68        	lda (z80_ix),y 		; x coordinate.
002709  3  38           	sec
00270A  3  E9 02        	sbc #2			; look left 2 pixels.
00270C  3  85 rr        	sta dispx		; coords in dispx,dispy.
00270E  3  4C 30 28     	jmp cangh		; test if we can go there.
002711  3               
002711  3               ;---------------------------------------------------------
002711  3               ; Can go right check.
002711  3               ;
002711  3               ; Input:
002711  3               ;  IX = sprite pointer
002711  3               ;
002711  3               ; Output:
002711  3               ;  A  = 0 is ok, A <>0 is not ok
002711  3               ;---------------------------------------------------------
002711  3               
002711  3  00 00 00 00  .repeat 272
002715  3  00 00 00 00  
002719  3  00 00 00 00  
002821  3                 .byte 0
002821  3               .endrep
002821  3               
002821  3               cangr:
002821  3  A0 08        	ldy #8
002823  3  B1 68        	lda (z80_ix),y		; y coordinate.
002825  3  85 rr        	sta dispy
002827  3  A0 09        	ldy #9
002829  3  B1 68        	lda (z80_ix),y		; x coordinate.
00282B  3  18           	clc
00282C  3  69 10        	adc #16			; look right 16 pixels.
00282E  3  85 rr        	sta dispx		; coords in dispx,dispy.
002830  3               cangh:
002830  3               cangh2:
002830  3  A9 03        	lda #(SPR_HGT/8+1)	; default rows to write.
002832  3  85 63        	sta z80_b
002834  3  A5 rr        	lda dispy		; y position.
002836  3  29 07        	and #7			; does x straddle cells?
002838  3  D0 02        	bne cangh0		; yes, loop counter is good.
00283A  3  C6 63        	dec z80_b		; one less row to write.
00283C  3               cangh0:
00283C  3  20 3F 29     	jsr tstbl		; get map address.
00283F  3               cangh1:
00283F  3  20 57 28     	jsr lrchk		; standard left/right check.
002842  3  F0 01        	beq :+
002844  3  60           	rts			; no way through.
002845  3               :
002845  3  48           	pha
002846  3  18           	clc
002847  3  A5 rr        	lda bufaddr
002849  3  69 20        	adc #32			; look down.
00284B  3  85 rr        	sta bufaddr
00284D  3  90 02        	bcc :+
00284F  3  E6 rr        	inc bufaddr+1
002851  3               :
002851  3  68           	pla
002852  3               
002852  3  C6 63        	dec z80_b
002854  3  D0 E9        	bne cangh1
002856  3  60           	rts
002857  3               
002857  3               ;-------------------------------------
002857  3               ; Check left/right movement is okay.
002857  3               ;
002857  3               ; Input:
002857  3               ;  bufaddr = MAP + x/8 + y/8*32
002857  3               ;
002857  3               ; Output:
002857  3               ;  A  = 0 is ok, A <>0 is not ok
002857  3               ;-------------------------------------
002857  3               
002857  3               lrchk:
002857  3  A0 00        	ldy #0
002859  3  B1 rr        	lda (bufaddr),y		; fetch map cell.
00285B  3  C9 02        	cmp #WALL 		; is it passable?
00285D  3  F0 0A        	beq lrchkx		; no.
00285F  3               
00285F  3  C9 04        	cmp #FODDER		; fodder has to be dug.
002861  3  F0 06        	beq lrchkx		; not passable.
002863  3  A9 00        	lda #0
002865  3  60           	rts
002866  3               
002866  3               ;--------------------------------------------------------------
002866  3               ; Called by mmenu
002866  3               ;--------------------------------------------------------------
002866  3               
002866  3               always:
002866  3  A9 FF        	lda #255		; report it as okay.
002868  3  60           	rts
002869  3               
002869  3               lrchkx:
002869  3  A9 01        	lda #1 			; reset all bits.
00286B  3  60           	rts
00286C  3               
00286C  3               
00286C  3               ;--------------------------------------------------------------
00286C  3               ; Check platform or solid item is not in way.
00286C  3               ;
00286C  3               ; Input:
00286C  3               ;  bufaddr = MAP + x/8 + y/8*32
00286C  3               ;
00286C  3               ; Output:
00286C  3               ;  A  = 0 is ok, A <>0 is not ok
00286C  3               ;--------------------------------------------------------------
00286C  3               
00286C  3               plchk:
00286C  3  A0 00        	ldy #0
00286E  3  B1 rr        	lda (bufaddr),y 	; fetch map cell.
002870  3  C9 02        	cmp #WALL 		; is it passable?
002872  3  F0 F5        	beq lrchkx		; no.
002874  3               .if pflag .or dflag
002874  3               	cmp #FODDER		; fodder has to be dug.
002874  3               	beq lrchkx		; not passable.
002874  3               .endif
002874  3  C9 01        	cmp #PLATFM		; platform is solid.
002876  3  F0 03        	beq plchkx		; not passable.
002878  3               .if lflag
002878  3               	cmp #LADDER		; is it a ladder?
002878  3               	beq lrchkx		; on ladder, deny movement.
002878  3               .endif
002878  3               plchk0:
002878  3  A9 00        	lda #0			; report as ok
00287A  3  60           	rts
00287B  3               plchkx:
00287B  3  A5 rr        	lda dispy		; x coordinate.
00287D  3  29 07        	and #7			; position straddling blocks.
00287F  3  F0 E8        	beq lrchkx		; on platform, deny movement.
002881  3  4C 78 28     	jmp plchk0
002884  3               
002884  3               ;--------------------------------------------------------------
002884  3               ; Check ladder is available.
002884  3               ;
002884  3               ; Input:
002884  3               ;  bufaddr = MAP + x/8 + y/8*32
002884  3               ;
002884  3               ; Output:
002884  3               ;  A  = 0 is ok, A <>0 is not ok
002884  3               ;--------------------------------------------------------------
002884  3               
002884  3               .if lflag
002884  3               ldchk:
002884  3               	ldy #0
002884  3               	lda (bufaddr),y 	; fetch cell.
002884  3               	cmp #LADDER 		; is it a ladder?
002884  3               	beq :+
002884  3               	lda #1
002884  3               	rts  			; return with zero flag set accordingly.
002884  3               :
002884  3               	lda #0
002884  3               	rts
002884  3               .endif
002884  3               
002884  3               ;--------------------------------------------------------------
002884  3               ; Get collectables.
002884  3               ;--------------------------------------------------------------
002884  3               
002884  3               .if cflag
002884  3               getcol:
002884  3                       lda #COLECT             ; collectable blocks.
002884  3                       sta z80_b
002884  3                       jsr tded                ; test for collectable blocks.
002884  3                       cmp z80_b               ; did we find one?
002884  3                       beq :+
002884  3                       rts                     ; none were found, job done.
002884  3               :
002884  3                       jsr gtblk               ; get block.
002884  3                       jsr evnt20              ; collected block event.
002884  3                       jmp getcol              ; repeat until none left.
002884  3               
002884  3               ; Get collectable block.
002884  3               
002884  3               gtblk:
002884  3               	ldy #0
002884  3               	lda (bufaddr),y
002884  3               	sta z80_a
002884  3                       lda #0
002884  3                       sta (bufaddr),y		; make it empty now.
002884  3               
002884  3               	lda bufaddr		; set dispx
002884  3               	and #31
002884  3               	sta dispx
002884  3               
002884  3               	lda bufaddr+1		; Set dispy
002884  3               	sec
002884  3               	sbc #>MAP
002884  3               	sta bufaddr+1
002884  3               	asl bufaddr
002884  3               	rol bufaddr+1
002884  3               	asl bufaddr
002884  3               	rol bufaddr+1
002884  3               	asl bufaddr
002884  3               	rol bufaddr+1
002884  3               	lda bufaddr+1
002884  3               	sta dispy
002884  3               
002884  3               	lda colpatt		; get blocknr
002884  3               	sta z80_e		; displacement in e.
002884  3               	lda #0
002884  3               	sta z80_d		; no high byte.
002884  3               	asl z80_e  		; multiply char by 8.
002884  3               	rol z80_d
002884  3               	asl z80_e
002884  3               	rol z80_d
002884  3               	asl z80_e
002884  3               	rol z80_d
002884  3               	clc
002884  3               	lda z80_e
002884  3               	adc #<chgfx 		; address of graphics.
002884  3               	sta tileaddr
002884  3               	lda z80_d
002884  3               	adc #>chgfx
002884  3               	sta tileaddr+1
002884  3               	jsr gprad 		; get screen address.
002884  3               	ldx #7			; number of pixel rows to write.
002884  3               gtblk0:
002884  3               	ldy #0
002884  3               	lda (tileaddr),y 	; get image byte.
002884  3               	ldy scrtab,x
002884  3               	eor (scraddr),y 	; XOR tile on screen
002884  3               	sta (scraddr),y 	; copy to screen.
002884  3               	inc tileaddr 		; next image byte.
002884  3               	bne :+
002884  3               	inc tileaddr+1
002884  3               :
002884  3               	dex	 		; repeat for 8 pixel rows.
002884  3               	bpl gtblk0
002884  3               	rts
002884  3               .endif
002884  3               
002884  3               ;--------------------------------------------------------------
002884  3               ; Touched deadly block check.
002884  3               ; returns with DEADLY (must be non-zero) in accumulator if true.
002884  3               ;
002884  3               ; Input:
002884  3               ;  IX = sprite address
002884  3               ;
002884  3               ; Output:
002884  3               ;  A  = 0 is ok, A=5 is not ok
002884  3               ;--------------------------------------------------------------
002884  3               
002884  3               tded:
002884  3  A0 08        	ldy #8
002886  3  B1 68        	lda (z80_ix),y 		; y coordinate.
002888  3  85 rr        	sta dispy
00288A  3  C8           	iny
00288B  3  B1 68        	lda (z80_ix),y 		; x coordinate.
00288D  3  85 rr        	sta dispx		; coords in dispx,dispy.
00288F  3  20 3F 29     	jsr tstbl		; get map address.
002892  3  48           	pha
002893  3  A9 1F        	lda #31			; default distance to next line down.
002895  3  85 64        	sta z80_e
002897  3  68           	pla
002898  3  C5 63        	cmp z80_b		; is this the required block?
00289A  3  D0 01        	bne :+
00289C  3  60           	rts			; yes.
00289D  3               :
00289D  3  E6 rr        	inc bufaddr 		; next cell.
00289F  3  D0 02        	bne :+
0028A1  3  E6 rr        	inc bufaddr+1
0028A3  3               :
0028A3  3  A0 00        	ldy #0
0028A5  3  B1 rr        	lda (bufaddr),y		; fetch type.
0028A7  3  C5 63        	cmp z80_b 		; is this deadly/custom?
0028A9  3  D0 01        	bne :+
0028AB  3  60           	rts			; yes.
0028AC  3               :
0028AC  3  A5 rr        	lda dispx		; horizontal position.
0028AE  3  85 62        	sta z80_c 		; store column in c register.
0028B0  3  29 07        	and #7			; is it straddling cells?
0028B2  3  D0 03        	bne :+
0028B4  3  4C C8 28     	jmp tded0		; no.
0028B7  3               :
0028B7  3  E6 rr        	inc bufaddr 		; last cell.
0028B9  3  D0 02        	bne :+
0028BB  3  E6 rr        	inc bufaddr+1
0028BD  3               :
0028BD  3  A0 00        	ldy #0
0028BF  3  B1 rr        	lda (bufaddr),y 	; fetch type.
0028C1  3  C5 63        	cmp z80_b		; is this the block?
0028C3  3  D0 01        	bne :+
0028C5  3  60           	rts			; yes.
0028C6  3               :
0028C6  3  C6 64        	dec z80_e		; one less cell to next row down.
0028C8  3               tded0:
0028C8  3  18           	clc 			; point to next row.
0028C9  3  A5 rr        	lda bufaddr
0028CB  3  65 64        	adc z80_e
0028CD  3  85 rr        	sta bufaddr
0028CF  3  90 02        	bcc :+
0028D1  3  E6 rr        	inc bufaddr+1
0028D3  3               :
0028D3  3  A0 00        	ldy #0
0028D5  3  B1 rr        	lda (bufaddr),y		; fetch left cell block.
0028D7  3  C5 63        	cmp z80_b		; is this fatal?
0028D9  3  D0 01        	bne :+
0028DB  3  60           	rts			; yes.
0028DC  3               :
0028DC  3  E6 rr        	inc bufaddr 		; next cell.
0028DE  3  D0 02        	bne :+
0028E0  3  E6 rr        	inc bufaddr+1
0028E2  3               :
0028E2  3  A0 00        	ldy #0
0028E4  3  B1 rr        	lda (bufaddr),y 	; fetch type.
0028E6  3  C5 63        	cmp z80_b		; is this fatal?
0028E8  3  D0 01        	bne :+
0028EA  3  60           	rts			; yes.
0028EB  3               :
0028EB  3  A5 62        	lda z80_c		; horizontal position.
0028ED  3  29 07        	and #7			; is it straddling cells?
0028EF  3  D0 03        	bne :+
0028F1  3  4C 03 29     	jmp tded1 		; no.
0028F4  3               :
0028F4  3  E6 rr        	inc bufaddr		; last cell.
0028F6  3  D0 02        	bne :+
0028F8  3  E6 rr        	inc bufaddr+1
0028FA  3               :
0028FA  3  A0 00        	ldy #0
0028FC  3  B1 rr        	lda (bufaddr),y		; fetch type.
0028FE  3  C5 63        	cmp z80_b		; is this fatal?
002900  3  D0 01        	bne :+
002902  3  60           	rts			; yes.
002903  3               :
002903  3               tded1:
002903  3  A5 rr        	lda dispy		; vertical position.
002905  3  29 07        	and #7 			; is it straddling cells?
002907  3  D0 01        	bne :+
002909  3  60           	rts			; no, job done.
00290A  3               :
00290A  3  18           	clc			; point to next row.
00290B  3  A5 rr        	lda bufaddr
00290D  3  65 64        	adc z80_e
00290F  3  85 rr        	sta bufaddr
002911  3  90 02        	bcc :+
002913  3  E6 rr        	inc bufaddr+1
002915  3               :
002915  3  A0 00        	ldy #0
002917  3  B1 rr        	lda (bufaddr),y 	; fetch left cell block.
002919  3  C5 63        	cmp z80_b		; is this fatal?
00291B  3  D0 01        	bne :+
00291D  3  60           	rts			; yes.
00291E  3               :
00291E  3  E6 rr        	inc bufaddr		; next cell.
002920  3  D0 02        	bne :+
002922  3  E6 rr        	inc bufaddr+1
002924  3               :
002924  3  A0 00        	ldy #0
002926  3  B1 rr        	lda (bufaddr),y 	; fetch type.
002928  3  C5 63        	cmp z80_b		; is this fatal?
00292A  3  D0 01        	bne :+
00292C  3  60           	rts			; yes.
00292D  3               :
00292D  3  A5 62        	lda z80_c		; horizontal position.
00292F  3  29 07        	and #7			; is it straddling cells?
002931  3  D0 01        	bne :+
002933  3  60           	rts			; no.
002934  3               :
002934  3  E6 rr        	inc bufaddr		; last cell.
002936  3  D0 02        	bne :+
002938  3  E6 rr        	inc bufaddr+1
00293A  3               :
00293A  3  A0 00        	ldy #0
00293C  3  B1 rr        	lda (bufaddr),y		; fetch final type.
00293E  3  60           	rts 			; return with final type in accumulator.
00293F  3               
00293F  3               ;---------------------------------------------------
00293F  3               ; Fetch block type at (dispx, dispy).
00293F  3               ;
00293F  3               ; Output:
00293F  3               ;  A = block type
00293F  3               ;---------------------------------------------------
00293F  3               
00293F  3               tstbl:
00293F  3  A5 rr        	lda dispy 		; fetch y coord.
002941  3  4A           	lsr a			; bufaddr = y/8
002942  3  4A           	lsr a
002943  3  4A           	lsr a
002944  3  85 rr        	sta chary
002946  3               
002946  3  85 rr        	sta bufaddr
002948  3  A9 00        	lda #0
00294A  3  85 rr        	sta bufaddr+1
00294C  3               
00294C  3  06 rr        	asl bufaddr  		; bufaddr = y/8 * 32
00294E  3  26 rr        	rol bufaddr+1
002950  3  06 rr        	asl bufaddr
002952  3  26 rr        	rol bufaddr+1
002954  3  06 rr        	asl bufaddr
002956  3  26 rr        	rol bufaddr+1
002958  3  06 rr        	asl bufaddr
00295A  3  26 rr        	rol bufaddr+1
00295C  3  06 rr        	asl bufaddr
00295E  3  26 rr        	rol bufaddr+1
002960  3               
002960  3  A5 rr        	lda dispx		; x/8
002962  3  4A           	lsr a
002963  3  4A           	lsr a
002964  3  4A           	lsr a
002965  3  85 rr        	sta charx
002967  3               
002967  3  18           	clc			; bufaddr = MAP + x/8 + y/8*32
002968  3  65 rr        	adc bufaddr
00296A  3  69 00        	adc #<MAP
00296C  3  85 rr        	sta bufaddr
00296E  3  A5 rr        	lda bufaddr+1
002970  3  69 98        	adc #>MAP
002972  3  85 rr        	sta bufaddr+1
002974  3               
002974  3  A0 00        	ldy #0
002976  3  B1 rr        	lda (bufaddr),y 	; fetch byte there.
002978  3  60           	rts
002979  3               
002979  3               
002979  3               ;-------------------------------------------------------------------
002979  3               ; Jump - if we can.
002979  3               ; Requires initial speed to be set up in accumulator prior to call.
002979  3               ;
002979  3               ; Input:
002979  3               ;  IX = sprite address
002979  3               ;-------------------------------------------------------------------
002979  3               
002979  3               jump:
002979  3  A0 0D        	ldy #13
00297B  3  B1 68        	lda (z80_ix),y		; jump table low.
00297D  3  A0 0E        	ldy #14
00297F  3  11 68        	ora (z80_ix),y		; jump table high.
002981  3  F0 01        	beq :+
002983  3  60           	rts			; already in the air.
002984  3               :
002984  3  A9 38        	lda #>jtab
002986  3  A0 0E        	ldy #14
002988  3  91 68        	sta (z80_ix),y		; set jump high.
00298A  3  A9 B0        	lda #<jtab		; jump table start.
00298C  3  A0 0D        	ldy #13
00298E  3  91 68        	sta (z80_ix),y		; set jump low.
002990  3  60           	rts
002991  3               
002991  3               ; Jump table.
002991  3               
002991  3               ;jtab:
002991  3               ;	.byte 248,250,252
002991  3               ;	.byte 254,254,255
002991  3               ;	.byte 255,255,0,0
002991  3               ;	.byte 0,1,1,1,2,2
002991  3               ;	.byte 4,6,8,8,8,99
002991  3               
002991  3               ;------------------------------------------------
002991  3               ; Random numbers code.
002991  3               ; Pseudo-random number generator, 8-bit.
002991  3               ;
002991  3               ; Output:
002991  3               ;  RND = random number
002991  3               ;------------------------------------------------
002991  3               
002991  3               random:
002991  3  A5 rr        	lda seed
002993  3  F0 05        	beq doEor
002995  3  0A           	asl a
002996  3  F0 04        	beq noEor
002998  3  90 02        	bcc noEor
00299A  3  49 1D        doEor:	eor #$1d
00299C  3  85 rr        noEor:	sta seed
00299E  3  60           	rts
00299F  3               
00299F  3  A5 rr        	lda seed		; get last random number.
0029A1  3  0A           	asl a
0029A2  3  0A           	asl a
0029A3  3  18           	clc
0029A4  3  65 rr        	adc seed
0029A6  3  18           	clc
0029A7  3  69 45        	adc #$45
0029A9  3  85 rr        	sta seed		; store new seed.
0029AB  3  85 rr        	sta varrnd		; return number in variable.
0029AD  3  60           	rts
0029AE  3               
0029AE  3               ;--------------------------------------------------------
0029AE  3               ; Keys
0029AE  3               ;
0029AE  3               ; Out: joyval=x65FUDLR (bit cleared if key pressed)
0029AE  3               ;             ||||||||
0029AE  3               ;             |||||||+> Right    KEY 0  - X
0029AE  3               ;             ||||||+-> Left     KEY 1  - Z
0029AE  3               ;             |||||+--> Down     KEY 2  - .
0029AE  3               ;             ||||+---> Up       KEY 3  - ;
0029AE  3               ;             |||+----> Fire1    KEY 4  - SPC
0029AE  3               ;             ||+-----> Fire2    KEY 5  - Q
0029AE  3               ;             |+------> Fire3    KEY 6  - P
0029AE  3               ;             +-------> Not used
0029AE  3               ;
0029AE  3               ;                       Option1  KEY 7  - 1
0029AE  3               ;                       Option2  KEY 8  - 2
0029AE  3               ;                       Option3  KEY 9  - 3
0029AE  3               ;                       Option4  KEY 10 - 4
0029AE  3               ;--------------------------------------------------------
0029AE  3               
0029AE  3               ;              X   Z   .   ;  SPC  Q   P
0029AE  3               ;keys:   .byte $35,$15,$93,$22,$90,$04,$14       ; Keys defined by game designer.
0029AE  3               ;        .byte $21,$11,$01,$92                   ; menu options.
0029AE  3  03 01 02 04  jkeys:  .byte $03,$01,$02,$04,$00,$04,$14       ; Joykey keys
0029B2  3  00 04 14     
0029B5  3  21 11 01 92          .byte $21,$11,$01,$92                   ; menu options.
0029B9  3               
0029B9  3               ;--------------------------------------------------------
0029B9  3               ; Keyboard test routine.
0029B9  3               ;
0029B9  3               ; Input:
0029B9  3               ;  A = key to read, high nibble=row and low nibble=col
0029B9  3               ;
0029B9  3               ; Output:
0029B9  3               ;  carry clr = key pressed
0029B9  3               ;  carry set = key not pressed
0029B9  3               ;--------------------------------------------------------
0029B9  3               
0029B9  3               ktest:
0029B9  3  85 61        	sta z80_a		; save key
0029BB  3               
0029BB  3  4A           	lsr a			; set row
0029BC  3  4A           	lsr a
0029BD  3  4A           	lsr a
0029BE  3  4A           	lsr a
0029BF  3  09 F0        	ora #ScrMode		; don't flip screenmode
0029C1  3  8D 00 B0     	sta KeyRowAddr
0029C4  3               
0029C4  3  A5 61        	lda z80_a
0029C6  3  29 0F        	and #$0f
0029C8  3  AA           	tax
0029C9  3  AD 01 B0     	lda KeyColAddr		; read column
0029CC  3               
0029CC  3  3D D5 29     	and keymask,x		; check key pressed
0029CF  3  F0 02        	beq pressed
0029D1  3  38           	sec			; key not pressed
0029D2  3  60           	rts
0029D3  3               pressed:
0029D3  3  18           	clc			; key pressed
0029D4  3  60           	rts
0029D5  3               
0029D5  3  01 02 04 08  keymask:	.byte $01,$02,$04,$08,$10,$20
0029D9  3  10 20        
0029DB  3               
0029DB  3               ;-------------------------------------------------------
0029DB  3               ; Joystick and keyboard reading routines.
0029DB  3               ;
0029DB  3               ; contrl = 0, Keyboard
0029DB  3               ;          1, JoyKeyb
0029DB  3               ;          2, JoyMMC
0029DB  3               ;-------------------------------------------------------
0029DB  3               
0029DB  3               joykey:
0029DB  3  A5 rr        	lda contrl 		; control flag.
0029DD  3  C9 01        	cmp #1
0029DF  3  D0 03        	bne :+
0029E1  3  4C FF 29     	jmp joyjoy 		; read keyboard joystick
0029E4  3               :
0029E4  3  C9 02        	cmp #2
0029E6  3  D0 03        	bne :+
0029E8  3  4C 28 2A     	jmp joysin 		; read MMC joystick.
0029EB  3               :
0029EB  3               ; Keyboard controls.
0029EB  3               
0029EB  3  A9 00        	lda #0		 	; zero reading.
0029ED  3  85 64        	sta z80_e
0029EF  3               
0029EF  3  A0 06        	ldy #6	 		; address of last key.
0029F1  3               joyke0:
0029F1  3  B9 B1 38     	lda keys,y 		; get key from table.
0029F4  3  20 B9 29     	jsr ktest		; being pressed?
0029F7  3  26 64        	rol z80_e 		; rotate into reading.
0029F9  3               
0029F9  3  88           	dey		 	; next key.
0029FA  3  10 F5        	bpl joyke0 		; repeat for all keys.
0029FC  3  4C 10 2A     	jmp joyjo1 		; store the value.
0029FF  3               
0029FF  3               ; Keyboard joystick controls.
0029FF  3               
0029FF  3               joyjoy:
0029FF  3  A9 00        	lda #0		 	; zero reading.
002A01  3  85 64        	sta z80_e
002A03  3               
002A03  3  A0 06        	ldy #6	 		; address of last key.
002A05  3               joyjo3:
002A05  3  B9 AE 29     	lda jkeys,y 		; get key from table.
002A08  3  20 B9 29     	jsr ktest		; being pressed?
002A0B  3  26 64        	rol z80_e 		; rotate into reading.
002A0D  3               
002A0D  3  88           	dey		 	; next key.
002A0E  3  10 F5        	bpl joyjo3 		; repeat for all keys.
002A10  3               joyjo1:
002A10  3  A5 64        	lda z80_e 		; copy e register to accumulator.
002A12  3               joyjo2:
002A12  3  85 rr        	sta joyval		; remember value.
002A14  3  60           	rts
002A15  3               
002A15  3               
002A15  3               ; AtoMMC joystick controls.
002A15  3               
002A15  3               ; Set PORTB direction
002A15  3               
002A15  3               joyinit:
002A15  3  A9 FF        	lda #$ff   		; Write value to latch, bits 0-7 input
002A17  3  8D 01 B4     	sta DatReg
002A1A  3  20 56 2A     	jsr interwritedelay
002A1D  3  A9 A1        	lda #$a1   		; Write direction in latch to PORTB
002A1F  3  8D 00 B4     	sta CmdReg
002A22  3               
002A22  3               wait_until_not_busy:
002A22  3  AD 00 B4     	lda CmdReg
002A25  3  30 FB        	bmi wait_until_not_busy
002A27  3  60           	rts
002A28  3               
002A28  3               ; Get PORTB value
002A28  3               
002A28  3               joysin:
002A28  3  A9 A2        	lda #$a2   		; Read value PORTB in latch
002A2A  3  8D 00 B4     	sta CmdReg
002A2D  3  20 56 2A     	jsr interwritedelay
002A30  3               
002A30  3  AD 01 B4     	lda DatReg		; Read joystick status
002A33  3  29 7F        	and #$7f
002A35  3  85 rr        	sta joyval
002A37  3  85 F0        	sta $f0
002A39  3               
002A39  3  AD B6 38     	lda keys+5		; check fire2
002A3C  3  20 B9 29     	jsr ktest
002A3F  3  B0 06        	bcs :+
002A41  3  A5 rr        	lda joyval
002A43  3  29 DF        	and #$df
002A45  3  85 rr        	sta joyval
002A47  3               :
002A47  3  AD B7 38     	lda keys+6		; check fire3
002A4A  3  20 B9 29     	jsr ktest
002A4D  3  B0 06        	bcs :+
002A4F  3  A5 rr        	lda joyval
002A51  3  29 BF        	and #$bf
002A53  3  85 rr        	sta joyval
002A55  3               :
002A55  3  60           	rts
002A56  3               
002A56  3               ; Short delay
002A56  3               ; Enough to intersperse 2 writes to the FATPIC.
002A56  3               
002A56  3               interwritedelay:
002A56  3  A9 08        	lda  #8
002A58  3  38           	sec
002A59  3               loop:
002A59  3  E9 01        	sbc  #1
002A5B  3  D0 FC        	bne  loop
002A5D  3  60           	rts
002A5E  3               
002A5E  3               ;tmp_byte:   .byte 0
002A5E  3               
002A5E  3               ;---------------------------------------------------------------
002A5E  3               ; Getkey in column,row format
002A5E  3               ;
002A5E  3               ; Output:
002A5E  3               ;  A = high nibble=row and low nibble=column key in matrix
002A5E  3               ;---------------------------------------------------------------
002A5E  3               
002A5E  3               kget:
002A5E  3  A9 F0        	lda #ScrMode		; high-mono mode.
002A60  3  8D 00 B0     	sta ScrSelAddr		; screen select port
002A63  3  86 rr        	stx xtmp
002A65  3               kget4:
002A65  3  20 71 FE     	jsr READKEY		; read key until pressed
002A68  3  C0 FF        	cpy #255
002A6A  3  F0 F9        	beq kget4
002A6C  3  85 rr        	sta rcol		; save column
002A6E  3  86 rr        	stx rrow		; determine row
002A70  3               kget3:
002A70  3  20 71 FE     	jsr READKEY		; wait until key released
002A73  3  C0 FF        	cpy #255
002A75  3  D0 F9        	bne kget3
002A77  3               
002A77  3  38           	sec			; calculate matrix row
002A78  3  A9 0A        	lda #10
002A7A  3  E5 rr        	sbc rrow
002A7C  3  0A           	asl a
002A7D  3  0A           	asl a
002A7E  3  0A           	asl a
002A7F  3  0A           	asl a
002A80  3  85 rr        	sta rrow
002A82  3               
002A82  3  A0 FF        	ldy #255		; find column mask
002A84  3               kget1:
002A84  3  C8           	iny
002A85  3  B9 D5 29     	lda keymask,y
002A88  3  C5 rr        	cmp rcol
002A8A  3  F0 03        	beq kget2
002A8C  3  4C 84 2A     	jmp kget1
002A8F  3               kget2:
002A8F  3  98           	tya			; determine column
002A90  3  18           	clc
002A91  3  65 rr        	adc rrow
002A93  3  A6 rr        	ldx xtmp
002A95  3  60           	rts
002A96  3               
002A96  3               ;---------------------------------------------------------------
002A96  3               ; Display message.
002A96  3               ;
002A96  3               ; Input:
002A96  3               ;  A = message number
002A96  3               ;---------------------------------------------------------------
002A96  3               
002A96  3               dmsg:
002A96  3  AA           	tax
002A97  3  A9 BE        	lda #<msgdat		; pointer to messages.
002A99  3  85 66        	sta z80_l
002A9B  3  A9 34        	lda #>msgdat
002A9D  3  85 67        	sta z80_h
002A9F  3  20 B1 2B     	jsr getwrd		; get message number.
002AA2  3               dmsg3:
002AA2  3  20 9E 2B     	jsr preprt		; pre-printing stuff.
002AA5  3  20 CC 23     	jsr checkx		; make sure we"re in a printable range.
002AA8  3  A5 rr        	lda prtmod		; print mode.
002AAA  3  D0 47        	bne bmsg1		; no, double-height text.
002AAC  3               dmsg0:
002AAC  3  A5 67        	lda z80_h		; store string pointer.
002AAE  3  48           	pha
002AAF  3  A5 66        	lda z80_l
002AB1  3  48           	pha
002AB2  3               
002AB2  3  A0 00        	ldy #0
002AB4  3  B1 66        	lda (z80_hl),y		; fetch byte to display.
002AB6  3  29 7F        	and #127		; remove any end marker.
002AB8  3  C9 0D        	cmp #13
002ABA  3  F0 24        	beq dmsg1
002ABC  3  20 60 25     	jsr pchar		; display character.
002ABF  3  20 8B 2B     	jsr nexpos 		; display position.
002AC2  3  D0 03        	bne dmsg2		; not on a new line.
002AC4  3  20 90 2B     	jsr nexlin		; next line down.
002AC7  3               dmsg2:
002AC7  3  68           	pla			; retrieve string pointer
002AC8  3  85 66        	sta z80_l
002ACA  3  68           	pla
002ACB  3  85 67        	sta z80_h
002ACD  3               
002ACD  3  A0 00        	ldy #0
002ACF  3  B1 66        	lda (z80_hl),y		; fetch last character.
002AD1  3  0A           	asl a  			; was it the end?
002AD2  3  90 03        	bcc :+
002AD4  3  4C 1F 24     	jmp dscor2		; yes, job done.
002AD7  3               :
002AD7  3  E6 66        	inc z80_l		; next character to display.
002AD9  3  D0 02        	bne :+
002ADB  3  E6 67        	inc z80_h
002ADD  3               :
002ADD  3  4C AC 2A     	jmp dmsg0
002AE0  3               dmsg1:
002AE0  3  E6 rr        	inc dispy
002AE2  3  A5 rr        	lda dispy
002AE4  3  C9 18        	cmp #24
002AE6  3  90 04        	bcc dmsg4
002AE8  3  A9 00        	lda #0
002AEA  3  85 rr        	sta dispy
002AEC  3               dmsg4:
002AEC  3  A9 00        	lda #0
002AEE  3  85 rr        	sta dispx
002AF0  3  4C C7 2A     	jmp dmsg2
002AF3  3               
002AF3  3               ;prtmod:	.byte 0            	; print mode, 0 = standard, 1 = double-height.
002AF3  3               
002AF3  3               ;----------------------------------------------------------
002AF3  3               ; Display message in big text.
002AF3  3               ;
002AF3  3               ; Input:
002AF3  3               ;  HL = string pointer
002AF3  3               ;----------------------------------------------------------
002AF3  3               
002AF3  3               bmsg1:
002AF3  3  A0 00        	ldy #0
002AF5  3  B1 66        	lda (z80_hl),y 		; get character to display.
002AF7  3  29 7F        	and #127		; only want 7 bits.
002AF9  3  C9 0D        	cmp #13
002AFB  3  F0 13        	beq bmsg2
002AFD  3  20 25 2B     	jsr bchar 		; display big char.
002B00  3               bmsg3:
002B00  3  A0 00        	ldy #0
002B02  3  B1 66        	lda (z80_hl),y 		; look at last character.
002B04  3  48           	pha
002B05  3  E6 66        	inc z80_l 		; next character in list.
002B07  3  D0 02        	bne :+
002B09  3  E6 67        	inc z80_h
002B0B  3               :
002B0B  3  68           	pla
002B0C  3  0A           	asl a  			; was terminator flag set?
002B0D  3  90 E4        	bcc bmsg1		; no, keep going.
002B0F  3  60           	rts
002B10  3               bmsg2:
002B10  3  A9 00        	lda #0
002B12  3  85 rr        	sta dispx
002B14  3  E6 rr        	inc dispy
002B16  3  E6 rr        	inc dispy
002B18  3  A5 rr        	lda dispy
002B1A  3  C9 17        	cmp #23
002B1C  3  90 E2        	bcc bmsg3
002B1E  3  A9 00        	lda #0
002B20  3  85 rr        	sta dispy
002B22  3  4C 00 2B     	jmp bmsg3
002B25  3               
002B25  3               ;----------------------------------------------------------
002B25  3               ; Big character display.
002B25  3               ;
002B25  3               ; Input:
002B25  3               ;  A = character
002B25  3               ;----------------------------------------------------------
002B25  3               
002B25  3               bchar:
002B25  3  85 64        	sta z80_e		; save char in lb
002B27  3  A9 00        	lda #0
002B29  3  85 65        	sta z80_d		; reset hb
002B2B  3               
002B2B  3  06 64        	asl z80_e 		; multiply char by 8.
002B2D  3  26 65        	rol z80_d
002B2F  3  06 64        	asl z80_e
002B31  3  26 65        	rol z80_d
002B33  3  06 64        	asl z80_e
002B35  3  26 65        	rol z80_d		; de = a*8
002B37  3               
002B37  3  18           	clc			; de = Fontpointer + a*8
002B38  3  A5 64        	lda z80_e
002B3A  3  69 B0        	adc #<(FONT-256) 		; address of font.
002B3C  3  85 64        	sta z80_e
002B3E  3  A5 65        	lda z80_d
002B40  3  69 34        	adc #>(FONT-256)
002B42  3  85 65        	sta z80_d
002B44  3               
002B44  3  20 11 25     	jsr gprad 		; get screen address.
002B47  3               
002B47  3  A2 00        	ldx #0			; height of character in font.
002B49  3               bchar0:
002B49  3  A0 00        	ldy #0
002B4B  3  B1 64        	lda (z80_de),y 		; get a bit of the font.
002B4D  3               
002B4D  3               .if iflag
002B4D  3               	eor #$ff
002B4D  3               .endif
002B4D  3               
002B4D  3  91 rr        	sta (scraddr),y
002B4F  3  48           	pha
002B50  3  20 E5 2E     	jsr nline 		; next line down.
002B53  3  68           	pla
002B54  3  91 rr        	sta (scraddr),y
002B56  3  20 E5 2E     	jsr nline 		; next line down.
002B59  3               
002B59  3  18           	clc
002B5A  3  E6 64        	inc z80_e 		; next line of font.
002B5C  3  D0 02        	bne :+
002B5E  3  E6 65        	inc z80_d
002B60  3               :
002B60  3  E8           	inx
002B61  3  E0 08        	cpx #8
002B63  3  D0 E4        	bne bchar0
002B65  3               
002B65  3  20 8B 2B     	jsr nexpos		; display position.
002B68  3  D0 05        	bne bchar2 		; not on a new line.
002B6A  3               bchar3:
002B6A  3  E6 rr        	inc dispy
002B6C  3  20 90 2B     	jsr nexlin 		; next line check.
002B6F  3               bchar2:
002B6F  3  4C 1F 24     	jmp dscor2		; tidy up line and column variables.
002B72  3               
002B72  3               
002B72  3               ;-------------------------------------------------
002B72  3               ; Display a character.
002B72  3               ;
002B72  3               ; Input:
002B72  3               ;  A = character
002B72  3               ;-------------------------------------------------
002B72  3               
002B72  3               achar:
002B72  3  85 63        	sta z80_b 		; copy to b.
002B74  3  20 9E 2B     	jsr preprt 		; get ready to print.
002B77  3  A5 63        	lda z80_b		; character in accumulator.
002B79  3  A6 rr        	ldx prtmod 		; print mode.
002B7B  3  F0 03        	beq :+
002B7D  3  4C 25 2B     	jmp bchar 		; no, double-height text.
002B80  3               :
002B80  3  20 60 25     	jsr pchar 		; display character.
002B83  3  20 8B 2B     	jsr nexpos 		; display position.
002B86  3  F0 E2        	beq bchar3		; next line down.
002B88  3  4C 6F 2B     	jmp bchar2 		; tidy up.
002B8B  3               
002B8B  3               
002B8B  3               ;-------------------------------------------------
002B8B  3               ; Get next print column position.
002B8B  3               ;-------------------------------------------------
002B8B  3               
002B8B  3               nexpos:
002B8B  3  E6 rr        	inc dispx		; move along one position.
002B8D  3  A5 rr        	lda dispx 		; get coordinate.
002B8F  3               ;	and #31
002B8F  3  60           	rts 			; return with status in zero flag.
002B90  3               
002B90  3               ;-------------------------------------------------
002B90  3               ; Get next print line position.
002B90  3               ;-------------------------------------------------
002B90  3               
002B90  3               nexlin:
002B90  3  E6 rr        	inc dispy 		; newline.
002B92  3  A5 rr        	lda dispy		; vertical position.
002B94  3  C9 18        	cmp #24			; past screen edge?
002B96  3  B0 01        	bcs :+
002B98  3  60           	rts			; no, still okay.
002B99  3               :
002B99  3  A9 00        	lda #0			; restart at top.
002B9B  3  85 rr        	sta dispy
002B9D  3  60           	rts
002B9E  3               
002B9E  3               ;--------------------------------------------------------
002B9E  3               ; Pre-print preliminaries.
002B9E  3               ;--------------------------------------------------------
002B9E  3               
002B9E  3               preprt:
002B9E  3  A9 B0        	lda #<(FONT-256)		; font pointer.
002BA0  3  8D CA 23     	sta grbase		; set up graphics base.
002BA3  3  A9 34        	lda #>(FONT-256)
002BA5  3  8D CB 23     	sta grbase+1
002BA8  3               prescr:
002BA8  3  A5 rr        	lda charx 		; display coordinates.
002BAA  3  85 rr        	sta dispx		; set up general coordinates.
002BAC  3  A5 rr        	lda chary
002BAE  3  85 rr        	sta dispy
002BB0  3  60           	rts
002BB1  3               
002BB1  3               ;--------------------------------------------------------------
002BB1  3               ; Get messagenr x in hl
002BB1  3               ;
002BB1  3               ; Input:
002BB1  3               ;  HL = pointer to message list
002BB1  3               ;  X  = message number.
002BB1  3               ;--------------------------------------------------------------
002BB1  3               
002BB1  3               getwrd:
002BB1  3  E0 00        	cpx #0
002BB3  3  D0 01        	bne:+ 			; first word in list?
002BB5  3  60           	rts 			; yep, don't search.
002BB6  3               :
002BB6  3  A0 00        	ldy #0
002BB8  3               getwd0:
002BB8  3  B1 66        	lda (z80_hl),y
002BBA  3  48           	pha
002BBB  3  E6 66        	inc z80_l
002BBD  3  D0 02        	bne :+
002BBF  3  E6 67        	inc z80_h
002BC1  3               :
002BC1  3  68           	pla
002BC2  3  C9 80        	cmp #128		; found end?
002BC4  3  30 F2        	bmi getwd0		; no, carry on.
002BC6  3  CA           	dex			; until we have right number.
002BC7  3  D0 EF        	bne getwd0
002BC9  3  60           	rts
002BCA  3               
002BCA  3               ;-----------------------------------------------------------
002BCA  3               ; Bubble sort.
002BCA  3               ;-----------------------------------------------------------
002BCA  3               
002BCA  3               bsort:
002BCA  3  A9 0B        	lda #NUMSPR - 1		; sprites to swap.
002BCC  3  85 rr        	sta qscnt
002BCE  3               
002BCE  3  A9 33        	lda #<sprtab 		; sprite table.
002BD0  3  85 68        	sta z80_x
002BD2  3  A9 33        	lda #>sprtab
002BD4  3  85 69        	sta z80_i
002BD6  3               bsort0:
002BD6  3  A0 00        	ldy #0
002BD8  3  B1 68        	lda (z80_ix),y 		; first sprite type.
002BDA  3  C9 FF        	cmp #255 		; is it switched off?
002BDC  3  F0 30        	beq swemp		; yes, may need to switch another in here.
002BDE  3               
002BDE  3  A0 11        	ldy #TABSIZ
002BE0  3  B1 68        	lda (z80_ix),y 		; check next slot exists.
002BE2  3  C9 FF        	cmp #255 		; is it enabled?
002BE4  3  F0 0A        	beq bsort2 		; no, nothing to swap.
002BE6  3               
002BE6  3  A0 14        	ldy #TABSIZ+3
002BE8  3  B1 68        	lda (z80_ix),y 		; fetch next sprite's coordinate.
002BEA  3  A0 03        	ldy #3
002BEC  3  D1 68        	cmp (z80_ix),y 		; compare with this x coordinate.
002BEE  3  90 10        	bcc bsort1		; next sprite is higher - may need to switch.
002BF0  3               bsort2:
002BF0  3  18           	clc
002BF1  3  A5 68        	lda z80_x
002BF3  3  69 11        	adc #TABSIZ 		; distance to next odd/even entry.
002BF5  3  85 68        	sta z80_x
002BF7  3  90 02        	bcc :+
002BF9  3  E6 69        	inc z80_i
002BFB  3               :
002BFB  3  C6 rr        	dec qscnt
002BFD  3  D0 D7        	bne bsort0		; repeat for remaining sprites.
002BFF  3  60           	rts
002C00  3               
002C00  3               ;qscnt:	.byte 0
002C00  3               
002C00  3               bsort1:
002C00  3  A0 11        	ldy #TABSIZ
002C02  3  B1 68        	lda (z80_ix),y		; sprite on/off flag.
002C04  3  C9 FF        	cmp #255		; is it enabled?
002C06  3  F0 E8        	beq bsort2		; no, nothing to swap.
002C08  3  20 1C 2C     	jsr swspr		; swap positions.
002C0B  3  4C F0 2B     	jmp bsort2
002C0E  3               swemp:
002C0E  3  A0 11        	ldy #TABSIZ
002C10  3  B1 68        	lda (z80_ix),y		; next table entry.
002C12  3  C9 FF        	cmp #255		; is that one on?
002C14  3  F0 DA        	beq bsort2		; no, nothing to swap.
002C16  3  20 1C 2C     	jsr swspr		; swap positions.
002C19  3  4C F0 2B     	jmp bsort2
002C1C  3               
002C1C  3               ; Swap sprites.
002C1C  3               
002C1C  3               swspr:
002C1C  3  A5 68        	lda z80_x		; table address
002C1E  3  85 64        	sta z80_e		; copy to de pair.
002C20  3  85 66        	sta z80_l		; copy to hl pair.
002C22  3  A5 69        	lda z80_i
002C24  3  85 67        	sta z80_h
002C26  3  85 65        	sta z80_d
002C28  3               
002C28  3  18           	clc
002C29  3  A5 66        	lda z80_l
002C2B  3  69 11        	adc #TABSIZ		; distance to second entry.
002C2D  3  85 66        	sta z80_l
002C2F  3  90 02        	bcc :+
002C31  3  E6 67        	inc z80_h
002C33  3               :
002C33  3  A9 11        	lda #TABSIZ		; bytes to swap.
002C35  3  85 63        	sta z80_b
002C37  3  A0 00        	ldy #0
002C39  3               swspr0:
002C39  3  B1 66        	lda (z80_hl),y		; fetch second byte.
002C3B  3  48           	pha
002C3C  3  B1 64        	lda (z80_de),y 		; fetch first byte.
002C3E  3  91 66        	sta (z80_hl),y 		; copy to second.
002C40  3  68           	pla
002C41  3  91 64        	sta (z80_de),y 		; copy to first sprite entry.
002C43  3               
002C43  3  E6 64        	inc z80_e 		; next byte.
002C45  3  D0 02        	bne :+
002C47  3  E6 65        	inc z80_d
002C49  3               :
002C49  3  E6 66        	inc z80_l 		; next byte.
002C4B  3  D0 02        	bne :+
002C4D  3  E6 67        	inc z80_h
002C4F  3               :
002C4F  3  C6 63        	dec z80_b
002C51  3  D0 E6        	bne swspr0 		; swap all bytes in table entry.
002C53  3  60           	rts
002C54  3               
002C54  3               ;----------------------------------------------------
002C54  3               ; Process sprites.
002C54  3               ;----------------------------------------------------
002C54  3               
002C54  3               pspr:
002C54  3  A9 0C        	lda #NUMSPR		; sprites to process.
002C56  3  85 rr        	sta sprptr
002C58  3               
002C58  3  A9 33        	lda #<sprtab 		; sprite table.
002C5A  3  85 68        	sta z80_x
002C5C  3  A9 33        	lda #>sprtab
002C5E  3  85 69        	sta z80_i
002C60  3               pspr1:
002C60  3  A0 00        	ldy #0
002C62  3  B1 68        	lda (z80_ix),y		; fetch sprite type.
002C64  3  C9 09        	cmp #9 			; within range of sprite types?
002C66  3  B0 03        	bcs :+
002C68  3  20 7B 2C     	jsr pspr2 		; yes, process this one.
002C6B  3               :
002C6B  3  18           	clc
002C6C  3  A5 68        	lda z80_x
002C6E  3  69 11        	adc #TABSIZ 		; distance to next odd/even entry.
002C70  3  85 68        	sta z80_x
002C72  3  90 02        	bcc :+
002C74  3  E6 69        	inc z80_i		; next sprite.
002C76  3               :
002C76  3  C6 rr        	dec sprptr 		; repeat for remaining sprites.
002C78  3  D0 E6        	bne pspr1
002C7A  3  60           	rts
002C7B  3               
002C7B  3               ;sprptr:	.byte 0
002C7B  3               
002C7B  3               pspr2:
002C7B  3  A5 68        	lda z80_x 		; store original sprite pointer.
002C7D  3  85 rr        	sta ogptr
002C7F  3  A5 69        	lda z80_i
002C81  3  85 rr        	sta ogptr+1
002C83  3  20 8F 2C     	jsr pspr3		; do the routine.
002C86  3               rtorg:
002C86  3  A5 rr        	lda ogptr 		; restore original pointer to sprite.
002C88  3  85 68        	sta z80_x
002C8A  3  A5 rr        	lda ogptr+1
002C8C  3  85 69        	sta z80_i
002C8E  3               rtorg0:
002C8E  3  60           	rts
002C8F  3               
002C8F  3               pspr3:
002C8F  3  A9 C4        	lda #<evtyp0		; sprite type events list.
002C91  3  85 66        	sta z80_l
002C93  3  A9 2C        	lda #>evtyp0
002C95  3  85 67        	sta z80_h
002C97  3               pspr4:
002C97  3  B1 68        	lda (z80_ix),y
002C99  3  0A           	asl a			; double accumulator.
002C9A  3  18           	clc
002C9B  3  65 66        	adc z80_l
002C9D  3  85 66        	sta z80_l
002C9F  3  90 02        	bcc :+
002CA1  3  E6 67        	inc z80_h
002CA3  3               :
002CA3  3  B1 66        	lda (z80_hl),y
002CA5  3  85 64        	sta z80_e 		; copy to de.
002CA7  3  48           	pha
002CA8  3               
002CA8  3  E6 66        	inc z80_l 		; next byte of address.
002CAA  3  D0 02        	bne :+
002CAC  3  E6 67        	inc z80_h
002CAE  3               :
002CAE  3  B1 66        	lda (z80_hl),y 		; address high.
002CB0  3  85 65        	sta z80_d
002CB2  3               
002CB2  3  48           	pha	 		; swap address into hl.
002CB3  3  A5 67        	lda z80_h
002CB5  3  85 65        	sta z80_d
002CB7  3  68           	pla
002CB8  3  85 67        	sta z80_h
002CBA  3  68           	pla
002CBB  3  85 66        	sta z80_l
002CBD  3  A5 66        	lda z80_l
002CBF  3  85 64        	sta z80_e
002CC1  3               
002CC1  3  6C 66 00     	jmp (z80_hl) 		; go there.
002CC4  3               
002CC4  3               ;ogptr:	.word 0			; original sprite pointer.
002CC4  3               
002CC4  3               ; Address of each sprite type's routine.
002CC4  3               
002CC4  3  45 34        evtyp0:	.word evnt00
002CC6  3  46 34        evtyp1:	.word evnt01
002CC8  3  47 34        evtyp2:	.word evnt02
002CCA  3  48 34        evtyp3:	.word evnt03
002CCC  3  49 34        evtyp4:	.word evnt04
002CCE  3  4A 34        evtyp5:	.word evnt05
002CD0  3  4B 34        evtyp6:	.word evnt06
002CD2  3  4C 34        evtyp7:	.word evnt07
002CD4  3  4D 34        evtyp8:	.word evnt08
002CD6  3               
002CD6  3               ;--------------------------------------------------------------
002CD6  3               ; Display sprites.
002CD6  3               ;
002CD6  3               ; Input:
002CD6  3               ;  IX = sprite table
002CD6  3               ;--------------------------------------------------------------
002CD6  3               
002CD6  3               dspr:
002CD6  3  A9 06        	lda #(NUMSPR/2)		; number of sprites to display.
002CD8  3  85 rr        	sta sprcnt
002CDA  3               dspr0:
002CDA  3  A0 00        	ldy #0
002CDC  3  B1 68        	lda (z80_ix),y 		; get sprite type.
002CDE  3  C9 FF        	cmp #255 		; is it enabled?
002CE0  3  D0 42        	bne dspr1 		; yes, it needs deleting.
002CE2  3               dspr5:
002CE2  3  A0 05        	ldy #5
002CE4  3  B1 68        	lda (z80_ix),y 		; new type.
002CE6  3  C9 FF        	cmp #255		; is it enabled?
002CE8  3  D0 77        	bne dspr3 		; yes, it needs drawing.
002CEA  3               dspr2:
002CEA  3  A0 05        	ldy #5
002CEC  3  B1 68        	lda (z80_ix),y 		; copy new type.
002CEE  3  A0 00        	ldy #0
002CF0  3  91 68        	sta (z80_ix),y
002CF2  3  A0 06        	ldy #6
002CF4  3  B1 68        	lda (z80_ix),y 		; copy new image number.
002CF6  3  A0 01        	ldy #1
002CF8  3  91 68        	sta (z80_ix),y
002CFA  3  A0 07        	ldy #7
002CFC  3  B1 68        	lda (z80_ix),y 		; copy new frame.
002CFE  3  A0 02        	ldy #2
002D00  3  91 68        	sta (z80_ix),y
002D02  3  A0 08        	ldy #8
002D04  3  B1 68        	lda (z80_ix),y 		; copy new y.
002D06  3  A0 03        	ldy #3
002D08  3  91 68        	sta (z80_ix),y
002D0A  3  A0 09        	ldy #9
002D0C  3  B1 68        	lda (z80_ix),y 		; copy new x.
002D0E  3  A0 04        	ldy #4
002D10  3  91 68        	sta (z80_ix),y
002D12  3               
002D12  3  18           	clc
002D13  3  A5 68        	lda z80_x
002D15  3  69 22        	adc #(TABSIZ*2)		; distance to next odd/even entry.
002D17  3  85 68        	sta z80_x
002D19  3  A5 69        	lda z80_i
002D1B  3  69 00        	adc #0
002D1D  3  85 69        	sta z80_i 		; next sprite.
002D1F  3  C6 rr        	dec sprcnt
002D21  3  D0 B7        	bne dspr0		; repeat for remaining sprites.
002D23  3  60           	rts
002D24  3               dspr1:
002D24  3  A0 05        	ldy #5
002D26  3  B1 68        	lda (z80_ix),y 		; type of new sprite.
002D28  3  C9 FF        	cmp #255		; is this enabled?
002D2A  3  D0 06        	bne dspr4 		; yes, display both.
002D2C  3               dspr6:
002D2C  3  20 FC 2D     	jsr sspria 		; show single sprite.
002D2F  3  4C EA 2C     	jmp dspr2
002D32  3               
002D32  3               ; Displaying two sprites.  Don't bother redrawing if nothing has changed.
002D32  3               
002D32  3               dspr4:
002D32  3  A0 04        	ldy #4
002D34  3  B1 68        	lda (z80_ix),y		; old x.
002D36  3  A0 09        	ldy #9
002D38  3  D1 68        	cmp (z80_ix),y 		; compare with new value.
002D3A  3  D0 1F        	bne dspr7 		; they differ, need to redraw.
002D3C  3               
002D3C  3  A0 03        	ldy #3
002D3E  3  B1 68        	lda (z80_ix),y		; old y.
002D40  3  A0 08        	ldy #8
002D42  3  D1 68        	cmp (z80_ix),y 		; compare against new value.
002D44  3  D0 15        	bne dspr7		; they differ, need to redraw.
002D46  3               
002D46  3  A0 02        	ldy #2
002D48  3  B1 68        	lda (z80_ix),y 		; old frame.
002D4A  3  A0 07        	ldy #7
002D4C  3  D1 68        	cmp (z80_ix),y 		; compare against new value.
002D4E  3  4C 5B 2D     	jmp dspr7 		; they differ, need to redraw.
002D51  3               
002D51  3  A0 01        	ldy #1
002D53  3  B1 68        	lda (z80_ix),y 		; old image.
002D55  3  A0 06        	ldy #6
002D57  3  D1 68        	cmp (z80_ix),y 		; compare against new value.
002D59  3  F0 8F        	beq dspr2		; everything is the same, don't redraw.
002D5B  3               dspr7:
002D5B  3  20 29 2E     	jsr sspric 		; delete old sprite, draw new one simultaneously.
002D5E  3  4C EA 2C     	jmp dspr2
002D61  3               dspr3:
002D61  3  20 23 2E     	jsr ssprib 		; show single sprite.
002D64  3  4C EA 2C     	jmp dspr2
002D67  3               
002D67  3               ;sprcnt:	.byte 0
002D67  3               
002D67  3               ;-----------------------------------------
002D67  3               ; Get sprite address calculations.
002D67  3               ; gspran = new sprite, gsprad = old sprite.
002D67  3               ;
002D67  3               ; Input:
002D67  3               ;  IX = sprite address
002D67  3               ;-----------------------------------------
002D67  3               
002D67  3               gspran:
002D67  3  A0 08        	ldy #8
002D69  3  B1 68        	lda (z80_ix),y 		; new y coordinate.
002D6B  3  85 rr        	sta dispy
002D6D  3  A0 09        	ldy #9
002D6F  3  B1 68        	lda (z80_ix),y 		; new x coordinate.
002D71  3  85 rr        	sta dispx
002D73  3  A0 06        	ldy #6
002D75  3  B1 68        	lda (z80_ix),y 		; new sprite image.
002D77  3  20 55 31     	jsr gfrm		; fetch start frame for this sprite.
002D7A  3               
002D7A  3  A0 00        	ldy #0
002D7C  3  B1 66        	lda (z80_hl),y 		; frame in accumulator.
002D7E  3  A0 07        	ldy #7
002D80  3  18           	clc
002D81  3  71 68        	adc (z80_ix),y 		; new add frame number.
002D83  3  4C A2 2D     	jmp gspra0
002D86  3               
002D86  3               ;-----------------------------------------
002D86  3               ; Calculate old sprite address
002D86  3               ;
002D86  3               ; Input:
002D86  3               ;  IX = sprite address
002D86  3               ;
002D86  3               ; Output:
002D86  3               ;  B  = right byte mask
002D86  3               ;  C  = left byte mask
002D86  3               ;  DE = spriteframe address
002D86  3               ;  scraddr = screenaddress(dispx,dispy)
002D86  3               ;-----------------------------------------
002D86  3               
002D86  3               gsprad:
002D86  3  A0 03        	ldy #3
002D88  3  B1 68        	lda (z80_ix),y		; y coordinate.
002D8A  3  85 rr        	sta dispy
002D8C  3  A0 04        	ldy #4
002D8E  3  B1 68        	lda (z80_ix),y		; x coordinate.
002D90  3  85 rr        	sta dispx
002D92  3  A0 01        	ldy #1
002D94  3  B1 68        	lda (z80_ix),y 		; sprite image.
002D96  3  20 55 31     	jsr gfrm 		; fetch start frame for this sprite.
002D99  3               
002D99  3  A0 00        	ldy #0
002D9B  3  B1 66        	lda (z80_hl),y 		; frame in accumulator.
002D9D  3  A0 02        	ldy #2
002D9F  3  18           	clc
002DA0  3  71 68        	adc (z80_ix),y 		; add frame number.
002DA2  3               gspra0:
002DA2  3  4A           	lsr a	  		; multiply by 128.
002DA3  3  85 65        	sta z80_d 		; store in d.
002DA5  3  8D FA 2D     	sta tmp1
002DA8  3  A9 00        	lda #0
002DAA  3  6A           	ror a
002DAB  3  85 64        	sta z80_e 		; got low byte.
002DAD  3  8D FB 2D     	sta tmp2
002DB0  3               .if bflag
002DB0  3               	lsr tmp1
002DB0  3               	ror tmp2
002DB0  3               	clc
002DB0  3               	lda tmp2
002DB0  3               	adc z80_e
002DB0  3               	sta z80_e
002DB0  3               	lda tmp1
002DB0  3               	adc z80_d
002DB0  3               	sta z80_d
002DB0  3               .endif
002DB0  3  18           	clc 			; address of play sprites.
002DB1  3  A5 64        	lda z80_e
002DB3  3  69 F5        	adc #<sprgfx
002DB5  3  85 64        	sta z80_e
002DB7  3  A5 65        	lda z80_d
002DB9  3  69 34        	adc #>sprgfx
002DBB  3  85 65        	sta z80_d
002DBD  3               
002DBD  3  A5 rr        	lda dispx 		; y coordinate.
002DBF  3  29 06        	and #6 			; position within byte boundary.
002DC1  3  AA           	tax	 		; low byte of table displacement.
002DC2  3               
002DC2  3  0A           	asl a	  		; multiply by 32.
002DC3  3  0A           	asl a  			; already a multiple
002DC4  3  0A           	asl a  			; of 2, so just 4
002DC5  3               .if bflag
002DC5  3               	sta tmp1
002DC5  3               	asl a  			; shifts needed.
002DC5  3               	clc
002DC5  3               	adc tmp1
002DC5  3               .else
002DC5  3  0A           	asl a  			; shifts needed.
002DC6  3               .endif
002DC6  3  18           	clc 			; add to sprite address.
002DC7  3  65 64        	adc z80_e
002DC9  3  85 64        	sta z80_e
002DCB  3  90 02        	bcc :+
002DCD  3  E6 65        	inc z80_d
002DCF  3               :
002DCF  3  BD F2 2D     	lda spmask,x		 ; pointer to mask table.
002DD2  3  85 62        	sta z80_c 		; left mask.
002DD4  3  BD F3 2D     	lda spmask+1,x
002DD7  3  85 63        	sta z80_b 		; right mask.
002DD9  3               
002DD9  3               ;------------------------------------------------------------------
002DD9  3               ; Drop into screen address routine.
002DD9  3               ; This routine returns a screen address for (dispx, dispy) in scraddr.
002DD9  3               ;------------------------------------------------------------------
002DD9  3               
002DD9  3               scadd:
002DD9  3  A6 rr        	ldx dispy
002DDB  3  E0 C0        	cpx #192
002DDD  3  90 02        	bcc :+
002DDF  3  A2 C0        	ldx #192
002DE1  3               :
002DE1  3  A5 rr        	lda dispx
002DE3  3  4A           	lsr a
002DE4  3  4A           	lsr a
002DE5  3  4A           	lsr a
002DE6  3  18           	clc
002DE7  3  7D 00 9B     	adc SCADTB_lb,x
002DEA  3  85 rr        	sta scraddr
002DEC  3  BD 00 9C     	lda SCADTB_hb,x
002DEF  3  85 rr        	sta scraddr+1
002DF1  3  60           	rts
002DF2  3               
002DF2  3  FF 00        spmask:	.byte $ff,$00
002DF4  3  3F C0        	.byte $3f,$c0
002DF6  3  0F F0        	.byte $0f,$f0
002DF8  3  03 FC        	.byte $03,$fc
002DFA  3               
002DFA  3  00           tmp1:	.byte 0
002DFB  3  00           tmp2:	.byte 0
002DFC  3               
002DFC  3               ;-----------------------------------------------------------------
002DFC  3               ; These are the sprite routines.
002DFC  3               ; sspria = single sprite, old (ix).
002DFC  3               ; ssprib = single sprite, new (ix+5).
002DFC  3               ; sspric = both sprites, old (ix) and new (ix+5).
002DFC  3               ;-----------------------------------------------------------------
002DFC  3               
002DFC  3               sspria:
002DFC  3  20 86 2D     	jsr gsprad		; get old sprite address.
002DFF  3               sspri2:
002DFF  3  A5 64        	lda z80_e
002E01  3  8D 71 2E     	sta dline1+1		; Set spritedata address
002E04  3  8D 80 2E     	sta dline2+1
002E07  3  A5 65        	lda z80_d
002E09  3  8D 72 2E     	sta dline1+2
002E0C  3  8D 81 2E     	sta dline2+2
002E0F  3  86 rr        	stx xtmp
002E11  3  A2 00        	ldx #0			; vertical lines.
002E13  3               sspri0:
002E13  3  20 6D 2E     	jsr dline		; draw a line.
002E16  3  E0 10        	cpx #16			; detect block boundery
002E18  3  D0 02        	bne :+			; skip if not
002E1A  3  E6 rr        	inc scraddr+1		; jump to next blockline
002E1C  3               :
002E1C  3  E0 20        	cpx #32			; check finished
002E1E  3               .if bflag
002E1E  3               	bne :+			; skip if not
002E1E  3               	inc scraddr+1		; jump to next blockline
002E1E  3               	inc z80_hlp+1		; jump to next blockline
002E1E  3               :
002E1E  3               	cpx #48			; check finished
002E1E  3               .endif
002E1E  3  D0 F3        	bne sspri0		; no, repeat
002E20  3  A6 rr        	ldx xtmp
002E22  3  60           	rts
002E23  3               
002E23  3               ;-----------------------------------------------------------------
002E23  3               
002E23  3               ssprib:
002E23  3  20 67 2D     	jsr gspran 		; get new sprite address.
002E26  3  4C FF 2D     	jmp sspri2
002E29  3               
002E29  3               ;-----------------------------------------------------------------
002E29  3               
002E29  3               sspric:
002E29  3  20 86 2D     	jsr gsprad 		; get old sprite address.
002E2C  3  A5 64        	lda z80_e
002E2E  3  8D 95 2E     	sta ddline1+1		; Set spritedata address
002E31  3  8D A4 2E     	sta ddline2+1
002E34  3  A5 65        	lda z80_d
002E36  3  8D 96 2E     	sta ddline1+2
002E39  3  8D A5 2E     	sta ddline2+2
002E3C  3  20 BC 38     	jsr exx  		; store addresses.
002E3F  3               
002E3F  3  20 67 2D     	jsr gspran 		; get new sprite addresses.
002E42  3  A5 64        	lda z80_e
002E44  3  8D 71 2E     	sta dline1+1		; Set spritedata address
002E47  3  8D 80 2E     	sta dline2+1
002E4A  3  A5 65        	lda z80_d
002E4C  3  8D 72 2E     	sta dline1+2
002E4F  3  8D 81 2E     	sta dline2+2
002E52  3               
002E52  3  86 rr        	stx xtmp
002E54  3  A2 00        	ldx #0			; vertical lines.
002E56  3               lloop:
002E56  3  20 6D 2E     	jsr dline 		; draw a line.
002E59  3  CA           	dex
002E5A  3  CA           	dex
002E5B  3  20 91 2E     	jsr ddline 		; delete a line.
002E5E  3  E0 10        	cpx #16			; detect block boundery
002E60  3  D0 04        	bne :+			; skip if not
002E62  3  E6 rr        	inc scraddr+1		; jump to next blockline
002E64  3  E6 73        	inc z80_hlp+1		; jump to next blockline
002E66  3               :
002E66  3  E0 20        	cpx #32			; check finished
002E68  3               .if bflag
002E68  3               	bne :+			; skip if not
002E68  3               	inc scraddr+1		; jump to next blockline
002E68  3               	inc z80_hlp+1		; jump to next blockline
002E68  3               :
002E68  3               	cpx #48			; check finished
002E68  3               .endif
002E68  3  D0 EC        	bne lloop		; no, repeat
002E6A  3  A6 rr        	ldx xtmp
002E6C  3  60           	rts
002E6D  3               
002E6D  3               
002E6D  3               ;-----------------------------------------------------------------
002E6D  3               
002E6D  3               dline:
002E6D  3  BC B5 2E     	ldy sprline,x		; point to screenleft
002E70  3               dline1:
002E70  3  BD 8A 35     	lda objdta,x		; fetch spriteleft byte
002E73  3  85 61        	sta z80_a		; save spriteright byte
002E75  3  A5 61        	lda z80_a
002E77  3  25 62        	and z80_c		; mask left
002E79  3  51 rr        	eor (scraddr),y		; merge with screenleft
002E7B  3  91 rr        	sta (scraddr),y		; write screenleft
002E7D  3               sline:
002E7D  3  E8           	inx			; next spritebyte
002E7E  3  C8           	iny			; point to screenmiddle
002E7F  3               dline2:
002E7F  3  BD 8A 35     	lda objdta,x		; fetch spritemiddle byte
002E82  3  51 rr        	eor (scraddr),y		; merge with screenmiddle
002E84  3  91 rr        	sta (scraddr),y		; write screenmiddle
002E86  3               sline2:
002E86  3  C8           	iny			; point to screenright
002E87  3  A5 61        	lda z80_a		; fetch spriteright byte
002E89  3  25 63        	and z80_b		; mask right
002E8B  3  51 rr        	eor (scraddr),y		; merge with screenright
002E8D  3  91 rr        	sta (scraddr),y		; write screenright
002E8F  3               sline3:
002E8F  3  E8           	inx			; next spritebyte
002E90  3               
002E90  3  60           	rts
002E91  3               
002E91  3               ;-----------------------------------------------------------------
002E91  3               
002E91  3               ddline:
002E91  3  BC B5 2E     	ldy sprline,x		; point to screenleft
002E94  3               ddline1:
002E94  3  BD 8A 35     	lda objdta,x		; fetch spriteleft byte
002E97  3  85 61        	sta z80_a		; save spriteright byte
002E99  3  A5 61        	lda z80_a
002E9B  3  25 6E        	and z80_cp		; mask left
002E9D  3  51 72        	eor (z80_hlp),y		; merge with screenleft
002E9F  3  91 72        	sta (z80_hlp),y		; write screenleft
002EA1  3               dsline:
002EA1  3  E8           	inx			; next spritebyte
002EA2  3  C8           	iny			; point to screenmiddle
002EA3  3               ddline2:
002EA3  3  BD 8A 35     	lda objdta,x		; fetch spritemiddle byte
002EA6  3  51 72        	eor (z80_hlp),y		; merge with screenmiddle
002EA8  3  91 72        	sta (z80_hlp),y		; write screenmiddle
002EAA  3               dsline2:
002EAA  3  C8           	iny			; point to screenright
002EAB  3  A5 61        	lda z80_a		; fetch spriteright byte
002EAD  3  25 6F        	and z80_bp		; mask right
002EAF  3  51 72        	eor (z80_hlp),y		; merge with screenright
002EB1  3  91 72        	sta (z80_hlp),y		; write screenright
002EB3  3               dsline3:
002EB3  3  E8           	inx			; next spritebyte
002EB4  3               
002EB4  3  60           	rts
002EB5  3               
002EB5  3               sprline:
002EB5  3  00 01 20 21  	.byte $00,$01,$20,$21,$40,$41,$60,$61
002EB9  3  40 41 60 61  
002EBD  3  80 81 A0 A1  	.byte $80,$81,$a0,$a1,$c0,$c1,$e0,$e1
002EC1  3  C0 C1 E0 E1  
002EC5  3  00 01 20 21  	.byte $00,$01,$20,$21,$40,$41,$60,$61
002EC9  3  40 41 60 61  
002ECD  3  80 81 A0 A1  	.byte $80,$81,$a0,$a1,$c0,$c1,$e0,$e1
002ED1  3  C0 C1 E0 E1  
002ED5  3  00 01 20 21  	.byte $00,$01,$20,$21,$40,$41,$60,$61
002ED9  3  40 41 60 61  
002EDD  3  80 81 A0 A1  	.byte $80,$81,$a0,$a1,$c0,$c1,$e0,$e1
002EE1  3  C0 C1 E0 E1  
002EE5  3               
002EE5  3               ;----------------------------------------------------------------------
002EE5  3               ; Line drawn, now work out next target address.
002EE5  3               ;----------------------------------------------------------------------
002EE5  3               
002EE5  3               nline:
002EE5  3  18           	clc
002EE6  3  A5 rr        	lda scraddr 		; get low byte of address.
002EE8  3  69 20        	adc #$20
002EEA  3  85 rr        	sta scraddr 		; new low byte of address.
002EEC  3  90 02        	bcc :+
002EEE  3  E6 rr        	inc scraddr+1 		; new high byte of address.
002EF0  3               :
002EF0  3  60           	rts
002EF1  3               
002EF1  3               ;-------------------------------------------------------------
002EF1  3               ; Line drawn, now work out next target address.
002EF1  3               ;
002EF1  3               ; Input:
002EF1  3               ;  BP  = right mask
002EF1  3               ;  CP  = left mask
002EF1  3               ;  DEP = spriteaddress
002EF1  3               ;  z80_hlp = screen address
002EF1  3               ;-------------------------------------------------------------
002EF1  3               
002EF1  3               
002EF1  3               ;-----------------------------------------------------------
002EF1  3               ; Animates a sprite.
002EF1  3               ;
002EF1  3               ; Input:
002EF1  3               ;  IX = sprite address
002EF1  3               ;  HL = last sprite address
002EF1  3               ;-----------------------------------------------------------
002EF1  3               
002EF1  3               animsp:
002EF1  3  25 rr        	and frmno
002EF3  3  F0 01        	beq :+
002EF5  3  60           	rts
002EF6  3               :
002EF6  3  A0 06        	ldy #6
002EF8  3  B1 68        	lda (z80_ix),y		; sprite image
002EFA  3  20 55 31     	jsr gfrm		; get frame data.
002EFD  3               
002EFD  3  E6 66        	inc z80_l		; point to frames.
002EFF  3  D0 02        	bne :+
002F01  3  E6 67        	inc z80_h
002F03  3               :
002F03  3  A0 07        	ldy #7
002F05  3  B1 68        	lda (z80_ix),y		; sprite frame.
002F07  3  18           	clc
002F08  3  69 01        	adc #1			; next one along.
002F0A  3  A0 00        	ldy #0
002F0C  3  D1 66        	cmp (z80_hl),y		; reached the last frame?
002F0E  3  90 02        	bcc anims0		; no, not yet.
002F10  3  A9 00        	lda #0			; start at first frame.
002F12  3               anims0:
002F12  3  A0 07        	ldy #7
002F14  3  91 68        	sta (z80_ix),y		; new frame.
002F16  3  60           	rts
002F17  3               
002F17  3               ;--------------------------------------------------------------
002F17  3               ; Animate back
002F17  3               ;
002F17  3               ; Input:
002F17  3               ;  IX = sprite address
002F17  3               ;  HL = last sprite address
002F17  3               ;--------------------------------------------------------------
002F17  3               
002F17  3               animbk:
002F17  3  25 rr        	and frmno
002F19  3  F0 01        	beq :+
002F1B  3  60           	rts
002F1C  3               :
002F1C  3  A0 06        	ldy #6
002F1E  3  B1 68        	lda (z80_ix),y		; sprite image.
002F20  3  20 55 31     	jsr gfrm		; get frame data.
002F23  3               
002F23  3  E6 66        	inc z80_l 		; point to frames.
002F25  3  D0 02        	bne :+
002F27  3  E6 67        	inc z80_h
002F29  3               :
002F29  3  A0 07        	ldy #7
002F2B  3  B1 68        	lda (z80_ix),y 		; sprite frame.
002F2D  3  F0 03        	beq :+
002F2F  3  4C 36 2F     	jmp rtanb0 		; yes, start at end.
002F32  3               :
002F32  3  A0 00        	ldy #0
002F34  3  B1 66        	lda (z80_hl),y 		; last sprite.
002F36  3               rtanb0:
002F36  3  38           	sec
002F37  3  E9 01        	sbc #1			; next one along.
002F39  3  4C 12 2F     	jmp anims0		; set new frame.
002F3C  3               
002F3C  3               ;--------------------------------------------------------------
002F3C  3               ; Check for collision with other sprite, strict enforcement.
002F3C  3               ;
002F3C  3               ; Input:
002F3C  3               ;  b		= sprite to test for
002F3C  3               ;  ix		= current sprite pointer
002F3C  3               ;
002F3C  3               ; global:	b
002F3C  3               ; local:	x,y,hl,de,skptr
002F3C  3               ; calls:	-
002F3C  3               ;--------------------------------------------------------------
002F3C  3               
002F3C  3               sktyp:
002F3C  3  A9 33        	lda #<sprtab				; sprite table.
002F3E  3  85 66        	sta z80_l
002F40  3  A9 33        	lda #>sprtab
002F42  3  85 67        	sta z80_h
002F44  3               numsp2:
002F44  3  A9 0C        	lda #NUMSPR				; number of sprites.
002F46  3  85 rr        	sta sktptr
002F48  3               sktyp0:
002F48  3  A5 66        	lda z80_l 				; store pointer to sprite.
002F4A  3  85 rr        	sta skptr
002F4C  3  A5 67        	lda z80_h
002F4E  3  85 rr        	sta skptr+1
002F50  3               
002F50  3  A0 00        	ldy #0
002F52  3  B1 66        	lda (z80_hl),y 				; get sprite type.
002F54  3  C5 63        	cmp z80_b				; is it the type we seek?
002F56  3  F0 1D        	beq coltyp				; yes, we can use this one.
002F58  3               sktyp1:
002F58  3  18           	clc
002F59  3  A5 rr        	lda skptr				; retrieve sprite pointer.
002F5B  3  69 11        	adc #TABSIZ				; size of each entry.
002F5D  3  85 66        	sta z80_l
002F5F  3  A5 rr        	lda skptr+1
002F61  3  69 00        	adc #0
002F63  3  85 67        	sta z80_h
002F65  3  C6 rr        	dec sktptr					; one less iteration.
002F67  3  D0 DF        	bne sktyp0				; keep going until we find a slot.
002F69  3  A9 00        	lda #0					; default to ROM address - no sprite.
002F6B  3  85 66        	sta z80_l
002F6D  3  85 67        	sta z80_h
002F6F  3  85 rr        	sta skptr				; store pointer to sprite.
002F71  3  85 rr        	sta skptr+1
002F73  3               
002F73  3  18           	clc					; don't return with zero flag set.
002F74  3  60           	rts 					; didn't find one.
002F75  3               
002F75  3               ;skptr:	.word 0					; search pointer.
002F75  3               ;sktptr:	.byte 0
002F75  3               
002F75  3               coltyp:
002F75  3  A0 00        	ldy #0
002F77  3  B1 68        	lda (z80_ix),y				; current sprite type.
002F79  3  C5 63        	cmp z80_b				; seeking sprite of same type?
002F7B  3  F0 3D        	beq colty1				; yes, need to check we're not detecting ourselves.
002F7D  3               colty0:
002F7D  3  A0 09        	ldy #9					; distance to x position in table.
002F7F  3  B1 66        	lda (z80_hl),y				; fetch x coordinate.
002F81  3  85 64        	sta z80_e
002F83  3  88           	dey
002F84  3  B1 66        	lda (z80_hl),y				; fetch y coordinate.
002F86  3  85 65        	sta z80_d
002F88  3               
002F88  3               ; Drop into collision detection.
002F88  3               
002F88  3               colc16:
002F88  3  A0 09        	ldy #9
002F8A  3  B1 68        	lda (z80_ix),y			 	; x coord.
002F8C  3  38           	sec					; subtract x.
002F8D  3  E5 64        	sbc z80_e
002F8F  3  B0 05        	bcs  colc1a 				; result is positive.
002F91  3  49 FF        	eor #$ff				; make negative positive.
002F93  3  18           	clc
002F94  3  69 01        	adc #1
002F96  3               colc1a:
002F96  3  C9 10        	cmp #16 				; within x range?
002F98  3  B0 BE        	bcs sktyp1				; no - they"ve missed.
002F9A  3  85 62        	sta z80_c				; store difference.
002F9C  3               
002F9C  3  A0 08        	ldy #8
002F9E  3  B1 68        	lda (z80_ix),y				; y coord.
002FA0  3  38           	sec
002FA1  3  E5 65        	sbc z80_d				; subtract y.
002FA3  3  B0 05        	bcs colc1b				; result is positive.
002FA5  3  49 FF        	eor #$ff				; make negative positive.
002FA7  3  18           	clc
002FA8  3  69 01        	adc #1
002FAA  3               colc1b:
002FAA  3  C9 10        	cmp #16					; within y range?
002FAC  3  B0 AA        	bcs sktyp1 				; no - they've missed.
002FAE  3  18           	clc					; add x difference.
002FAF  3  65 62        	adc z80_c
002FB1  3  C9 1A        	cmp #26					; only 5 corner pixels touching?
002FB3  3  B0 02        	bcs :+
002FB5  3  38           	sec
002FB6  3  60           	rts 					; carry set if there's a collision.
002FB7  3               :
002FB7  3  4C 58 2F     	jmp sktyp1				; try next sprite in table.
002FBA  3               colty1:
002FBA  3  A5 68        	lda z80_x  				; compare the two.
002FBC  3  C5 66        	cmp z80_l
002FBE  3  D0 09        	bne end_col
002FC0  3  A5 69        	lda z80_i
002FC2  3  C5 67        	cmp z80_h
002FC4  3  D0 03        	bne end_col
002FC6  3  4C 58 2F     	jmp sktyp1 				; addresses are identical.
002FC9  3               end_col:
002FC9  3  4C 7D 2F     	jmp colty0
002FCC  3               
002FCC  3               ;-----------------------------------------------------------
002FCC  3               ; Display number, left aligned
002FCC  3               ;
002FCC  3               ; Input:
002FCC  3               ;  a		= number
002FCC  3               ;
002FCC  3               ; global:	-
002FCC  3               ; local:	a,y,bc,hl,displ0
002FCC  3               ; calls:	num2ch,dmsg3
002FCC  3               ;-----------------------------------------------------------
002FCC  3               
002FCC  3               disply:
002FCC  3  85 61        	sta z80_a
002FCE  3  A9 F4        	lda #<displ0				; display workspace.
002FD0  3  85 62        	sta z80_c
002FD2  3  A9 2F        	lda #>displ0
002FD4  3  85 63        	sta z80_b
002FD6  3  A5 61        	lda z80_a
002FD8  3  20 7A 22     	jsr num2ch				; convert accumulator to string.
002FDB  3               displ1:
002FDB  3  C6 62        	dec z80_c				; back one character.
002FDD  3  D0 02        	bne :+
002FDF  3  C6 63        	dec z80_b
002FE1  3               :
002FE1  3  A0 00        	ldy #0
002FE3  3  B1 62        	lda (z80_bc),y				; fetch digit.
002FE5  3  09 80        	ora #128				; insert end marker.
002FE7  3  91 62        	sta (z80_bc),y				; new value.
002FE9  3               
002FE9  3  A9 F4        	lda #<displ0				; display space.
002FEB  3  85 66        	sta z80_l
002FED  3  A9 2F        	lda #>displ0
002FEF  3  85 67        	sta z80_h
002FF1  3  4C A2 2A     	jmp dmsg3				; display the string.
002FF4  3               
002FF4  3  00 00 00 8D  displ0:	.byte 0,0,0,13+128
002FF8  3               
002FF8  3               ;----------------------------------------------------------------
002FF8  3               ; Initialise screen.
002FF8  3               ;
002FF8  3               ; global:	roomtb,scno
002FF8  3               ; local:	-
002FF8  3               ; calls:	tstcs
002FF8  3               ;----------------------------------------------------------------
002FF8  3               
002FF8  3               initsc:
002FF8  3  AD 10 34     	lda roomtb 			; whereabouts in the map are we?
002FFB  3  20 05 30     	jsr tstsc 			; find displacement.
002FFE  3  C9 FF        	cmp #255 			; is it valid?
003000  3  F0 02        	beq init_end 			; no, it's rubbish.
003002  3  85 rr        	sta scno			; store new room number.
003004  3               init_end:
003004  3  60           	rts
003005  3               
003005  3               ;----------------------------------------------------------------
003005  3               ; Test screen.
003005  3               ;
003005  3               ; global:	-
003005  3               ; local:	x
003005  3               ; calls:	-
003005  3               ;----------------------------------------------------------------
003005  3               
003005  3               tstsc:
003005  3  85 rr        	sta tmproom
003007  3  18           	clc
003008  3  69 03        	adc #MAPWID 			; add width in case we"re negative.
00300A  3  AA           	tax 				; add displacement to map data.
00300B  3  BD 3B 34     	lda mapdat-MAPWID,x 		; find room number there.
00300E  3  60           	rts
00300F  3               
00300F  3               ;tmproom:	.byte 0
00300F  3               
00300F  3               ;--------------------------
00300F  3               ; Screen left.
00300F  3               ;--------------------------
00300F  3               
00300F  3               scrl:
00300F  3  AD 10 34     	lda roomtb 			; present room table pointer.
003012  3  38           	sec
003013  3  E9 01        	sbc #1				; room left.
003015  3               scrl0:
003015  3  20 05 30     	jsr tstsc			; test screen.
003018  3  C9 FF        	cmp #255			; is there a screen this way?
00301A  3  D0 01        	bne :+
00301C  3  60           	rts				; no, return to loop.
00301D  3               :
00301D  3  A5 rr        	lda tmproom			; restore room displacement.
00301F  3  8D 10 34     	sta roomtb			; new room table position.
003022  3               scrl1:
003022  3  20 F8 2F     	jsr initsc 			; set new screen.
003025  3  A9 02        	lda #2
003027  3  85 rr        	sta restfl 			; set it.
003029  3  60           	rts
00302A  3               scrr:
00302A  3  AD 10 34     	lda roomtb 			; room table pointer.
00302D  3  18           	clc
00302E  3  69 01        	adc #1				; room right.
003030  3  4C 15 30     	jmp scrl0
003033  3               scru:
003033  3  AD 10 34     	lda roomtb 			; room table pointer.
003036  3  38           	sec
003037  3  E9 03        	sbc #MAPWID 			; room up.
003039  3  4C 15 30     	jmp scrl0
00303C  3               scrd:
00303C  3  AD 10 34     	lda roomtb 			; room table pointer.
00303F  3  18           	clc
003040  3  69 03        	adc #MAPWID 			; room down.
003042  3  4C 15 30     	jmp scrl0
003045  3               
003045  3               ;-----------------------------------------
003045  3               ; Jump to new screen.
003045  3               ;-----------------------------------------
003045  3               
003045  3               nwscr:
003045  3  A2 00        	ldx #0				; start of map data.
003047  3               nwscr0:
003047  3  DD 3E 34     	cmp mapdat,x
00304A  3  F0 06        	beq nwscr1			; have we found a match for screen?
00304C  3  E8           	inx 				; next room.
00304D  3  E0 50        	cpx #80				; zero room count, 80 to search.
00304F  3  D0 F6        	bne nwscr0			; keep looking.
003051  3  60           	rts
003052  3               nwscr1:
003052  3  8E 10 34     	stx roomtb			; set the map position.
003055  3  4C 22 30     	jmp scrl1			; draw new room.
003058  3               
003058  3               
003058  3               ;----------------------------------------------------------
003058  3               ; Gravity processing.
003058  3               ;----------------------------------------------------------
003058  3               
003058  3               grav:
003058  3  A0 0D        	ldy #13
00305A  3  B1 68        	lda (z80_ix),y			; jump pointer low.
00305C  3  85 66        	sta z80_l
00305E  3  A0 0E        	ldy #14
003060  3  B1 68        	lda (z80_ix),y			; jump pointer high.
003062  3  85 67        	sta z80_h
003064  3  05 66        	ora z80_l			; merge in low byte.
003066  3  D0 01        	bne :+
003068  3  60           	rts				; if neither is set, we're not in the air.
003069  3               :
003069  3  A0 00        	ldy #0
00306B  3  B1 66        	lda (z80_hl),y			; pixels to move.
00306D  3  85 61        	sta z80_a
00306F  3  C9 63        	cmp #99				; reached the end?
003071  3  D0 0C        	bne grav0			; no, continue.
003073  3               grav2:
003073  3  C6 66        	dec z80_l			; go back to previous value.
003075  3  C9 FF        	cmp #$ff
003077  3  D0 02        	bne :+
003079  3  C6 67        	dec z80_h
00307B  3               :
00307B  3  B1 66        	lda (z80_hl),y			; fetch that from table.
00307D  3  85 61        	sta z80_a
00307F  3               grav0:
00307F  3  E6 66        	inc z80_l			; point to next table entry.
003081  3  D0 02        	bne :+
003083  3  E6 67        	inc z80_h
003085  3               :
003085  3  A5 66        	lda z80_l
003087  3  A0 0D        	ldy #13
003089  3  91 68        	sta (z80_ix),y			; store new pointer low.
00308B  3  A5 67        	lda z80_h
00308D  3  A0 0E        	ldy #14
00308F  3  91 68        	sta (z80_ix),y			; store new pointer high.
003091  3               grav1:
003091  3  A5 61        	lda z80_a
003093  3  D0 01        	bne :+				; any movement required?
003095  3  60           	rts				; no, not this time.
003096  3               :
003096  3  A5 61        	lda z80_a
003098  3  C9 80        	cmp #128			; is it up or down?
00309A  3  B0 15        	bcs gravu			; it's up.
00309C  3               gravd:
00309C  3  85 63        	sta z80_b			; set pixels to move.
00309E  3               gravd0:
00309E  3  20 CA 26     	jsr cangd			; can we go down?
0030A1  3  D0 28        	bne gravst			; can't move down, so stop.
0030A3  3  A0 08        	ldy #8
0030A5  3  B1 68        	lda (z80_ix),y			; adjust new x coord.
0030A7  3  18           	clc
0030A8  3  69 01        	adc #1
0030AA  3  91 68        	sta (z80_ix),y
0030AC  3  C6 63        	dec z80_b
0030AE  3  D0 EE        	bne gravd0
0030B0  3  60           	rts
0030B1  3               gravu:
0030B1  3  49 FF        	eor #$ff			; flip the sign so it's positive.
0030B3  3  18           	clc
0030B4  3  69 01        	adc #1
0030B6  3  85 63        	sta z80_b			; set pixels to move.
0030B8  3               gravu0:
0030B8  3  20 95 26     	jsr cangu			; can we go up?
0030BB  3  D0 6E        	bne ifalls			; can't move up, go down next.
0030BD  3  A0 08        	ldy #8
0030BF  3  B1 68        	lda (z80_ix),y
0030C1  3  38           	sec
0030C2  3  E9 01        	sbc #1
0030C4  3  91 68        	sta (z80_ix),y			; adjust new x coord.
0030C6  3  C6 63        	dec z80_b
0030C8  3  D0 EE        	bne gravu0
0030CA  3  60           	rts
0030CB  3               gravst:
0030CB  3  A0 0D        	ldy #13
0030CD  3  B1 68        	lda (z80_ix),y			; jump pointer low.
0030CF  3  85 66        	sta z80_l
0030D1  3  A0 0E        	ldy #14
0030D3  3  B1 68        	lda (z80_ix),y			; jump pointer high.
0030D5  3  85 67        	sta z80_h
0030D7  3               
0030D7  3  A9 00        	lda #0				; null value in pointer.
0030D9  3  A0 0D        	ldy #13
0030DB  3  91 68        	sta (z80_ix),y			; store new pointer low.
0030DD  3  C8           	iny
0030DE  3  91 68        	sta (z80_ix),y			; store new pointer high.
0030E0  3               
0030E0  3  A0 00        	ldy #0
0030E2  3  B1 66        	lda (z80_hl),y			; fetch byte from table.
0030E4  3  C9 63        	cmp #99				; is it the end marker?
0030E6  3               evftf:
0030E6  3  F0 01        	beq :+				; yes, fallen too far.
0030E8  3  60           	rts
0030E9  3               :
0030E9  3  4C B7 34     	jmp evnt15			; EVENT FELLTOOFAR
0030EC  3               
0030EC  3               ;------------------------------------------------
0030EC  3               ; Initiate fall check.
0030EC  3               ;------------------------------------------------
0030EC  3               
0030EC  3               ifall:
0030EC  3  A0 0D        	ldy #13
0030EE  3  B1 68        	lda (z80_ix),y 			; jump pointer low.
0030F0  3  85 66        	sta z80_l
0030F2  3  A0 0E        	ldy #14
0030F4  3  B1 68        	lda (z80_ix),y 			; jump pointer high.
0030F6  3  85 67        	sta z80_h			; high byte in accumulator.
0030F8  3  05 66        	ora z80_l			; merge in low byte.
0030FA  3  F0 01        	beq :+
0030FC  3  60           	rts				; if either is set, we're already in the air.
0030FD  3               :
0030FD  3  A0 09        	ldy #9
0030FF  3  B1 68        	lda (z80_ix),y			; y coordinate.
003101  3  85 rr        	sta dispx
003103  3  A0 08        	ldy #8
003105  3  B1 68        	lda (z80_ix),y			; look x coordinate.
003107  3  18           	clc
003108  3               numsp7:
003108  3  69 10        	adc #SPR_HGT			; add 16 pixels.
00310A  3  85 rr        	sta dispy			; set up test coordinates.
00310C  3  20 3F 29     	jsr tstbl			; get map address.
00310F  3  20 6C 28     	jsr plchk			; block, platform check.
003112  3  F0 01        	beq :+
003114  3  60           	rts				; it's solid, don't fall.
003115  3               :
003115  3  E6 rr        	inc bufaddr			; look right one cell.
003117  3  20 6C 28     	jsr plchk			; block, platform check.
00311A  3  F0 01        	beq :+
00311C  3  60           	rts				; it's solid, don't fall.
00311D  3               :
00311D  3  A5 rr        	lda dispx			; y coordinate.
00311F  3  29 07        	and #7				; position straddling block cells.
003121  3  F0 08        	beq ifalls			; no more checks needed.
003123  3  E6 rr        	inc bufaddr			; look to third cell.
003125  3  20 6C 28     	jsr plchk			; block, platform check.
003128  3  F0 01        	beq :+
00312A  3  60           	rts				; it's solid, don't fall.
00312B  3               :
00312B  3               ifalls:
00312B  3  A9 B0        	lda #<jtab			; jump table start.
00312D  3  85 66        	sta z80_l
00312F  3  A9 38        	lda #>jtab
003131  3  85 67        	sta z80_h
003133  3               ifal0:
003133  3  E6 66        	inc z80_l			; point to next value.
003135  3  D0 02        	bne :+
003137  3  E6 67        	inc z80_h
003139  3               :
003139  3  A0 00        	ldy #0
00313B  3  B1 66        	lda (z80_hl),y			; fetch value.
00313D  3  F0 F4        	beq ifal0			; no, get next value.
00313F  3  C9 63        	cmp #99				; reached end of table?
003141  3  D0 01        	bne :+
003143  3  60           	rts				; yes, don't fall.
003144  3               :
003144  3  C9 80        	cmp #128			; is it going up?
003146  3  B0 EB        	bcs ifal0			; yes, looking for first movement down.
003148  3               
003148  3  A0 0D        	ldy #13
00314A  3  A5 66        	lda z80_l
00314C  3  91 68        	sta (z80_ix),y 			; set jump low.
00314E  3  A0 0E        	ldy #14
003150  3  A5 67        	lda z80_h
003152  3  91 68        	sta (z80_ix),y 			; set jump high.
003154  3  60           	rts
003155  3               
003155  3               
003155  3               ;----------------------------------------------------
003155  3               ; Get frame data for a particular sprite.
003155  3               ; Input:
003155  3               ;  a		= framenumer
003155  3               ; Output:
003155  3               ;  hl		= frame address
003155  3               ;
003155  3               ; global:	hl,frmptr
003155  3               ; local:	-
003155  3               ; calls:	-
003155  3               ;----------------------------------------------------
003155  3               
003155  3               gfrm:
003155  3  0A           	asl a	 		 	; multiple of 2.
003156  3  18           	clc
003157  3  6D 3D 20     	adc frmptr 			; frames used by game.
00315A  3  85 66        	sta z80_l
00315C  3  AD 3E 20     	lda frmptr+1
00315F  3  69 00        	adc #0
003161  3  85 67        	sta z80_h 			; point to frame start.
003163  3  60           	rts
003164  3               
003164  3               ;----------------------------------------------------
003164  3               ; Find sprite list for current room.
003164  3               ;
003164  3               ; global:	hl
003164  3               ; local:	x,y
003164  3               ; calls:	-
003164  3               ;----------------------------------------------------
003164  3               
003164  3               sprlst:
003164  3  A9 85        	lda #<nmedat 			; list of enemy sprites.
003166  3  85 66        	sta z80_l
003168  3  A9 35        	lda #>nmedat
00316A  3  85 67        	sta z80_h
00316C  3  A6 rr        	ldx scno 			; screen number.
00316E  3  D0 01        	bne sprls2 			; is it the first screen?
003170  3  60           	rts 				; yes, don't need to search data.
003171  3               sprls2:
003171  3  A0 00        	ldy #0
003173  3               sprls1:
003173  3  B1 66        	lda (z80_hl),y 			; fetch type of sprite.
003175  3  C9 FF        	cmp #255			; is it an end marker?
003177  3  F0 0E        	beq sprls0 			; yes, end of this room.
003179  3               
003179  3  18           	clc 				; point to next sprite in list.
00317A  3  A5 66        	lda z80_l
00317C  3  69 04        	adc #NMESIZ
00317E  3  85 66        	sta z80_l
003180  3  90 02        	bcc :+
003182  3  E6 67        	inc z80_h
003184  3               :
003184  3  4C 73 31     	jmp sprls1 			; continue until end of room.
003187  3               sprls0:
003187  3  E6 66        	inc z80_l 			; point to start of next screen.s
003189  3  D0 02        	bne :+
00318B  3  E6 67        	inc z80_h
00318D  3               :
00318D  3  CA           	dex
00318E  3  D0 E3        	bne sprls1 			; continue until room found.
003190  3  60           	rts
003191  3               
003191  3               
003191  3               ;----------------------------------------------------
003191  3               ; Clear all but a single player sprite.
003191  3               ;
003191  3               ; global:	-
003191  3               ; local:	x,y,ix
003191  3               ; calls:	-
003191  3               ;----------------------------------------------------
003191  3               
003191  3               nspr:
003191  3  A9 0C        	lda #NUMSPR			; sprite slots in table.
003193  3  85 rr        	sta sprcnt
003195  3  A9 33        	lda #<sprtab 			; sprite table.
003197  3  85 68        	sta z80_x
003199  3  A9 33        	lda #>sprtab
00319B  3  85 69        	sta z80_i
00319D  3               nspr0:
00319D  3  A0 00        	ldy #0 				; fetch sprite type.
00319F  3  B1 68        	lda (z80_ix),y 			; is it a player?
0031A1  3  F0 1A        	beq nspr1 			; yes, keep this one.
0031A3  3               
0031A3  3  A9 FF        	lda #255
0031A5  3  A0 00        	ldy #0 				; fetch sprite type.
0031A7  3  91 68        	sta (z80_ix),y 			; delete sprite.
0031A9  3  A0 05        	ldy #5
0031AB  3  91 68        	sta (z80_ix),y 			; remove next type.
0031AD  3               
0031AD  3  18           	clc	 			; next sprite.
0031AE  3  A5 68        	lda z80_x
0031B0  3  69 11        	adc #TABSIZ 			; distance to next odd/even entry.
0031B2  3  85 68        	sta z80_x
0031B4  3  90 02        	bcc :+
0031B6  3  E6 69        	inc z80_i
0031B8  3               :
0031B8  3  C6 rr        	dec sprcnt	 			; one less space in the table.
0031BA  3  D0 E1        	bne nspr0
0031BC  3  60           	rts
0031BD  3               nspr1:
0031BD  3  A9 FF        	lda #255
0031BF  3  A0 00        	ldy #0
0031C1  3  91 68        	sta (z80_ix),y 			; delete sprite.
0031C3  3               
0031C3  3  18           	clc	 			; point to next sprite.
0031C4  3  A5 68        	lda z80_x
0031C6  3  69 11        	adc #TABSIZ 			; distance to next odd/even entry.
0031C8  3  85 68        	sta z80_x
0031CA  3  90 02        	bcc :+
0031CC  3  E6 69        	inc z80_i
0031CE  3               :
0031CE  3  C6 rr        	dec sprcnt	 			; one less to do.
0031D0  3  D0 01        	bne nspr2
0031D2  3  60           	rts
0031D3  3               nspr2:
0031D3  3  A9 FF        	lda #255
0031D5  3  A0 00        	ldy #0
0031D7  3  91 68        	sta (z80_ix),y 			; delete sprite.
0031D9  3  A0 05        	ldy #5
0031DB  3  91 68        	sta (z80_ix),y 			; remove next type.
0031DD  3               
0031DD  3  18           	clc	 			; next sprite.
0031DE  3  A5 68        	lda z80_x
0031E0  3  69 11        	adc #TABSIZ 			; distance to next odd/even entry.
0031E2  3  85 68        	sta z80_x
0031E4  3  90 02        	bcc :+
0031E6  3  E6 69        	inc z80_i
0031E8  3               :
0031E8  3  C6 rr        	dec sprcnt	 			; one less space in table.
0031EA  3  D0 E7        	bne nspr2
0031EC  3  60           	rts
0031ED  3               
0031ED  3               ;----------------------------------------------------------
0031ED  3               ; Two initialisation routines.
0031ED  3               ; Initialise sprites - copy everything from list to table.
0031ED  3               ;
0031ED  3               ; global:	-
0031ED  3               ; local:	x,y,ix
0031ED  3               ; calls:	cpsp
0031ED  3               ;----------------------------------------------------------
0031ED  3               
0031ED  3               ispr:
0031ED  3  A9 0C        	lda #NUMSPR			; sprite slots in table.
0031EF  3  85 rr        	sta sprcnt
0031F1  3  A9 33        	lda #<sprtab			; sprite table.
0031F3  3  85 68        	sta z80_x
0031F5  3  A9 33        	lda #>sprtab
0031F7  3  85 69        	sta z80_i
0031F9  3               ispr2:
0031F9  3  A0 00        	ldy #0
0031FB  3  B1 66        	lda (z80_hl),y 			; fetch byte.
0031FD  3  C9 FF        	cmp #255 			; is it an end marker?
0031FF  3  D0 01        	bne :+
003201  3  60           	rts 				; yes, no more to do.
003202  3               :
003202  3               ispr1:
003202  3  A0 00        	ldy #0
003204  3  B1 68        	lda (z80_ix),y 			; fetch sprite type.
003206  3  C9 FF        	cmp #255 			; is it enabled yet?
003208  3  D0 08        	bne ispr4			; yes, try another slot.
00320A  3               
00320A  3  A0 05        	ldy #5
00320C  3  B1 68        	lda (z80_ix),y		 	; next type.
00320E  3  C9 FF        	cmp #255 			; is it enabled yet?
003210  3  F0 10        	beq ispr3 			; no, process this one.
003212  3               ispr4:
003212  3  18           	clc 				; next sprite.
003213  3  A5 68        	lda z80_x
003215  3  69 11        	adc #TABSIZ		 	; distance to next odd/even entry.
003217  3  85 68        	sta z80_x
003219  3  90 02        	bcc :+
00321B  3  E6 69        	inc z80_i
00321D  3               :
00321D  3  C6 rr        	dec sprcnt
00321F  3  D0 E1        	bne ispr1 			; repeat for remaining sprites.
003221  3  60           	rts  				; no more room in table.
003222  3               ispr3:
003222  3  20 75 32     	jsr cpsp			; initialise a sprite.
003225  3  C6 rr        	dec sprcnt			; one less space in the table.
003227  3  D0 D0        	bne ispr2
003229  3  60           	rts
00322A  3               
00322A  3               
00322A  3               ;-----------------------------------------------------------------------
00322A  3               ; Initialise sprites - but not player, we're keeping the old one.
00322A  3               ;
00322A  3               ; global:	-
00322A  3               ; local:	x,y,ix
00322A  3               ; calls:	cpsp
00322A  3               ;-----------------------------------------------------------------------
00322A  3               
00322A  3               kspr:
00322A  3  A2 0C        	ldx #NUMSPR			; sprite slots in table.
00322C  3  A9 33        	lda #<sprtab 			; sprite table.
00322E  3  85 68        	sta z80_x
003230  3  A9 33        	lda #>sprtab
003232  3  85 69        	sta z80_i
003234  3               kspr2:
003234  3  A0 00        	ldy #0
003236  3  B1 66        	lda (z80_hl),y 			; fetch byte.
003238  3  C9 FF        	cmp #255 			; is it an end marker?
00323A  3  D0 01        	bne :+
00323C  3  60           	rts 				; yes, no more to do.
00323D  3               :
00323D  3  C9 00        	cmp #0
00323F  3  D0 0E        	bne kspr1 			; no, add to table as normal.
003241  3               
003241  3  18           	clc 				; next sprite.
003242  3  A5 66        	lda z80_l
003244  3  69 04        	adc #NMESIZ		 	; distance to next odd/even entry.
003246  3  85 66        	sta z80_l
003248  3  90 02        	bcc :+
00324A  3  E6 67        	inc z80_h
00324C  3               :
00324C  3  4C 34 32     	jmp kspr2
00324F  3               kspr1:
00324F  3  A0 00        	ldy #0 				; fetch sprite type.
003251  3  B1 68        	lda (z80_ix),y
003253  3  C9 FF        	cmp #255 			; is it enabled yet?
003255  3  D0 08        	bne kspr4 			; yes, try another slot.
003257  3               
003257  3  A0 05        	ldy #5 				; next type.
003259  3  B1 68        	lda (z80_ix),y
00325B  3  C9 FF        	cmp #255 			; is it enabled yet?
00325D  3  F0 0F        	beq kspr3 			; no, process this one.
00325F  3               kspr4:
00325F  3  18           	clc 				; next sprite.
003260  3  A5 68        	lda z80_x
003262  3  69 11        	adc #TABSIZ		 	; distance to next odd/even entry.
003264  3  85 68        	sta z80_x
003266  3  90 02        	bcc :+
003268  3  E6 69        	inc z80_i
00326A  3               :
00326A  3  CA           	dex	 			; repeat for remaining sprites.
00326B  3  D0 E2        	bne kspr1
00326D  3  60           	rts  				; no more room in table.
00326E  3               kspr3:
00326E  3  20 75 32     	jsr cpsp 			; copy sprite to table.
003271  3  CA           	dex	 			; one less space in the table.
003272  3  D0 C0        	bne kspr2
003274  3  60           	rts
003275  3               
003275  3               ;----------------------------------------------
003275  3               ; Copy sprite from list to table.
003275  3               ;
003275  3               ; global:	hl,ix
003275  3               ; local:	y
003275  3               ; calls:	evnt09
003275  3               ;----------------------------------------------
003275  3               
003275  3               cpsp:
003275  3  A0 00        	ldy #0				; fetch byte from table.
003277  3  B1 66        	lda (z80_hl),y
003279  3  91 68        	sta (z80_ix),y			; set up type.
00327B  3  A0 05        	ldy #PAM1ST
00327D  3  91 68        	sta (z80_ix),y 			; set up type.
00327F  3               
00327F  3  E6 66        	inc z80_l 			; move to next byte.
003281  3  D0 02        	bne :+
003283  3  E6 67        	inc z80_h
003285  3               :
003285  3  A0 00        	ldy #0 				; fetch byte from table.
003287  3  B1 66        	lda (z80_hl),y
003289  3  A0 06        	ldy #6
00328B  3  91 68        	sta (z80_ix),y			; set up image.
00328D  3               
00328D  3  E6 66        	inc z80_l 			; move to next byte.
00328F  3  D0 02        	bne :+
003291  3  E6 67        	inc z80_h
003293  3               :
003293  3  A0 00        	ldy #0
003295  3  B1 66        	lda (z80_hl),y 			; fetch byte from table.
003297  3  A0 08        	ldy #8
003299  3  91 68        	sta (z80_ix),y 			; set up coordinate.
00329B  3               
00329B  3  A9 C8        	lda #200 			; set initial coordinate off screen.
00329D  3  A0 03        	ldy #3
00329F  3  91 68        	sta (z80_ix),y
0032A1  3               
0032A1  3  E6 66        	inc z80_l 			; move to next byte.
0032A3  3  D0 02        	bne :+
0032A5  3  E6 67        	inc z80_h
0032A7  3               :
0032A7  3  A0 00        	ldy #0 				; fetch byte from table.
0032A9  3  B1 66        	lda (z80_hl),y
0032AB  3  A0 09        	ldy #9
0032AD  3  91 68        	sta (z80_ix),y 			; set up coordinate.
0032AF  3               
0032AF  3  E6 66        	inc z80_l 			; move to next byte.
0032B1  3  D0 02        	bne :+
0032B3  3  E6 67        	inc z80_h
0032B5  3               :
0032B5  3  A9 00        	lda #0				; zeroes in accumulator.
0032B7  3  A0 07        	ldy #7 				; reset frame number.
0032B9  3  91 68        	sta (z80_ix),y
0032BB  3  A0 0A        	ldy #10 			; reset direction.
0032BD  3  91 68        	sta (z80_ix),y
0032BF  3  A0 0D        	ldy #13				; reset jump pointer low.
0032C1  3  91 68        	sta (z80_ix),y
0032C3  3  A0 0E        	ldy #14	 			; reset jump pointer high.
0032C5  3  91 68        	sta (z80_ix),y
0032C7  3               
0032C7  3  A9 FF        	lda #255 			; reset data pointer to auto-restore.
0032C9  3  A0 10        	ldy #16
0032CB  3  91 68        	sta (z80_ix),y
0032CD  3               evis0:
0032CD  3  A5 69        	lda z80_i
0032CF  3  48           	pha
0032D0  3  A5 68        	lda z80_x
0032D2  3  48           	pha
0032D3  3  A5 67        	lda z80_h
0032D5  3  48           	pha
0032D6  3  A5 66        	lda z80_l
0032D8  3  48           	pha
0032D9  3               
0032D9  3  20 4E 34     	jsr evnt09 			; perform event.
0032DC  3               
0032DC  3  68           	pla
0032DD  3  85 66        	sta z80_l
0032DF  3  68           	pla
0032E0  3  85 67        	sta z80_h
0032E2  3  68           	pla
0032E3  3  85 68        	sta z80_x
0032E5  3  68           	pla
0032E6  3  85 69        	sta z80_i
0032E8  3               
0032E8  3  18           	clc
0032E9  3  A5 68        	lda z80_x 			; distance to next odd/even entry.
0032EB  3  69 11        	adc #TABSIZ		 	; next sprite.
0032ED  3  85 68        	sta z80_x
0032EF  3  90 02        	bcc :+
0032F1  3  E6 69        	inc z80_i
0032F3  3               :
0032F3  3  60           	rts
0032F4  3               
0032F4  3               
0032F4  3               ;-------------------------------------
0032F4  3               ; Clear the play area window.
0032F4  3               ;-------------------------------------
0032F4  3               
0032F4  3               clw:
0032F4  3  AD 49 20     	lda wintop			; get coordinates of window.
0032F7  3  85 rr        	sta dispy			; put into dispx for calculation.
0032F9  3  AD 4A 20     	lda winlft
0032FC  3  85 rr        	sta dispx
0032FE  3               
0032FE  3  AD 4B 20     	lda winhgt			; height of window.
003301  3  85 rr        	sta rrow			; copy to b register.
003303  3               clw3:
003303  3  AD 4C 20     	lda winwid 			; width of window.
003306  3  85 rr        	sta rcol
003308  3               clw2:
003308  3  20 11 25     	jsr gprad 			; get print address.
00330B  3  A9 00        	lda #0				; zero byte to write.
00330D  3  A2 07        	ldx #7				; pixel height of each cell.
00330F  3               clw1:
00330F  3  BC 97 25     	ldy scrtab,x
003312  3  91 rr        	sta (scraddr),y 			; copy to screen.
003314  3  CA           	dex				; next screen row down.
003315  3  10 F8        	bpl clw1
003317  3               
003317  3  E6 rr        	inc dispx			; next column.
003319  3  C6 rr        	dec rcol			; one less to do.
00331B  3  D0 EB        	bne clw2			; repeat for remaining columns.
00331D  3               
00331D  3  AD 4A 20     	lda winlft			; get left edge.
003320  3  85 rr        	sta dispx 			; reset x.
003322  3  E6 rr        	inc dispy 			; next line down.
003324  3               
003324  3  C6 rr        	dec rrow
003326  3  D0 DB        	bne clw3			; repeat down the screen.
003328  3               
003328  3  AD 49 20     	lda wintop			; get coordinates of window.
00332B  3  85 rr        	sta chary			; put into display position.
00332D  3  AD 4A 20     	lda winlft
003330  3  85 rr        	sta charx
003332  3  60           	rts
003333  3               
003333  3               
003333  3               ;----------------------------------------------------------
003333  3               ; Effects code.
003333  3               ; Ticker routine is called 25 times per second.
003333  3               ;
003333  3               ; HL = txtscr = left text screen address
003333  3               ; DE = txtscr+txtwid-1 = right text screen address
003333  3               ; BC = txtpos = text scroller position
003333  3               ;
003333  3               ;----------------------------------------------------------
003333  3               
003333  3               .if sflag
003333  3               scrly:
003333  3               	rts
003333  3               	.word txtscr         	; get left screen address.
003333  3               	sta scr_l
003333  3               	lda txtscr+1
003333  3               	sta scr_l+1
003333  3               	sta scr_r+1
003333  3               
003333  3               	stx xtmp
003333  3               
003333  3               	clc         		; get right screen address.
003333  3               	lda scr_l
003333  3               	adc txtwid
003333  3               	sta scr_r
003333  3               	dec scr_r
003333  3               scrly1:
003333  3               	ldy txtwid		; set txtwide
003333  3               	dey
003333  3               	clc
003333  3               scrly0:
003333  3               	lda (scr_l),y		; scroll 1 line
003333  3               	rol a
003333  3               	sta (scr_l),y
003333  3               	dey
003333  3               	bpl scrly0
003333  3               
003333  3               	clc			; point to next line
003333  3               	lda scr_l
003333  3               	adc #32
003333  3               	sta scr_l
003333  3               	bcc scrly1		; repeat 8 times
003333  3               
003333  3               	lda txtpos 		; get text pointer.
003333  3               	sta scr_txt
003333  3               	lda txtpos+1
003333  3               	sta scr_txt+1
003333  3               
003333  3               	ldy #0
003333  3               	lda (scr_txt),y 		; find character we're displaying.
003333  3               	and #127 		; remove end marker bit if applicable.
003333  3               	cmp #13			; is it newline?
003333  3               	bne scrly5 		; no, it's okay.
003333  3               	lda #32			; convert to a space instead.
003333  3               scrly5:
003333  3               	sta fntaddr		; calculate char address
003333  3               	lda #0
003333  3               	sta fntaddr+1
003333  3               	asl fntaddr  		; multiply char by 8.
003333  3               	rol fntaddr+1
003333  3               	asl fntaddr
003333  3               	rol fntaddr+1
003333  3               	asl fntaddr
003333  3               	rol fntaddr+1
003333  3               	lda fntaddr
003333  3               	clc
003333  3               	adc #<(FONT-256)
003333  3               	sta scrly3+1		; that's the low byte.
003333  3               	lda fntaddr+1
003333  3               	adc #>(FONT-256)
003333  3               	sta scrly3+2		; add displacement.
003333  3               
003333  3               	ldx #0
003333  3               scrly3:
003333  3               	lda $3333,x		; get image of char line.
003333  3               	and txtbit
003333  3               	beq scrly2		; don't plot pixel
003333  3               	ldy scrline,x
003333  3               	lda (scr_r),y
003333  3               	clc
003333  3               	ora #1
003333  3               	sta (scr_r),y		; plot pixel
003333  3               scrly2:
003333  3               	inx			; next line of char.
003333  3               	cpx #8
003333  3               	bne scrly3
003333  3               
003333  3               	lsr txtbit		; bit of text to display.
003333  3               	bcs :+
003333  3               	rts
003333  3               :
003333  3               	ldy #0
003333  3               	lda (scr_txt),y 	; what was the character?
003333  3               	asl a	  		; end of message?
003333  3               	bcs scrly4
003333  3               	inc txtpos
003333  3               	bne :+
003333  3               	inc txtpos+1
003333  3               :
003333  3               	jmp scrly6 		; not yet - continue.
003333  3               scrly4:
003333  3               	lda txtini 		; start of scrolling message.
003333  3               	sta txtpos
003333  3               	lda txtini+1
003333  3               	sta txtpos+1
003333  3               scrly6:
003333  3               	lda #128
003333  3               	sta txtbit
003333  3               	ldx xtmp
003333  3               	rts
003333  3               
003333  3               scrline:	.byte $00,$20,$40,$60,$80,$a0,$c0,$e0
003333  3               
003333  3               ;-------------------------------------------------------
003333  3               ; Entry TICKER command
003333  3               ;
003333  3               ; Entry:
003333  3               ;  z80_b = message nr
003333  3               ;  z80_c = width
003333  3               ;-------------------------------------------------------
003333  3               
003333  3               iscrly:
003333  3               	jsr prescr 		; set up display position.
003333  3               
003333  3               	lda #<msgdat 		; text messages.
003333  3               	sta z80_l
003333  3               	lda #>msgdat
003333  3               	sta z80_h
003333  3               
003333  3               	lda z80_c 		; width.
003333  3               	sec
003333  3               	sbc #1			; subtract one.
003333  3               	cmp #32 		; is it between 1 and 32?
003333  3               	bcc :+
003333  3               	lda #$60
003333  3               	jmp iscrl0		; no, disable messages.
003333  3               :
003333  3               	ldx z80_b		; message number.
003333  3               	jsr getwrd 		; find message start.
003333  3               
003333  3               	lda z80_l		; set initial text position.
003333  3               	sta txtini
003333  3               	lda z80_h
003333  3               	sta txtini+1
003333  3               
003333  3               	lda #$ad		; code for lda adrr
003333  3               iscrl0:
003333  3               	sta scrly		; enable/disable scrolling routine.
003333  3               
003333  3               	jsr prescr 		; set up display position.
003333  3               	jsr gprad 		; get print address.
003333  3               
003333  3               	lda scraddr 		; set text screen address.
003333  3               	sta txtscr
003333  3               	lda scraddr+1
003333  3               	sta txtscr+1
003333  3               
003333  3               	lda z80_c		; width.
003333  3               	sta txtwid		; set width in working storage.
003333  3               
003333  3               	lda #128 		; start with leftmost bit.
003333  3               	sta txtbit
003333  3               
003333  3               	jmp scrly4
003333  3               .endif
003333  3               
003333  3               ;------------------------------------------------------------------
003333  3               ; Dig routine, conditional assembly depending on dflag
003333  3               ;------------------------------------------------------------------
003333  3               .if dflag
003333  3               dig:
003333  3               	and #3
003333  3               	beq digr		; dig right
003333  3               	cmp #1
003333  3               	beq digl		; dig left
003333  3               	cmp #2
003333  3               	beq digd		; dig down
003333  3               
003333  3               ; Dig up.
003333  3               
003333  3               digu:				; dig up
003333  3               	ldy #8
003333  3               	lda (z80_ix),y
003333  3               	sec
003333  3               	sbc #2
003333  3               	sta dispy		; set y
003333  3               
003333  3               	iny
003333  3               	lda (z80_ix),y
003333  3               	sta dispx		; set x
003333  3               	jmp digv
003333  3               
003333  3               ; Dig down.
003333  3               
003333  3               digd:
003333  3               	ldy #9
003333  3               	lda (z80_ix),y
003333  3               	sta dispx		; set y
003333  3               
003333  3               	dey
003333  3               	clc
003333  3               	lda (z80_ix),y
003333  3               	adc #16
003333  3               	sta dispy		; set y
003333  3               	jmp digv
003333  3               
003333  3               ; Dig left.
003333  3               
003333  3               digl:
003333  3               	ldy #8
003333  3               	lda (z80_ix),y
003333  3               	sta dispy		; set y
003333  3               
003333  3               	iny
003333  3               	lda (z80_ix),y
003333  3               	sec
003333  3               	sbc #2			; x=x-2
003333  3               	sta dispx		; set x
003333  3               	jmp digh
003333  3               
003333  3               ; Dig right.
003333  3               
003333  3               digr:
003333  3               	ldy #8
003333  3               	lda (z80_ix),y
003333  3               	sta dispy		; set y
003333  3               
003333  3               	iny
003333  3               	lda (z80_ix),y
003333  3               	clc
003333  3               	adc #16
003333  3               	sta dispx		; set x+16
003333  3               	jmp digh
003333  3               
003333  3               ; Vertical digging
003333  3               
003333  3               digv:
003333  3               	jsr tstbl		; check blocktype in MAP
003333  3               	jsr fdchk		; test if FODDER
003333  3               
003333  3               	clc
003333  3               	lda dispx		; look 1 cell down
003333  3               	adc #8
003333  3               	sta dispx
003333  3               	jsr tstbl		; check blocktype in MAP
003333  3               	jsr fdchk
003333  3               	lda dispx
003333  3               	and #7
003333  3               	bne :+
003333  3               	rts
003333  3               :
003333  3               	clc
003333  3               	lda dispx		; look 1 cell down
003333  3               	adc #8
003333  3               	sta dispx
003333  3               	jsr tstbl		; check blocktype in MAP
003333  3               	jmp fdchk
003333  3               
003333  3               ; Horizontal digging
003333  3               
003333  3               digh:
003333  3               	jsr tstbl		; check blocktype in MAP
003333  3               	jsr fdchk		; test if FODDER
003333  3               
003333  3               	clc
003333  3               	lda dispy		; look 1 cell down
003333  3               	adc #8
003333  3               	sta dispy
003333  3               	jsr tstbl		; check blocktype in MAP
003333  3               	jsr fdchk
003333  3               	lda dispy
003333  3               	and #7
003333  3               	bne :+
003333  3               	rts
003333  3               :
003333  3               	clc
003333  3               	lda dispy		; look 1 cell down
003333  3               	adc #8
003333  3               	sta dispy
003333  3               	jsr tstbl		; check blocktype in MAP
003333  3               	jmp fdchk
003333  3               
003333  3               digcnt:	.byte 0
003333  3               
003333  3               .endif
003333  3               
003333  3               ;------------------------------------------------------------------
003333  3               ; Sprite table
003333  3               ;------------------------------------------------------------------
003333  3               
003333  3               
003333  3               ; ix+0  = type.
003333  3               ; ix+1  = sprite image number.
003333  3               ; ix+2  = frame.
003333  3               ; ix+3  = y coord.
003333  3               ; ix+4  = x coord.
003333  3               
003333  3               ; ix+5  = new type.
003333  3               ; ix+6  = new image number.
003333  3               ; ix+7  = new frame.
003333  3               ; ix+8  = new y coord.
003333  3               ; ix+9  = new x coord.
003333  3               
003333  3               ; ix+10 = direction.
003333  3               ; ix+11 = parameter 1.
003333  3               ; ix+12 = parameter 2.
003333  3               ; ix+13 = jump pointer low.
003333  3               ; ix+14 = jump pointer high.
003333  3               ; ix+15 = data pointer low.
003333  3               ; ix+16 = data pointer high.
003333  3               
003333  3               ; block NUMSPR * TABSIZ,255
003333  3               
003333  3  FF FF FF FF  sprtab:	.res NUMSPR*TABSIZ,255
003337  3  FF FF FF FF  
00333B  3  FF FF FF FF  
0033FF  3  FF FF FF FF  ssprit:	.byte 255,255,255,255,255,255,255,0,192,120,0,0,0,255,255,255,255
003403  3  FF FF FF 00  
003407  3  C0 78 00 00  
003410  3  07           roomtb:	.byte 7                      ; start room map offset.
003411  3               
003411  3               ; User routine.  Put your own code in here to be called with USER instruction.
003411  3               ; if USER has an argument it will be passed in the accumulator.
003411  3               
003411  3               user:
003411  3               	.include "user.inc"
003411  4  60           	rts
003412  4               
003412  3               
003412  3               ;----------------------------------------------------
003412  3               ; Missing vars
003412  3               ;----------------------------------------------------
003412  3               
003412  3               MAP 		= $9800			; properties map buffer (3x256 bytes)
003412  3               SCADTB_lb 	= MAP+3*256		; screen address table lo-byte (256 bytes)
003412  3               SCADTB_hb 	= SCADTB_lb+256		; screen address table hi-byte (256 bytes)
003412  3               SHRAPN 		= SCADTB_hb+256		; shrapnel table (55x6 bytes)
003412  3               
003412  3               ;Fontpointer:	.byte 0,0
003412  3               ;TmpAddr:	.byte 0,0
003412  3               
003412  3               ;loopa:		.byte 0
003412  3               ;loopb:		.byte 0
003412  3               ;loopc:		.byte 0
003412  3               
003412  3               setfgcol:
003412  3  29 03        	and #3
003414  3  A8           	tay
003415  3  B9 37 34     	lda codcol,y
003418  3  4C 2E 34     	jmp calfgc
00341B  3               
00341B  3               setbgcol:
00341B  3  29 03        	and #3
00341D  3               calbgc:
00341D  3  A8           	tay
00341E  3  B9 37 34     	lda codcol,y
003421  3  48           	pha
003422  3  AD 35 34     	lda andeor
003425  3  4D 36 34     	eor andeor+1
003428  3  AA           	tax
003429  3  68           	pla
00342A  3  8D 36 34     	sta andeor+1
00342D  3  8A           	txa
00342E  3               calfgc:
00342E  3  4D 36 34     	eor andeor+1
003431  3  8D 35 34     	sta andeor
003434  3               calex1:
003434  3  60           	rts
003435  3               
003435  3  00 00        andeor:	.byte 0,0
003437  3  00 55 AA FF  codcol:	.byte $00,$55,$aa,$ff
00343B  3               
00343B  3               ; Everything below here will be generated by the editors.
00343B  3               
00343B  3               WINDOWTOP = 1
00343B  3               WINDOWLFT = 1
00343B  3               WINDOWHGT = 22
00343B  3               WINDOWWID = 30 ;a
00343B  3               MAPWID = 3
00343B  3  FF FF FF             .byte 255,255,255
00343E  3               mapdat:
00343E  3  FF 00 FF             .byte 255,0,255
003441  3  FF FF FF             .byte 255,255,255
003444  3  01           stmap:  .byte 1
003445  3               
003445  3               evnt00:
003445  3  60                   rts
003446  3               evnt01:
003446  3  60                   rts
003447  3               evnt02:
003447  3  60                   rts
003448  3               evnt03:
003448  3  60                   rts
003449  3               evnt04:
003449  3  60                   rts
00344A  3               evnt05:
00344A  3  60                   rts
00344B  3               evnt06:
00344B  3  60                   rts
00344C  3               evnt07:
00344C  3  60                   rts
00344D  3               evnt08:
00344D  3  60                   rts
00344E  3               evnt09:
00344E  3  60                   rts
00344F  3               evnt10:
00344F  3  A9 00                lda #0		; AT
003451  3  85 rr                sta chary
003453  3  A9 01                lda #1
003455  3  85 rr                sta charx
003457  3  A9 01                lda #1		; PRINTMODE
003459  3  85 rr                sta prtmod
00345B  3  A9 00                lda #0		; PRINT
00345D  3  20 96 2A             jsr dmsg
003460  3  A9 00                lda #0		; PRINTMODE
003462  3  85 rr                sta prtmod
003464  3  A9 03                lda #3		; AT
003466  3  85 rr                sta chary
003468  3  A9 01                lda #1
00346A  3  85 rr                sta charx
00346C  3  A9 01                lda #1		; PRINT
00346E  3  20 96 2A             jsr dmsg
003471  3  A5 rr                lda clock	; DISPLAY
003473  3  20 CC 2F             jsr disply
003476  3  A9 02                lda #2		; PRINT
003478  3  20 96 2A             jsr dmsg
00347B  3  A9 06                lda #6		; AT
00347D  3  85 rr                sta chary
00347F  3  A9 01                lda #1
003481  3  85 rr                sta charx
003483  3  A9 03                lda #3		; PRINT
003485  3  20 96 2A             jsr dmsg
003488  3  A5 rr                lda clock		; DISPLAYCLOCK
00348A  3  85 65                sta z80_d
00348C  3  A9 3C                lda #60
00348E  3  85 64                sta z80_e
003490  3  20 0B 23             jsr idiv
003493  3  48                   pha
003494  3  A5 65                lda z80_d
003496  3  20 CC 2F             jsr disply
003499  3  E6 rr                inc charx
00349B  3  A9 F4                lda #<displ0
00349D  3  85 62                sta z80_c
00349F  3  A9 2F                lda #>displ0
0034A1  3  85 63                sta z80_b
0034A3  3  68                   pla
0034A4  3  20 BD 22             jsr num2dd
0034A7  3  20 DB 2F             jsr displ1
0034AA  3  A9 04                lda #4		; PRINT
0034AC  3  20 96 2A             jsr dmsg
0034AF  3  60                   rts
0034B0  3               evnt11:
0034B0  3  60                   rts
0034B1  3               evnt12:
0034B1  3  20 05 21             jsr cls		; CLS
0034B4  3  60                   rts
0034B5  3               evnt13:
0034B5  3  60                   rts
0034B6  3               evnt14:
0034B6  3  60                   rts
0034B7  3               evnt15:
0034B7  3  60                   rts
0034B8  3               evnt16:
0034B8  3  60                   rts
0034B9  3               evnt17:
0034B9  3  60                   rts
0034BA  3               evnt18:
0034BA  3  60                   rts
0034BB  3               evnt19:
0034BB  3  60                   rts
0034BC  3               evnt20:
0034BC  3  60                   rts
0034BD  3  60           ptcusr: rts
0034BE  3               msgdat:
0034BE  3  43 4C 4F 43          .byte "CLOCK TEST:",160
0034C2  3  4B 20 54 45  
0034C6  3  53 54 3A A0  
0034CA  3  43 55 52 52          .byte "CURRENT CLOCK:",160
0034CE  3  45 4E 54 20  
0034D2  3  43 4C 4F 43  
0034D9  3  20 A0                .byte " ",160
0034DB  3  43 55 52 52          .byte "CURRENT TIME:",160
0034DF  3  45 4E 54 20  
0034E3  3  54 49 4D 45  
0034E9  3  20 A0                .byte " ",160
0034EB  3               nummsg:
0034EB  3  05                   .byte 5
0034EC  3               chgfx:
0034EC  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0
0034F0  3  00 00 00 00  
0034F4  3               bprop:
0034F4  3  00                   .byte 0
0034F5  3               sprgfx:
0034F5  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0034F9  3  00 00 00 00  
0034FD  3  00 00 00 00  
003515  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
003519  3  00 00 00 00  
00351D  3  00 00 00 00  
003535  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
003539  3  00 00 00 00  
00353D  3  00 00 00 00  
003555  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
003559  3  00 00 00 00  
00355D  3  00 00 00 00  
003575  3               
003575  3               frmlst:
003575  3  00 01 01 00          .byte 0,1,1,0
003579  3               scdat:
003579  3  09 00                .word 9
00357B  3  FF 00 00 FF          .byte 255,0,0,255,0,0,255,0,148
00357F  3  00 00 FF 00  
003583  3  94           
003584  3               numsc:
003584  3  01                   .byte 1
003585  3               nmedat:
003585  3  00 00 58 80          .byte 0,0,88,128,255
003589  3  FF           
00358A  3               NUMOBJ = 1
00358A  3               objdta:
00358A  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,160,32,0,160,32
00358E  3  00 00 00 00  
003592  3  00 00 00 00  
0035B0  3               font:
0035B0  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0
0035B4  3  00 00 00 00  
0035B8  3  00 30 30 30          .byte 0,48,48,48,48,0,48,0
0035BC  3  30 00 30 00  
0035C0  3  00 6C 6C 00          .byte 0,108,108,0,0,0,0,0
0035C4  3  00 00 00 00  
0035C8  3  00 6C FE 6C          .byte 0,108,254,108,108,254,108,0
0035CC  3  6C FE 6C 00  
0035D0  3  00 18 7E 78          .byte 0,24,126,120,126,30,126,24
0035D4  3  7E 1E 7E 18  
0035D8  3  00 E6 EC 18          .byte 0,230,236,24,48,110,206,0
0035DC  3  30 6E CE 00  
0035E0  3  00 30 78 30          .byte 0,48,120,48,126,204,126,0
0035E4  3  7E CC 7E 00  
0035E8  3  00 18 30 00          .byte 0,24,48,0,0,0,0,0
0035EC  3  00 00 00 00  
0035F0  3  00 0C 18 18          .byte 0,12,24,24,24,24,12,0
0035F4  3  18 18 0C 00  
0035F8  3  00 60 30 30          .byte 0,96,48,48,48,48,96,0
0035FC  3  30 30 60 00  
003600  3  00 00 3C 18          .byte 0,0,60,24,126,24,60,0
003604  3  7E 18 3C 00  
003608  3  00 00 18 18          .byte 0,0,24,24,126,24,24,0
00360C  3  7E 18 18 00  
003610  3  00 00 00 00          .byte 0,0,0,0,0,24,24,48
003614  3  00 18 18 30  
003618  3  00 00 00 00          .byte 0,0,0,0,126,0,0,0
00361C  3  7E 00 00 00  
003620  3  00 00 00 00          .byte 0,0,0,0,0,56,56,0
003624  3  00 38 38 00  
003628  3  00 00 06 0C          .byte 0,0,6,12,24,48,96,0
00362C  3  18 30 60 00  
003630  3  00 7C CE DE          .byte 0,124,206,222,246,230,124,0
003634  3  F6 E6 7C 00  
003638  3  00 38 78 18          .byte 0,56,120,24,24,24,126,0
00363C  3  18 18 7E 00  
003640  3  00 7C C6 06          .byte 0,124,198,6,124,192,254,0
003644  3  7C C0 FE 00  
003648  3  00 7C C6 1C          .byte 0,124,198,28,6,198,124,0
00364C  3  06 C6 7C 00  
003650  3  00 18 38 78          .byte 0,24,56,120,216,254,24,0
003654  3  D8 FE 18 00  
003658  3  00 FE C0 FC          .byte 0,254,192,252,6,198,124,0
00365C  3  06 C6 7C 00  
003660  3  00 7C C0 FC          .byte 0,124,192,252,198,198,124,0
003664  3  C6 C6 7C 00  
003668  3  00 FE 06 0C          .byte 0,254,6,12,24,48,48,0
00366C  3  18 30 30 00  
003670  3  00 7C C6 7C          .byte 0,124,198,124,198,198,124,0
003674  3  C6 C6 7C 00  
003678  3  00 7C C6 C6          .byte 0,124,198,198,126,6,124,0
00367C  3  7E 06 7C 00  
003680  3  00 00 00 30          .byte 0,0,0,48,0,0,48,0
003684  3  00 00 30 00  
003688  3  00 00 30 00          .byte 0,0,48,0,0,48,48,96
00368C  3  00 30 30 60  
003690  3  00 00 0C 18          .byte 0,0,12,24,48,24,12,0
003694  3  30 18 0C 00  
003698  3  00 00 00 7E          .byte 0,0,0,126,0,126,0,0
00369C  3  00 7E 00 00  
0036A0  3  00 00 30 18          .byte 0,0,48,24,12,24,48,0
0036A4  3  0C 18 30 00  
0036A8  3  00 7C C6 0C          .byte 0,124,198,12,24,0,24,0
0036AC  3  18 00 18 00  
0036B0  3  00 7C DE FE          .byte 0,124,222,254,254,192,124,0
0036B4  3  FE C0 7C 00  
0036B8  3  00 7C C6 C6          .byte 0,124,198,198,254,198,198,0
0036BC  3  FE C6 C6 00  
0036C0  3  00 FC C6 FC          .byte 0,252,198,252,198,198,252,0
0036C4  3  C6 C6 FC 00  
0036C8  3  00 7C C6 C0          .byte 0,124,198,192,192,198,124,0
0036CC  3  C0 C6 7C 00  
0036D0  3  00 F8 CC C6          .byte 0,248,204,198,198,204,248,0
0036D4  3  C6 CC F8 00  
0036D8  3  00 FE C0 FC          .byte 0,254,192,252,192,192,254,0
0036DC  3  C0 C0 FE 00  
0036E0  3  00 FE C0 FC          .byte 0,254,192,252,192,192,192,0
0036E4  3  C0 C0 C0 00  
0036E8  3  00 7C C6 C0          .byte 0,124,198,192,222,198,124,0
0036EC  3  DE C6 7C 00  
0036F0  3  00 C6 C6 FE          .byte 0,198,198,254,198,198,198,0
0036F4  3  C6 C6 C6 00  
0036F8  3  00 7E 18 18          .byte 0,126,24,24,24,24,126,0
0036FC  3  18 18 7E 00  
003700  3  00 06 06 06          .byte 0,6,6,6,198,198,124,0
003704  3  C6 C6 7C 00  
003708  3  00 CC D8 F0          .byte 0,204,216,240,216,204,198,0
00370C  3  D8 CC C6 00  
003710  3  00 C0 C0 C0          .byte 0,192,192,192,192,192,254,0
003714  3  C0 C0 FE 00  
003718  3  00 C6 EE FE          .byte 0,198,238,254,198,198,198,0
00371C  3  C6 C6 C6 00  
003720  3  00 C6 E6 F6          .byte 0,198,230,246,222,206,198,0
003724  3  DE CE C6 00  
003728  3  00 7C C6 C6          .byte 0,124,198,198,198,198,124,0
00372C  3  C6 C6 7C 00  
003730  3  00 FC C6 C6          .byte 0,252,198,198,252,192,192,0
003734  3  FC C0 C0 00  
003738  3  00 7C C6 C6          .byte 0,124,198,198,246,222,124,0
00373C  3  F6 DE 7C 00  
003740  3  00 FC C6 C6          .byte 0,252,198,198,252,204,198,0
003744  3  FC CC C6 00  
003748  3  00 7C C0 7C          .byte 0,124,192,124,6,198,124,0
00374C  3  06 C6 7C 00  
003750  3  00 FE 30 30          .byte 0,254,48,48,48,48,48,0
003754  3  30 30 30 00  
003758  3  00 C6 C6 C6          .byte 0,198,198,198,198,198,124,0
00375C  3  C6 C6 7C 00  
003760  3  00 C6 C6 C6          .byte 0,198,198,198,198,108,56,0
003764  3  C6 6C 38 00  
003768  3  00 C6 C6 C6          .byte 0,198,198,198,198,254,108,0
00376C  3  C6 FE 6C 00  
003770  3  00 C6 6C 38          .byte 0,198,108,56,56,108,198,0
003774  3  38 6C C6 00  
003778  3  00 86 CC 78          .byte 0,134,204,120,48,48,48,0
00377C  3  30 30 30 00  
003780  3  00 FE 0C 18          .byte 0,254,12,24,48,96,254,0
003784  3  30 60 FE 00  
003788  3  00 1E 18 18          .byte 0,30,24,24,24,24,30,0
00378C  3  18 18 1E 00  
003790  3  00 00 C0 60          .byte 0,0,192,96,48,24,12,0
003794  3  30 18 0C 00  
003798  3  00 F0 30 30          .byte 0,240,48,48,48,48,240,0
00379C  3  30 30 F0 00  
0037A0  3  00 30 78 FC          .byte 0,48,120,252,48,48,48,0
0037A4  3  30 30 30 00  
0037A8  3  00 00 00 00          .byte 0,0,0,0,0,0,0,255
0037AC  3  00 00 00 FF  
0037B0  3  00 3C 66 F8          .byte 0,60,102,248,96,96,254,0
0037B4  3  60 60 FE 00  
0037B8  3  00 00 78 0C          .byte 0,0,120,12,124,204,124,0
0037BC  3  7C CC 7C 00  
0037C0  3  00 60 60 7C          .byte 0,96,96,124,102,102,124,0
0037C4  3  66 66 7C 00  
0037C8  3  00 00 3C 60          .byte 0,0,60,96,96,96,60,0
0037CC  3  60 60 3C 00  
0037D0  3  00 0C 0C 7C          .byte 0,12,12,124,204,204,124,0
0037D4  3  CC CC 7C 00  
0037D8  3  00 00 78 CC          .byte 0,0,120,204,248,192,124,0
0037DC  3  F8 C0 7C 00  
0037E0  3  00 1C 30 38          .byte 0,28,48,56,48,48,48,0
0037E4  3  30 30 30 00  
0037E8  3  00 00 7C CC          .byte 0,0,124,204,204,124,12,120
0037EC  3  CC 7C 0C 78  
0037F0  3  00 C0 C0 F8          .byte 0,192,192,248,204,204,204,0
0037F4  3  CC CC CC 00  
0037F8  3  00 30 00 70          .byte 0,48,0,112,48,48,120,0
0037FC  3  30 30 78 00  
003800  3  00 0C 00 0C          .byte 0,12,0,12,12,12,108,56
003804  3  0C 0C 6C 38  
003808  3  00 60 78 70          .byte 0,96,120,112,112,120,108,0
00380C  3  70 78 6C 00  
003810  3  00 30 30 30          .byte 0,48,48,48,48,48,28,0
003814  3  30 30 1C 00  
003818  3  00 00 F8 FC          .byte 0,0,248,252,252,252,252,0
00381C  3  FC FC FC 00  
003820  3  00 00 F8 CC          .byte 0,0,248,204,204,204,204,0
003824  3  CC CC CC 00  
003828  3  00 00 78 CC          .byte 0,0,120,204,204,204,120,0
00382C  3  CC CC 78 00  
003830  3  00 00 F8 CC          .byte 0,0,248,204,204,248,192,192
003834  3  CC F8 C0 C0  
003838  3  00 00 7C CC          .byte 0,0,124,204,204,124,12,14
00383C  3  CC 7C 0C 0E  
003840  3  00 00 3C 60          .byte 0,0,60,96,96,96,96,0
003844  3  60 60 60 00  
003848  3  00 00 78 C0          .byte 0,0,120,192,120,12,248,0
00384C  3  78 0C F8 00  
003850  3  00 30 78 30          .byte 0,48,120,48,48,48,28,0
003854  3  30 30 1C 00  
003858  3  00 00 CC CC          .byte 0,0,204,204,204,204,120,0
00385C  3  CC CC 78 00  
003860  3  00 00 CC CC          .byte 0,0,204,204,120,120,48,0
003864  3  78 78 30 00  
003868  3  00 00 CC FC          .byte 0,0,204,252,252,252,120,0
00386C  3  FC FC 78 00  
003870  3  00 00 CC 78          .byte 0,0,204,120,48,120,204,0
003874  3  30 78 CC 00  
003878  3  00 00 CC CC          .byte 0,0,204,204,204,124,12,120
00387C  3  CC 7C 0C 78  
003880  3  00 00 FC 18          .byte 0,0,252,24,48,96,252,0
003884  3  30 60 FC 00  
003888  3  00 1E 18 70          .byte 0,30,24,112,24,24,30,0
00388C  3  18 18 1E 00  
003890  3  00 18 18 18          .byte 0,24,24,24,24,24,24,0
003894  3  18 18 18 00  
003898  3  00 F0 30 1C          .byte 0,240,48,28,48,48,240,0
00389C  3  30 30 F0 00  
0038A0  3  00 3C 78 00          .byte 0,60,120,0,0,0,0,0
0038A4  3  00 00 00 00  
0038A8  3  7C C6 BB E3          .byte 124,198,187,227,227,187,198,124
0038AC  3  E3 BB C6 7C  
0038B0  3               jtab:
0038B0  3  63                   .byte 99
0038B1  3  35 15 93 22  keys:   .byte 53,21,147,34,144,4,20,33,17,1,146
0038B5  3  90 04 14 21  
0038B9  3  11 01 92     
0038BC  3               
0038BC  2               
0038BC  1               	.include "z80.asm"
0038BC  2               ;------------------------------------------------------
0038BC  2               ; z80.asm
0038BC  2               ; spectrum stuff
0038BC  2               ; adresses
0038BC  2               
0038BC  2               
0038BC  2               ; Contains seperatly 1 bit set
0038BC  2               
0038BC  2               _bitmem0	= $f8
0038BC  2               _bitmem1	= $f9
0038BC  2               _bitmem2	= $fa
0038BC  2               _bitmem3	= $fb
0038BC  2               _bitmem4	= $fc
0038BC  2               _bitmem5	= $fd
0038BC  2               _bitmem6	= $fe
0038BC  2               _bitmem7	= $ff
0038BC  2               
0038BC  2               ; constants
0038BC  2               _bitvalue0	= $01
0038BC  2               _bitvalue1	= $02
0038BC  2               _bitvalue2	= $04
0038BC  2               _bitvalue3	= $08
0038BC  2               _bitvalue4	= $10
0038BC  2               _bitvalue5	= $20
0038BC  2               _bitvalue6	= $40
0038BC  2               _bitvalue7	= $80
0038BC  2               
0038BC  2               _notbitvalue0	= $fe
0038BC  2               _notbitvalue1	= $fd
0038BC  2               _notbitvalue2	= $fb
0038BC  2               _notbitvalue3	= $f7
0038BC  2               _notbitvalue4	= $ef
0038BC  2               _notbitvalue5	= $df
0038BC  2               _notbitvalue6	= $bf
0038BC  2               _notbitvalue7	= $7f
0038BC  2               
0038BC  2               
0038BC  2               exx:
0038BC  2  A5 62        		lda z80_c
0038BE  2  A4 6E        		ldy z80_cp
0038C0  2  84 62        		sty z80_c
0038C2  2  85 6E        		sta z80_cp
0038C4  2  A5 63        		lda z80_b
0038C6  2  A4 6F        		ldy z80_bp
0038C8  2  84 63        		sty z80_b
0038CA  2  85 6F        		sta z80_bp
0038CC  2  A5 64        		lda z80_e
0038CE  2  A4 70        		ldy z80_ep
0038D0  2  84 64        		sty z80_e
0038D2  2  85 70        		sta z80_ep
0038D4  2  A5 65        		lda z80_d
0038D6  2  A4 71        		ldy z80_dp
0038D8  2  84 65        		sty z80_d
0038DA  2  85 71        		sta z80_dp
0038DC  2  A5 rr        		lda scraddr
0038DE  2  A4 72        		ldy z80_lp
0038E0  2  84 rr        		sty scraddr
0038E2  2  85 72        		sta z80_lp
0038E4  2  A5 rr        		lda scraddr+1
0038E6  2  A4 73        		ldy z80_hp
0038E8  2  84 rr        		sty scraddr+1
0038EA  2  85 73        		sta z80_hp
0038EC  2  60           		rts
0038ED  2               
0038ED  2               
0038ED  1               eind_asm:
0038ED  1               eop:					; End Of Program
0038ED  1               
0038ED  1               .out .sprintf("Gamecode size = %d bytes, free space = %d bytes", (eind_asm - start_asm),(32000-eind_asm + start_asm))
0038ED  1               
