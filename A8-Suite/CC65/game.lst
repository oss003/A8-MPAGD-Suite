ca65 V2.17 - Git d13d068
Main file   : game.asm
Current file: game.asm

000000r 1               ;----------------------------------------------
000000r 1               ; Common AGD engine
000000r 1               ; Z80 conversion by Kees van Oss 2017
000000r 1               ;----------------------------------------------
000000r 1               	.DEFINE asm_code $2000
000000r 1               	.include "game.cfg"
000000r 2               ; Flags saved by AGD Compiler
000000r 2               
000000r 2               cflag = 0 ;
000000r 2               dflag = 0 ;
000000r 2               lflag = 0 ;
000000r 2               mflag = 0 ;
000000r 2               oflag = 0 ;
000000r 2               pflag = 0 ;
000000r 2               sflag = 0 ;
000000r 2               clwflag = 0 ;
000000r 2               bigflag = 1 ;
000000r 2               rflag = 0 ;
000000r 2               
000000r 1               
000000r 1               .segment "ZEROPAGE"
000000r 1               	.include "z80-zp.inc"
000000r 2               ;.segment "ZEROPAGE"
000000r 2               
000000r 2               ws	 = $60
000000r 2               
000000r 2               z80_f	 = ws+$00
000000r 2               z80_a	 = ws+$01
000000r 2               z80_af	 = z80_f
000000r 2               
000000r 2               z80_c	 = ws+$02
000000r 2               z80_b	 = ws+$03
000000r 2               z80_bc	 = z80_c
000000r 2               
000000r 2               z80_e	 = ws+$04
000000r 2               z80_d	 = ws+$05
000000r 2               z80_de	 = z80_e
000000r 2               
000000r 2               z80_l	 = ws+$06
000000r 2               z80_h	 = ws+$07
000000r 2               z80_hl	 = z80_l
000000r 2               
000000r 2               z80_x    = ws+$08
000000r 2               z80_i    = ws+$09
000000r 2               z80_ix	 = z80_x
000000r 2               
000000r 2               z80_iy	 = ws+$0a
000000r 2               
000000r 2               z80_fp	 = ws+$0c
000000r 2               z80_ap	 = ws+$0d
000000r 2               
000000r 2               z80_cp	 = ws+$0e
000000r 2               z80_bp	 = ws+$0f
000000r 2               z80_bcp	 = z80_cp
000000r 2               
000000r 2               z80_ep	 = ws+$10
000000r 2               z80_dp	 = ws+$11
000000r 2               z80_dep	 = z80_ep
000000r 2               
000000r 2               z80_lp	 = ws+$12
000000r 2               z80_hp	 = ws+$13
000000r 2               z80_hlp	 = z80_lp
000000r 2               
000000r 2               z80_sp   = ws+$14
000000r 2               
000000r 2               z80_reg0 = ws+$16
000000r 2               z80_reg1 = ws+$17
000000r 2               z80_reg2 = ws+$18
000000r 2               z80_reg3 = ws+$19
000000r 2               
000000r 2               z80_r	 = ws+$1a
000000r 2               
000000r 2               
000000r 1               	.include "engine-zp.inc"
000000r 2               ;----------------------------------------------------------------------
000000r 2               ; AGD 6502 Engine Zero Page Variables
000000r 2               ;----------------------------------------------------------------------
000000r 2               
000000r 2               ; Variables start here.
000000r 2               
000000r 2  xx           scno:	.res 1			; present screen number.
000001r 2  xx           numlif:	.res 1			; number of lives.
000002r 2               
000002r 2  xx           vara:	.res 1			; general-purpose variable.
000003r 2  xx           varb:	.res 1			; general-purpose variable.
000004r 2  xx           varc:	.res 1			; general-purpose variable.
000005r 2  xx           vard:	.res 1			; general-purpose variable.
000006r 2  xx           vare:	.res 1			; general-purpose variable.
000007r 2  xx           varf:	.res 1			; general-purpose variable.
000008r 2  xx           varg:	.res 1			; general-purpose variable.
000009r 2  xx           varh:	.res 1			; general-purpose variable.
00000Ar 2  xx           vari:	.res 1			; general-purpose variable.
00000Br 2  xx           varj:	.res 1			; general-purpose variable.
00000Cr 2  xx           vark:	.res 1			; general-purpose variable.
00000Dr 2  xx           varl:	.res 1			; general-purpose variable.
00000Er 2  xx           varm:	.res 1			; general-purpose variable.
00000Fr 2  xx           varn:	.res 1			; general-purpose variable.
000010r 2  xx           varo:	.res 1			; general-purpose variable.
000011r 2  xx           varp:	.res 1			; general-purpose variable.
000012r 2  xx           varq:	.res 1			; general-purpose variable.
000013r 2  xx           varr:	.res 1			; general-purpose variable.
000014r 2  xx           vars:	.res 1			; general-purpose variable.
000015r 2  xx           vart:	.res 1			; general-purpose variable.
000016r 2  xx           varu:	.res 1			; general-purpose variable.
000017r 2  xx           varv:	.res 1			; general-purpose variable.
000018r 2  xx           varw:	.res 1			; general-purpose variable.
000019r 2  xx           varz:	.res 1			; general-purpose variable.
00001Ar 2               
00001Ar 2  xx           charx:	.res 1			; cursor x position.
00001Br 2  xx           chary:	.res 1			; cursor y position.
00001Cr 2               
00001Cr 2  xx           clock:	.res 1			; last clock reading.
00001Dr 2  xx           varrnd:	.res 1	        	; last random number.
00001Er 2  xx           varobj:	.res 1  	   	; last object number.
00001Fr 2  xx           varopt:	.res 1     		; last option chosen from menu.
000020r 2  xx           varblk:	.res 1  		; block type.
000021r 2  xx           nexlev:	.res 1			; next level flag.
000022r 2  xx           restfl:	.res 1			; restart screen flag.
000023r 2  xx           deadf:	.res 1			; dead flag.
000024r 2  xx           gamwon:	.res 1			; game won flag.
000025r 2  xx           dispx:	.res 1			; cursor x position.
000026r 2  xx           dispy:	.res 1			; cursor y position.
000027r 2               
000027r 2  xx           contrl:	.res 1			; control = keyboard, 1 = Kempston, 2 = Sinclair, 3 = Mouse.
000028r 2  xx           joyval:	.res 1			; joystick reading.
000029r 2  xx           frmno:	.res 1			; selected frame.
00002Ar 2               
00002Ar 2               ;----------------------------------------------------
00002Ar 2               ; Missing vars
00002Ar 2               ;----------------------------------------------------
00002Ar 2               
00002Ar 2  xx           loopa:	    .res 1
00002Br 2  xx           loopb:	    .res 1
00002Cr 2  xx           loopc:	    .res 1
00002Dr 2  xx xx        FontPtr:    .res 2
00002Fr 2               
00002Fr 2               ; Local vars
00002Fr 2               
00002Fr 2  xx xx        scraddr:    .res 2
000031r 2  xx xx        fntaddr:    .res 2
000033r 2  xx xx        tileaddr:   .res 2
000035r 2  xx xx        bufaddr:    .res 2
000037r 2  xx xx        advbuff:    .res 2
000039r 2               
000039r 2  xx xx        tmp:        .res 2
00003Br 2  xx xx        scr_l:      .res 2
00003Dr 2  xx xx        scr_r:      .res 2
00003Fr 2  xx xx        scr_txt:    .res 2
000041r 2               
000041r 2  xx           xtmp:	    .res 1
000042r 2  xx           ytmp:	    .res 1
000043r 2  xx           spcnt:	    .res 1
000044r 2  xx xx        spptr:	    .res 2		; spawned sprite pointer.
000046r 2  xx           seed:	    .res 1		; seed for random numbers.
000047r 2               
000047r 2  xx           ccnt:       .res 1
000048r 2  xx           flag:	    .res 1
000049r 2  xx           rcol:	    .res 1
00004Ar 2  xx           rrow:	    .res 1
00004Br 2               
00004Br 2  xx           combyt:	    .res 1		; byte type compressed.
00004Cr 2  xx           comcnt:	    .res 1		; compression counter.
00004Dr 2  xx           prtmod:	    .res 1      	; print mode, 0 = standard, 1 = double-height.
00004Er 2  xx           qscnt:	    .res 1
00004Fr 2               
00004Fr 2  xx           sprptr:	    .res 1      	; not a ptr
000050r 2  xx           sprcnt:	    .res 1
000051r 2               
000051r 2  xx xx        skptr:	    .res 2		; search pointer.
000053r 2  xx           sktptr:	    .res 1      	; not a ptr
000054r 2  xx           tmproom:    .res 1
000055r 2  xx xx        ogptr:	    .res 2		; original sprite pointer.
000057r 2               
000057r 2               .if mflag
000057r 2               TmpAddr:    .res 2
000057r 2               bwid:	    .res 1     		; box/menu width.
000057r 2               blen:	    .res 1     		; box/menu height.
000057r 2               btop:	    .res 1    	 	; box coordinates.
000057r 2               blft:	    .res 1
000057r 2               .endif
000057r 2               
000057r 2               .if sflag .or pflag
000057r 2               shrctr:	    .res 1
000057r 2               .endif
000057r 2               .if pflag
000057r 2               explcnt:    .res 1
000057r 2               seed3:	    .res 1
000057r 2               .endif
000057r 2               
000057r 2               .if aflag
000057r 2               pbptr:       .res 2
000057r 2               pbbuf:	     .res 2
000057r 2               .endif
000057r 2               
000057r 2               ;sndtyp:     .res 1
000057r 2               
000057r 2               .if rflag
000057r 2               sprshft:     .res 1
000057r 2               .endif
000057r 2               
000057r 1               
000057r 1               .segment "CODE"
000000r 1               .org asm_code-6
001FFA  1  FF FF        	.word $ffff
001FFC  1  00 20        	.word start_asm
001FFE  1  FB 3A        	.word eind_asm
002000  1               
002000  1               start_asm:
002000  1               	.include "game.inc"
002000  2               .include "testcolour.inc"
002000  3               ;--------------------------------------------------------------
002000  3               ; Arcade Game Designer.
002000  3               ; (C) 2008 Jonathan Cauldwell.
002000  3               ; ZX Spectrum Next Engine v0.7.
002000  3               ; Acorn Atom port by K.v.Oss 2018
002000  3               ;--------------------------------------------------------------
002000  3               
002000  3               ; Conditional compilation flags
002000  3               ; Code is installed if flag is set
002000  3               ; Flags are set in commandline assembly or by the compiler
002000  3               
002000  3               ; Flags set by AGD compiler
002000  3               ;	mflag  			; MENU + INV
002000  3               ;	pflag 			; particle engine
002000  3               ;	sflag 			; scrollytext
002000  3               ;	dflag 			; digging mode
002000  3               ;	cflag			; collectable blocks
002000  3               ;	oflag			; objects
002000  3               ;	lflag			; ladders
002000  3               ;
002000  3               ; Flags set manually
002000  3               ;	aflag			; adventure mode
002000  3               ;	bflag			; big sprites (16x24)
002000  3               ;	iflag			; invert mode
002000  3               
002000  3               .if mflag
002000  3               	.out "- MEN/INV enabled"
002000  3               .endif
002000  3               .if pflag
002000  3               	.out "- Particles enabled"
002000  3               .endif
002000  3               .if sflag
002000  3               	.out "- Scrolling enabled"
002000  3               .endif
002000  3               .if dflag
002000  3               	.out "- Digging enabled"
002000  3               .endif
002000  3               .if cflag
002000  3               	.out "- Collectable blocks enabled"
002000  3               .endif
002000  3               .if oflag
002000  3               	.out "- Objects enabled"
002000  3               .endif
002000  3               .if lflag
002000  3               	.out "- Ladders enabled"
002000  3               .endif
002000  3               .if aflag
002000  3               	.out "- Adventure mode enabled"
002000  3               .endif
002000  3               .if bflag
002000  3               	.out "- Big Sprites (16x24) enabled"
002000  3               .endif
002000  3               .if iflag
002000  3               	.out "- Invert mode enabled"
002000  3               .endif
002000  3               .if gflag
002000  3               	.out "- Colour mode enabled"
002000  3               .endif
002000  3               .if rflag
002000  3               	.out "- RAM saving mode enabled"
002000  3               .endif
002000  3               
002000  3               ; Global definitions ------------------------------------------------------------
002000  3               
002000  3               	FONT = font		; Font address
002000  3               
002000  3               	green	= $00		; Colour definition filters
002000  3               	yellow	= $55
002000  3               	blue	= $aa
002000  3               	red	= $ff
002000  3               
002000  3               ; Block characteristics.
002000  3               
002000  3               	PLATFM	= 1		; platform.
002000  3               	WALL	= PLATFM + 1	; solid wall.
002000  3               	LADDER	= WALL + 1	; ladder.
002000  3               	FODDER	= LADDER + 1	; fodder block.
002000  3               	DEADLY	= FODDER + 1	; deadly block.
002000  3               	CUSTOM	= DEADLY + 1	; custom block.
002000  3               	WATER	= CUSTOM + 1	; water block.
002000  3                       COLECT	= WATER + 1	; collectable block.
002000  3                       NUMTYP	= COLECT + 1	; number of types.
002000  3               
002000  3               ; Sprites.
002000  3               
002000  3               .if bflag
002000  3               	SPR_HGT	= 24		; Sprite height
002000  3               	SPR_WID = 16		; Sprite width
002000  3               	NUMSPR	= 8		; number of sprites.
002000  3               .else				; 16x16 sprites
002000  3               	SPR_HGT = 16		; Sprite height
002000  3               	SPR_WID = 16		; Sprite width
002000  3               	NUMSPR	= 12		; number of sprites.
002000  3               .endif
002000  3               
002000  3               	TABSIZ = 17		; size of each entry.
002000  3               	SPRBUF = NUMSPR * TABSIZ; size of entire table.
002000  3               	NMESIZ = 4		; bytes stored in nmetab for each sprite.
002000  3               	var_X  = 8		; new x coordinate of sprite.
002000  3               	var_Y  = var_X + 1	; new y coordinate of sprite.
002000  3               	PAM1ST = 5		; first sprite parameter, old x (ix+5).
002000  3               
002000  3               ; Particle engine.
002000  3               
002000  3               	NUMSHR = 55		; pieces of shrapnel.
002000  3               	SHRSIZ = 6		; bytes per particle.
002000  3               
002000  3               ; System constants
002000  3               
002000  3               	ScrSelAddr  = $b000	; Screen selection address
002000  3               	KeyRowAddr  = $b000	; PIA key matrix row
002000  3               	KeyColAddr  = $b001	; PIA key matrix column
002000  3               	SpeakerBit  = $b002	; Speaker bit
002000  3               	CmdReg      = $b400	; Command register AtoMMC
002000  3               	DatReg      = $b401	; Data register AtoMMC
002000  3               	Timer2_Low  = $b808	; Timer 2 low byte
002000  3               	Timer2_High = $b809	; Timer 2 high byte
002000  3               	ScreenAddr  = $e400	; Startaddress video RAM
002000  3               
002000  3               	MAP 	    = $dd00		; properties map buffer (3x256 bytes)
002000  3               	SCADTB_lb   = MAP+3*256		; screen address table lo-byte (256 bytes)
002000  3               	SCADTB_hb   = SCADTB_lb+256	; screen address table hi-byte (256 bytes)
002000  3               	SHRAPN      = SCADTB_hb+256	; shrapnel table (55x6 bytes)
002000  3               
002000  3               ; System calls
002000  3               
002000  3               	SCRSYNC	 = $fe66	; wait for next CRT field flyback 60 Hz
002000  3               	SCRSYNC1 = $fe6b	; wait for CRT field flyback 60 Hz
002000  3               	OSRDCH   = $fe94	; get key subroutine
002000  3                       READKEY  = $fe71	; scan key matrix subroutine
002000  3               	OSWRCH	 = $fff4	; write character
002000  3               
002000  3               
002000  3               .if iflag
002000  3               	TxtInvert   = $ff	; Invert byte for character printing
002000  3               	ScrFillByte = $ff	; Screen fill byte for CLS
002000  3               .else
002000  3               	TxtInvert   = $00	; Invert byte for character printing
002000  3               	ScrFillByte = $00	; Screen fill byte for CLS
002000  3               .endif
002000  3               
002000  3               	ScrMode     = $f0	;  $f0 = CLEAR4  mono
002000  3               
002000  3               ;===============================================================
002000  3               ; Game starts here
002000  3               ;===============================================================
002000  3               
002000  3               ;.segment "CODE"
002000  3               
002000  3  20 2B 38     	jsr init
002003  3               
002003  3               ; Clear variables
002003  3               
002003  3  A9 00        	lda #0
002005  3  A2 00        	ldx #0
002007  3               clrloop:
002007  3  95 00        	sta 0,x
002009  3  E8           	inx
00200A  3  D0 FB        	bne clrloop
00200C  3               
00200C  3               gameloop:
00200C  3  20 D5 20     	jsr game	 	; start the game.
00200F  3  4C 0C 20     	jmp gameloop		; Start again
002012  3               
002012  3               ; Definition of variables
002012  3               ; Make sure pointers are arranged in the same order as the data itself.
002012  3               
002012  3  0D 34        msgptr:		.word msgdat	; messages
002014  3  61 34        blkptr:		.word chgfx	; block graphics.
002016  3  69 34        proptr:		.word bprop	; address of char properties.
002018  3  6A 34        sptptr:		.word sprgfx	; sprite graphics
00201A  3  EA 34        frmptr:		.word frmlst	; sprite frames.
00201C  3  EE 34        scrptr:		.word scdat	; address of screens.
00201E  3  F4 34        nmeptr:		.word nmedat	; enemy start positions.
002020  3  F9 34        objptr:		.word objdta	; object graphics
002022  3               
002022  3               ;TxtFilter:	.byte $ff
002022  3  00 55 AA FF  txtcol:		.byte green,yellow,blue,red
002026  3               
002026  3               ; Don't change the order of these four.
002026  3               ; Menu routine relies on winlft following wintop.
002026  3               
002026  3  00           wintop:		.byte WINDOWTOP	; top of window.
002027  3  00           winlft:		.byte WINDOWLFT	; left edge.
002028  3  08           winhgt:		.byte WINDOWHGT	; window height.
002029  3  20           winwid:		.byte WINDOWWID	; window width.
00202A  3  01           numob:		.byte NUMOBJ	; number of objects in game.
00202B  3               
00202B  3               ; Variables start here.
00202B  3               ; Pixel versions of wintop, winlft, winhgt, winwid.
00202B  3               
00202B  3  00           wntopx:		.byte (8 * WINDOWTOP)
00202C  3  00           wnlftx:		.byte (8 * WINDOWLFT)
00202D  3  30           wnbotx:		.byte ((WINDOWTOP * 8) + (WINDOWHGT * 8) - 16)
00202E  3  EE           wnrgtx:		.byte ((WINDOWLFT * 8) + (WINDOWWID * 8) - 16)-2
00202F  3               
00202F  3               ; Assorted game routines which can go in contended memory.
00202F  3               
00202F  3               ;--------------------------------------------------------------
00202F  3               ; Entry for inventory called by the INV command
00202F  3               ;
00202F  3               ; Input:
00202F  3               ;  X   = message nr with objects seperated with ,
00202F  3               ;
00202F  3               ; Output:
00202F  3               ;  OPT = selected objectnr of INV menu
00202F  3               ;--------------------------------------------------------------
00202F  3               
00202F  3               .if mflag
00202F  3               minve:
00202F  3               .if gflag
00202F  3               	lda #$ff		; blue frontcolour
00202F  3               	sta andeor
00202F  3               	lda #$aa		; yellow backcoloour
00202F  3               	sta andeor+1
00202F  3               .endif
00202F  3               	lda #<(invdis)		; routine address.
00202F  3               	sta mod0+1		; set up menu routine.
00202F  3               	sta mod2+1		; set up count routine.
00202F  3               	lda #>(invdis)
00202F  3               	sta mod0+2
00202F  3               	sta mod2+2
00202F  3               	lda #<(fopt)		; find option from available objects.
00202F  3               	sta mod1+1		; set up routine.
00202F  3               	lda #>(fopt)
00202F  3               	sta mod1+1+1
00202F  3               	jmp dbox		; do menu routine.
00202F  3               
00202F  3               ;--------------------------------------------------------------
00202F  3               ; Entry for menu called by the MENU command
00202F  3               ;
00202F  3               ; Input:
00202F  3               ;  X   = message nr with menu items seperated with ,
00202F  3               ;
00202F  3               ; Output:
00202F  3               ;  OPT = selected line nr of MENU menu
00202F  3               ;--------------------------------------------------------------
00202F  3               
00202F  3               mmenu:
00202F  3               	lda #<(always)		; routine address.
00202F  3               	sta mod0+1		; set up routine.
00202F  3               	sta mod2+1		; set up count routine.
00202F  3               	lda #>(always)
00202F  3               	sta mod0+2
00202F  3               	sta mod2+2
00202F  3               
00202F  3               	lda #<(fstd)		; standard option selection.
00202F  3               	sta mod1+1		; set up routine.
00202F  3               	lda #>(fstd)
00202F  3               	sta mod1+2
00202F  3               
00202F  3               ; Drop through into box routine.
00202F  3               
00202F  3               ;--------------------------------------------------------------
00202F  3               ; Work out size of box for message or menu.
00202F  3               ;--------------------------------------------------------------
00202F  3               
00202F  3               dbox:
00202F  3               	lda #<(msgdat)		; pointer to messages.
00202F  3               	sta z80_l
00202F  3               	lda #>(msgdat)
00202F  3               	sta z80_h
00202F  3               
00202F  3               	jsr getwrd		; get message number.
00202F  3               
00202F  3               	lda z80_h		; store pointer to message.
00202F  3               	sta TmpAddr
00202F  3               	lda z80_l
00202F  3               	sta TmpAddr+1
00202F  3               
00202F  3               	lda #1			; height.
00202F  3               	sta z80_d
00202F  3               	lda #0			; start at object zero.
00202F  3               	sta combyt		; store number of object in combyt.
00202F  3               	sta z80_e		; maximum width.
00202F  3               dbox5:
00202F  3               	lda #0			; this line"s width.
00202F  3               	sta z80_b
00202F  3               mod2:
00202F  3               	jsr always		; item in player"s possession?
00202F  3               	cmp #255
00202F  3               	bne dbox6		; not in inventory, skip this line.
00202F  3               	inc z80_d		; add to tally.
00202F  3               dbox6:
00202F  3               	ldy #0			; get character.
00202F  3               	lda (z80_hl),y
00202F  3               	sta z80_a
00202F  3               	inc z80_l		; next character.
00202F  3               	bne :+
00202F  3               	inc z80_h
00202F  3               :
00202F  3               	lda z80_a		; reached end of line?
00202F  3               	cmp #','
00202F  3               	beq dbox3		; yes.
00202F  3               	cmp #13
00202F  3               	beq dbox3		; yes.
00202F  3               	inc z80_b		; add to this line"s width.
00202F  3               	lda z80_a
00202F  3               	bmi dbox4		; end of message? yes, end count.
00202F  3               	jmp dbox6		; repeat until we find the end.
00202F  3               dbox3:
00202F  3               	lda z80_e		; maximum line width.
00202F  3               	cmp z80_b		; have we exceeded longest so far?
00202F  3               	bpl dbox5		; no, carry on looking.
00202F  3               	lda z80_b		; make this the widest so far.
00202F  3               	sta z80_e
00202F  3               	jmp dbox5		; keep looking.
00202F  3               dbox4:
00202F  3               	lda z80_e		; maximum line width.
00202F  3               	cmp z80_b		; have we exceeded longest so far?
00202F  3               	bpl dbox8		; no, carry on looking.
00202F  3               	lda z80_b		; final line is the longest so far.
00202F  3               	sta z80_e
00202F  3               dbox8:
00202F  3               	dec z80_d		; decrement items found.
00202F  3               	bne :+			; total was zero.
00202F  3               	lda #255
00202F  3               	sta varopt
00202F  3               	jmp dbox15
00202F  3               :
00202F  3               	lda z80_e		; longest line.
00202F  3               	bne :+			; was it zero?
00202F  3               	jmp dbox15		; total was zero.
00202F  3               :
00202F  3               	sta bwid		; set up size.
00202F  3               	lda z80_d
00202F  3               	sta blen
00202F  3               
00202F  3               ;--------------------------------------------------------------
00202F  3               ; That's set up our box size.
00202F  3               ;--------------------------------------------------------------
00202F  3               
00202F  3               	lda winhgt		; window height in characters.
00202F  3               	sec
00202F  3               	sbc z80_d		; subtract height of box.
00202F  3               	lsr a			; divide by 2.
00202F  3               	clc
00202F  3               	adc wintop		; add top edge of window.
00202F  3               	sta btop		; set up box top.
00202F  3               
00202F  3               	lda winwid		; window width in characters.
00202F  3               	sec
00202F  3               	sbc z80_e		; subtract box width.
00202F  3               	lsr a			; divide by 2.
00202F  3               	clc
00202F  3               	adc winlft		; add left edge of window.
00202F  3               	sta blft		; box left.
00202F  3               
00202F  3               	lda #<(FONT-256)		; font.
00202F  3               	sta grbase		; set up for text display.
00202F  3               	lda #>(FONT-256)
00202F  3               	sta grbase+1
00202F  3               
00202F  3               	lda TmpAddr+1		; restore message pointer.
00202F  3               	sta z80_l
00202F  3               	lda TmpAddr
00202F  3               	sta z80_h
00202F  3               
00202F  3               	lda btop		; box top.
00202F  3               	sta dispy		; set display coordinate.
00202F  3               	lda #0			; start at object zero.
00202F  3               	sta combyt		; store number of object in combyt.
00202F  3               dbox2:
00202F  3               	lda combyt		; get object number.
00202F  3               	sta z80_a
00202F  3               mod0:
00202F  3               	jsr always		; check inventory for display.
00202F  3               	cmp #255
00202F  3               	beq :+
00202F  3               	jmp dbox13		; not in inventory, skip this line.
00202F  3               :
00202F  3               	lda blft		; box left.
00202F  3               	sta dispx		; set left display position.
00202F  3               	lda bwid		; box width.
00202F  3               	sta z80_b		; store width.
00202F  3               dbox0:
00202F  3               	ldy #0
00202F  3               	lda (z80_hl),y		; get character.
00202F  3               	cmp #','		; end of line?
00202F  3               	beq dbox1		; yes, next one.
00202F  3               	cmp #13			; end of line?
00202F  3               	beq dbox1		; yes, next one.
00202F  3               
00202F  3               	cmp #141			; end of line?
00202F  3               	bne :+
00202F  3               	dec bwid
00202F  3               	jmp dbox7		; yes, next one.
00202F  3               :
00202F  3               	dec z80_b		; one less to display.
00202F  3               	and #127		; remove terminator.
00202F  3               
00202F  3               	jsr pchr		; display on screen.
00202F  3               
00202F  3               	ldy #0
00202F  3               	lda (z80_hl),y		; get character.
00202F  3               	sta z80_a
00202F  3               	inc z80_l		; next character.
00202F  3               	bne :+
00202F  3               	inc z80_h
00202F  3               :
00202F  3               	lda z80_a
00202F  3               	cmp #128		; end of message?
00202F  3               	bmi :+
00202F  3               	jmp dbox7		; yes, job done.
00202F  3               :
00202F  3               	lda z80_b		; chars remaining.
00202F  3               	beq :+			; are any left?
00202F  3               	jmp dbox0		; yes, continue.
00202F  3               :
00202F  3               ;---------------------------------------------------
00202F  3               ; Reached limit of characters per line.
00202F  3               ;---------------------------------------------------
00202F  3               
00202F  3               dbox9:
00202F  3               	ldy #0
00202F  3               	lda (z80_hl),y		; get character.
00202F  3               	inc z80_l		; next one.
00202F  3               	bne :+
00202F  3               	inc z80_h
00202F  3               :
00202F  3               	cmp #','		; another line?
00202F  3               	beq dbox10		; yes, do next line.
00202F  3               	cmp #13			; another line?
00202F  3               	beq dbox10		; yes, do next line.
00202F  3               	cmp #128		; end of message?
00202F  3               	bcs :+
00202F  3               	jmp dbox11		; yes, finish message.
00202F  3               :
00202F  3               	jmp dbox9
00202F  3               
00202F  3               ;---------------------------------------------------
00202F  3               ; Fill box to end of line.
00202F  3               ;---------------------------------------------------
00202F  3               
00202F  3               dboxf:
00202F  3               	lda #32			; space character.
00202F  3               	jsr pchr		; display character.
00202F  3               	dec z80_b
00202F  3               	beq :+
00202F  3               	jmp dboxf		; repeat for remaining chars on line.
00202F  3               :
00202F  3               	rts
00202F  3               dbox1:
00202F  3               	inc z80_l		; skip character.
00202F  3               	bne :+
00202F  3               	inc z80_h
00202F  3               :
00202F  3               	jsr dboxf		; fill box out to right side.
00202F  3               dbox10:
00202F  3               	inc dispy		; y coordinate down a line next position.
00202F  3               	jmp dbox2		; next line.
00202F  3               dbox7:
00202F  3               	lda z80_b		; chars remaining.
00202F  3               	bne :+			; are any left?
00202F  3               	jmp dbox11		; no, nothing to draw.
00202F  3               :
00202F  3               	jsr dboxf		; fill message to line.
00202F  3               
00202F  3               ;------------------------------------------------------
00202F  3               ; Drawn the box menu, now select option.
00202F  3               ;------------------------------------------------------
00202F  3               
00202F  3               dbox11:
00202F  3               	lda btop		; box top.
00202F  3               	sta dispy		; set bar position.
00202F  3               dbox14:
00202F  3               	jsr joykey		; get controls.
00202F  3               	cmp #$7f		; anything pressed?
00202F  3               	bne dbox14		; yes, debounce it.
00202F  3               	jsr dbar		; draw bar.
00202F  3               dbox12:
00202F  3               	jsr joykey		; get controls.
00202F  3               	cmp #$7f		; anything pressed?
00202F  3               	beq dbox12		; no, nothing.
00202F  3               	and #16			; fire button pressed?
00202F  3               	bne :+
00202F  3               mod1:
00202F  3               	jmp fstd		; yes, job done.
00202F  3               :
00202F  3               	jsr dbar		; delete bar.
00202F  3               
00202F  3               	lda joyval		; joystick reading.
00202F  3               	and #8			; going up?
00202F  3               	beq dboxu		; yes, go up.
00202F  3               
00202F  3               	ldx dispy		; vertical position of bar.
00202F  3               	inx			; look down.
00202F  3               	txa
00202F  3               	sec
00202F  3               	sbc btop		; find distance from top.
00202F  3               	cmp blen		; top of box.
00202F  3               	bne :+
00202F  3               	jmp dbox14		; yes, go no further.
00202F  3               :
00202F  3               	inc dispy		; move bar.
00202F  3               	jmp dbox14		; continue.
00202F  3               dboxu:
00202F  3               	lda dispy		; vertical position of bar.
00202F  3               	cmp btop		; are we at the top?
00202F  3               	bne :+
00202F  3               	jmp dbox14		; yes, go no further.
00202F  3               :
00202F  3               	dec dispy		; move bar.
00202F  3               	jmp dbox14		; continue.
00202F  3               fstd:
00202F  3               	lda dispy		; bar position.
00202F  3               	sec
00202F  3               	sbc btop		; find selected option.
00202F  3               	sta varopt		; store the option.
00202F  3               	jmp redraw		; redraw the screen.
00202F  3               
00202F  3               ;------------------------------------------------------
00202F  3               ; Option not available.  Skip this line.
00202F  3               ;------------------------------------------------------
00202F  3               
00202F  3               dbox13:
00202F  3               	ldy #0
00202F  3               	lda (z80_hl),y		; get character.
00202F  3               	inc z80_l		; next one.
00202F  3               	bne :+
00202F  3               	inc z80_h
00202F  3               :
00202F  3               	cmp #','		; another line?
00202F  3               	bne :+
00202F  3               	jmp dbox2		; yes, do next line.
00202F  3               :
00202F  3               	cmp #13			; another line?
00202F  3               	bne :+
00202F  3               	jmp dbox2		; yes, do next line.
00202F  3               :
00202F  3               
00202F  3               	bpl :+			; end of message?
00202F  3               	jmp dbox11		; yes, finish message.
00202F  3               :
00202F  3               	jmp dbox13
00202F  3               dbox15:
00202F  3               	lda TmpAddr		; pop message pointer from the stack.
00202F  3               	sta z80_h
00202F  3               	lda TmpAddr+1
00202F  3               	sta z80_l
00202F  3               	rts
00202F  3               
00202F  3               ;------------------------------------------------------
00202F  3               ; Invert bar
00202F  3               ;------------------------------------------------------
00202F  3               
00202F  3               dbar:
00202F  3               	lda blft		; box left.
00202F  3               	sta dispx		; set display coordinate.
00202F  3               	jsr gprad		; get printing address.
00202F  3               
00202F  3               	lda bwid		; box width.
00202F  3               	sta z80_c		; loop counter in c.
00202F  3               	lda z80_h
00202F  3               	sta z80_d		; store screen address high byte.
00202F  3               dbar1:
00202F  3               	ldx #7			; pixel height in b.
00202F  3               dbar0:
00202F  3               	ldy scrtab,x
00202F  3               	lda (scraddr),y		; get screen byte.
00202F  3               	eor #255		; reverse all bits.
00202F  3               	sta (scraddr),y		; write back to screen.
00202F  3               	dex			; next line down.
00202F  3               	bpl dbar0		; draw rest of character.
00202F  3               
00202F  3               	inc scraddr		; one char right.
00202F  3               	dec z80_c		; decrement character counter.
00202F  3               	bne dbar1		; repeat for whole line.
00202F  3               	rts
00202F  3               
00202F  3               ;------------------------------------------------------
00202F  3               ; Point to object
00202F  3               ;
00202F  3               ; Input:
00202F  3               ;  combyt
00202F  3               ;
00202F  3               ; Output:
00202F  3               ;  A = object number, A=255 if already in possession
00202F  3               ;------------------------------------------------------
00202F  3               
00202F  3               invdis:
00202F  3               	lda z80_l		; store message text pointer.
00202F  3               	pha
00202F  3               	lda z80_h
00202F  3               	pha
00202F  3               	lda combyt		; object number.
00202F  3               	inc combyt		; ready for next one.
00202F  3               	jsr gotob		; check if we have object.
00202F  3               	tay
00202F  3               	pla
00202F  3               	sta z80_h
00202F  3               	pla
00202F  3               	sta z80_l
00202F  3               	tya
00202F  3               	rts
00202F  3               
00202F  3               ;------------------------------------------------------
00202F  3               ; Find option selected.
00202F  3               ;
00202F  3               ; Input:
00202F  3               ;  -
00202F  3               ;
00202F  3               ; Output:
00202F  3               ;  OPT = selected object
00202F  3               ;------------------------------------------------------
00202F  3               
00202F  3               fopt:
00202F  3               	lda dispy
00202F  3               	sec
00202F  3               	sbc btop		; find selected option.
00202F  3               	sta tmp+2		; option selected in b register.
00202F  3               	inc tmp+2
00202F  3               
00202F  3               	lda #0			; set to first item.
00202F  3               	sta combyt		; object number.
00202F  3               fopt0:
00202F  3               	jsr fobj		; find next object in inventory.
00202F  3               	dec tmp+2
00202F  3               	bne fopt0		; repeat for relevant steps down the list.
00202F  3               
00202F  3               	lda combyt		; get option.
00202F  3               	sta varopt		; store the option.
00202F  3               	dec varopt		; one less, due to where we increment combyt.
00202F  3               	jmp redraw		; redraw the screen.
00202F  3               fobj:
00202F  3               	ldy combyt		; object number.
00202F  3               	inc combyt		; ready for next item.
00202F  3               	tya
00202F  3               	jsr gotob		; do we have this item?
00202F  3               	cmp #255
00202F  3               	bne :+
00202F  3               	rts
00202F  3               :
00202F  3               	jmp fobj		; yes, it's on the list.
00202F  3               
00202F  3               ;bwid:	.byte 0              ; box/menu width.
00202F  3               ;blen:	.byte 0              ; box/menu height.
00202F  3               ;btop:	.byte 0              ; box coordinates.
00202F  3               ;blft:	.byte 0
00202F  3               .endif
00202F  3               
00202F  3               ;----------------------------------------------------
00202F  3               ; Delay routine 1/50 sec
00202F  3               ;----------------------------------------------------
00202F  3               
00202F  3               delay:
00202F  3  8D 6B 38     	sta frames_delay
002032  3               del_loop:
002032  3  AD 6B 38     	lda frames_delay
002035  3  D0 FB        	bne del_loop
002037  3  60           	rts
002038  3               
002038  3               ;----------------------------------------------------
002038  3               ; Clear sprite table.
002038  3               ;
002038  3               ; sprtab[0] - sprtab[SPRBUF-1] = 255
002038  3               ;----------------------------------------------------
002038  3               
002038  3               xspr:
002038  3  A9 FF        	lda #255		; clear byte.
00203A  3  A2 00        	ldx #0			; length of table.
00203C  3               xspr0:
00203C  3  9D 39 32     	sta sprtab,x		; sprite table.
00203F  3  E8           	inx			; move to next byte.
002040  3  E0 CC        	cpx #SPRBUF
002042  3  D0 F8        	bne xspr0		; repeat for rest of table.
002044  3  60           	rts
002045  3               
002045  3               ;-------------------------------------------------------------
002045  3               ; Initialise all objects.
002045  3               ;
002045  3               ; Reset current room,y,x to start room,y,x for all objects
002045  3               ;-------------------------------------------------------------
002045  3               
002045  3               .if oflag
002045  3               iniob:
002045  3               	lda #<objdta 		; objects table.
002045  3               	sta z80_x
002045  3               	lda #>objdta
002045  3               	sta z80_i
002045  3               
002045  3               	ldx numob 		; number of objects in the game.
002045  3               iniob0:
002045  3               	ldy #35
002045  3               	lda (z80_ix),y 		; start screen.
002045  3               	ldy #32
002045  3               	sta (z80_ix),y 		; set start screen.
002045  3               
002045  3               	ldy #36
002045  3               	lda (z80_ix),y 		; find start y.
002045  3               	ldy #33
002045  3               	sta (z80_ix),y 		; set start y.
002045  3               
002045  3               	ldy #37
002045  3               	lda (z80_ix),y 		; get initial x.
002045  3               	ldy #34
002045  3               	sta (z80_ix),y 		; set x coord.
002045  3               
002045  3               	clc 			; point to next object.
002045  3               	lda z80_x
002045  3               	adc #38			; distance between objects.
002045  3               	sta z80_x
002045  3               	bcc :+
002045  3               	inc z80_i
002045  3               :
002045  3               	dex 			; repeat.
002045  3               	bne iniob0
002045  3               
002045  3               	rts
002045  3               .endif
002045  3               
002045  3               ;-------------------------------------------------------------
002045  3               ; Screen synchronisation.
002045  3               ;
002045  3               ;  - read joystick/keyboard
002045  3               ;  - handle sound
002045  3               ;  - handle shrapnel every even frame
002045  3               ;  - sync framerate to 25 Hz
002045  3               ;-------------------------------------------------------------
002045  3               
002045  3               vsync:
002045  3               
002045  3               ; Save registers
002045  3               
002045  3  48           	pha
002046  3  98           	tya
002047  3  48           	pha
002048  3  8A           	txa
002049  3  48           	pha
00204A  3               
00204A  3               ; Read joystick/keyboard
00204A  3               
00204A  3  20 70 29     	jsr joykey		; read joystick/keyboard.
00204D  3               
00204D  3               ; Handle shrapnel every even frame
00204D  3               
00204D  3  A5 rr        	lda clock
00204F  3  29 01        	and #1
002051  3  D0 03        	bne:+
002053  3  20 D4 20     	jsr proshr		; handle shrapnel every even frame
002056  3               :
002056  3               
002056  3               ; Handle sound
002056  3               
002056  3  AD 6D 20     	lda sndtyp
002059  3  F0 00        	beq sndskip
00205B  3               sndloop:
00205B  3               
00205B  3               sndskip:
00205B  3               
00205B  3               ; Sync framerate to 25 Hz
00205B  3               
00205B  3               check_if_enough_frames_passed:
00205B  3  AD 6A 38     	lda frames_passed
00205E  3  C9 02        	cmp #2
002060  3  90 F9        	bcc check_if_enough_frames_passed
002062  3               
002062  3  A9 00        	lda #0			; sync framerate 25 Hz
002064  3  8D 6A 38     	sta frames_passed
002067  3               
002067  3               ; Restore registers
002067  3               
002067  3  68           	pla
002068  3  AA           	tax
002069  3  68           	pla
00206A  3  A8           	tay
00206B  3  68           	pla
00206C  3  60           	rts
00206D  3               
00206D  3  00           sndtyp:	.byte 0
00206E  3               
00206E  3               ;-----------------------------------------------
00206E  3               ; Redraw the screen.
00206E  3               ;
00206E  3               ; Remove old copy of all sprites for redraw.
00206E  3               ;-----------------------------------------------
00206E  3               
00206E  3               redraw:
00206E  3               .if gflag
00206E  3  A9 FF        	lda #$ff
002070  3  8D 6B 39     	sta andeor
002073  3  A9 00        	lda #$00
002075  3  8D 6C 39     	sta andeor+1
002078  3               .endif
002078  3  A5 69        	lda z80_i 		; place sprite pointer on stack.
00207A  3  48           	pha
00207B  3  A5 68        	lda z80_x
00207D  3  48           	pha
00207E  3               
00207E  3  20 F4 25     	jsr droom		; show screen layout.
002081  3               .if oflag
002081  3               	jsr shwob		; draw objects.
002081  3               .endif
002081  3               numsp0:
002081  3  A9 0C        	lda #NUMSPR		; sprites to draw.
002083  3  85 rr        	sta tmp
002085  3               
002085  3  A9 39        	lda #<sprtab		; sprite table.
002087  3  85 68        	sta z80_x
002089  3  A9 32        	lda #>sprtab
00208B  3  85 69        	sta z80_i
00208D  3               redrw0:
00208D  3  A0 00        	ldy #0
00208F  3  B1 68        	lda (z80_ix),y		; old sprite type.
002091  3  C9 FF        	cmp #255		; is it enabled?
002093  3  F0 0B        	beq redrw1 		; no, find next one.
002095  3               
002095  3  A0 03        	ldy #3
002097  3  B1 68        	lda (z80_ix),y 		; sprite y.
002099  3  C9 B1        	cmp #177		; beyond maximum?
00209B  3  B0 03        	bcs redrw1		; yes, nothing to draw.
00209D  3               
00209D  3  20 02 2D     	jsr sspria		; show single sprite.
0020A0  3               redrw1:
0020A0  3  18           	clc			; next sprite.
0020A1  3  A5 68        	lda z80_x
0020A3  3  69 11        	adc #TABSIZ		; distance to next odd/even entry.
0020A5  3  85 68        	sta z80_x
0020A7  3  90 02        	bcc :+
0020A9  3  E6 69        	inc z80_i
0020AB  3               :
0020AB  3  C6 rr        	dec tmp			; repeat for remaining sprites.
0020AD  3  D0 DE        	bne redrw0
0020AF  3               rpblc1:
0020AF  3               ;	jsr dshrp		; redraw shrapnel.
0020AF  3               
0020AF  3               .if aflag
0020AF  3               	jsr rbloc		; draw blocks for this screen
0020AF  3               .endif
0020AF  3  68           	pla			; retrieve sprite pointer.
0020B0  3  85 68        	sta z80_x
0020B2  3  68           	pla
0020B3  3  85 69        	sta z80_i
0020B5  3               
0020B5  3  60           	rts
0020B6  3               
0020B6  3               ;----------------------------------------------------------------------
0020B6  3               ; Clear screen routine.
0020B6  3               ;
0020B6  3               ; Fill screenmem $e400-$fbff with ScrFillByte
0020B6  3               ;----------------------------------------------------------------------
0020B6  3               
0020B6  3               cls:
0020B6  3  A9 E4        	lda #>ScreenAddr		; screen address.
0020B8  3  8D C4 20     	sta clsloop+2
0020BB  3  A9 00        	lda #ScrFillByte
0020BD  3               .if gflag
0020BD  3  AD 6C 39     	lda andeor+1
0020C0  3               .endif
0020C0  3               .if iflag
0020C0  3               	eor #$ff
0020C0  3               .endif
0020C0  3  A0 00        	ldy #0
0020C2  3               clsloop:
0020C2  3  99 00 E4     	sta ScreenAddr,y
0020C5  3  C8           	iny
0020C6  3  D0 FA        	bne clsloop
0020C8  3  EE C4 20     	inc clsloop+2
0020CB  3  AE C4 20     	ldx clsloop+2
0020CE  3  E0 FC        	cpx #>(ScreenAddr+$1800)
0020D0  3  D0 F0        	bne clsloop
0020D2  3  60           	rts
0020D3  3               
0020D3  3               ;----------------------------------------------------------------------
0020D3  3               ; Atomic palette is static
0020D3  3               ;----------------------------------------------------------------------
0020D3  3               
0020D3  3               setpal:
0020D3  3  60           	rts
0020D4  3               
0020D4  3               ;----------------------------------------------------------------------
0020D4  3               ; FODDER check
0020D4  3               ;----------------------------------------------------------------------
0020D4  3               
0020D4  3               .if pflag .or dflag
0020D4  3               fdchk:
0020D4  3               	cmp #FODDER 		; is it fodder?
0020D4  3               	beq :+
0020D4  3               	rts 			; no.
0020D4  3               :
0020D4  3               	lda #0			; wipe fodder in MAP
0020D4  3               	ldy #0
0020D4  3               	sta (bufaddr),y 	; rewrite block type.
0020D4  3               
0020D4  3               	lda dispx		; x=x/8
0020D4  3               	pha
0020D4  3               	lsr a
0020D4  3               	lsr a
0020D4  3               	lsr a
0020D4  3               	sta dispx
0020D4  3               
0020D4  3               	lda dispy		; y=y/8
0020D4  3               	pha
0020D4  3               	lsr a
0020D4  3               	lsr a
0020D4  3               	lsr a
0020D4  3               	sta dispy
0020D4  3               
0020D4  3               	lda #0 			; block to write.
0020D4  3               	jsr pattr 		; write block.
0020D4  3               
0020D4  3               	pla
0020D4  3               	sta dispy
0020D4  3               	pla
0020D4  3               	sta dispx
0020D4  3               	rts
0020D4  3               .endif
0020D4  3               
0020D4  3               ;----------------------------------------------------
0020D4  3               ; Scrolly text and puzzle variables.
0020D4  3               ;----------------------------------------------------
0020D4  3               
0020D4  3               .if sflag
0020D4  3               txtbit:	.byte 128		; bit to write.
0020D4  3               txtwid:	.byte 16		; width of ticker message.
0020D4  3               txtpos:	.word msgdat
0020D4  3               txtini:	.word msgdat
0020D4  3               txtscr:	.word ScreenAddr
0020D4  3               .endif
0020D4  3               
0020D4  3               ;----------------------------------------------------
0020D4  3               ; Specialist routines.
0020D4  3               ; Process shrapnel.
0020D4  3               ;----------------------------------------------------
0020D4  3               proshr:
0020D4  3               .if pflag
0020D4  3               	lda #<SHRAPN		; table.
0020D4  3               	sta z80_x
0020D4  3               	lda #>SHRAPN
0020D4  3               	sta z80_i
0020D4  3               
0020D4  3               	lda #NUMSHR		; shrapnel pieces to process.
0020D4  3               	sta shrctr
0020D4  3               prosh0:
0020D4  3               	ldy #0
0020D4  3               	lda (z80_ix),y		; on/off marker.
0020D4  3               	asl a
0020D4  3               proshx:
0020D4  3               	bcs :+
0020D4  3               	jsr prosh1 		; on, so process it.
0020D4  3               :
0020D4  3               	clc
0020D4  3               	lda z80_x
0020D4  3               	adc #SHRSIZ
0020D4  3               	sta z80_x
0020D4  3               	bcc :+
0020D4  3               	inc z80_i
0020D4  3               :
0020D4  3               	dec shrctr		; round again.
0020D4  3               	bne prosh0
0020D4  3               .endif
0020D4  3               .if sflag
0020D4  3               	jsr scrly
0020D4  3               .endif
0020D4  3  60           	rts
0020D5  3               
0020D5  3               .if pflag
0020D5  3               ;shrctr:	.byte 0
0020D5  3               
0020D5  3               ;----------------------------------------------------
0020D5  3               ; Proces shrapnel piece
0020D5  3               ;----------------------------------------------------
0020D5  3               
0020D5  3               prosh1:
0020D5  3               	jsr plot 		; delete the pixel.
0020D5  3               
0020D5  3               	lda #<shrptr		; shrapnel routine pointers.
0020D5  3               	sta z80_l
0020D5  3               	lda #>shrptr
0020D5  3               	sta z80_h
0020D5  3               
0020D5  3               	ldy #0
0020D5  3               	lda (z80_ix),y		; restore shrapnel type.
0020D5  3               	jsr prosh2 		; run the routine.
0020D5  3               	jsr chkxy		; check x and y are good before we redisplay.
0020D5  3               
0020D5  3               	lda #<SHRSIZ 		; distance to next.
0020D5  3               	sta z80_e
0020D5  3               	lda #>SHRSIZ
0020D5  3               	sta z80_d
0020D5  3               	rts
0020D5  3               
0020D5  3               ;----------------------------------------------------
0020D5  3               ; Run the routine
0020D5  3               ;----------------------------------------------------
0020D5  3               
0020D5  3               prosh2:
0020D5  3               	asl a 			; 2 bytes per address.
0020D5  3               	tay
0020D5  3               	lda shrptr,y
0020D5  3               	sta z80_l
0020D5  3               	lda shrptr+1,y 		; fetch high byte from table.
0020D5  3               	sta z80_h
0020D5  3               	jmp (z80_hl) 		; jump to routine.
0020D5  3               
0020D5  3               ;----------------------------------------------------
0020D5  3               ; Paricle routine table
0020D5  3               ;----------------------------------------------------
0020D5  3               
0020D5  3               shrptr:	.word laser		; laser.
0020D5  3               	.word trail		; vapour trail.
0020D5  3               	.word shrap		; shrapnel from explosion.
0020D5  3               	.word dotl		; horizontal starfield left.
0020D5  3               	.word dotr		; horizontal starfield right.
0020D5  3               	.word dotu		; vertical starfield up.
0020D5  3               	.word dotd		; vertical starfield down.
0020D5  3               	.word ptcusr		; user particle.
0020D5  3               
0020D5  3               ;----------------------------------------------------
0020D5  3               ; Explosion shrapnel.
0020D5  3               ;----------------------------------------------------
0020D5  3               
0020D5  3               shrap:
0020D5  3               	ldy #1
0020D5  3               	lda (z80_ix),y 		; get the angle.
0020D5  3               	clc
0020D5  3               	adc #<shrsin		; shrapnel sine table.
0020D5  3               	sta z80_l
0020D5  3               	lda #>shrsin
0020D5  3               	adc #0
0020D5  3               	sta z80_h
0020D5  3               
0020D5  3               	ldy #0
0020D5  3               	lda (z80_hl),y 		; fetch value from table.
0020D5  3               	sta z80_e
0020D5  3               	inc z80_l 		; next byte of table.
0020D5  3               	bne :+
0020D5  3               	inc z80_h
0020D5  3               :
0020D5  3               	ldy #0
0020D5  3               	lda (z80_hl),y		; fetch value from table.
0020D5  3               	sta z80_d
0020D5  3               	inc z80_l		; next byte of table.
0020D5  3               	bne :+
0020D5  3               	inc z80_h
0020D5  3               :
0020D5  3               	ldy #0
0020D5  3               	lda (z80_hl),y 		; fetch value from table.
0020D5  3               	sta z80_c
0020D5  3               	inc z80_l 		; next byte of table.
0020D5  3               	bne :+
0020D5  3               	inc z80_h
0020D5  3               :
0020D5  3               	ldy #0
0020D5  3               	lda (z80_hl),y 		; fetch value from table.
0020D5  3               	sta z80_b
0020D5  3               
0020D5  3               	ldy #2
0020D5  3               	lda (z80_ix),y 		; x coordinate in hl.
0020D5  3               	clc
0020D5  3               	adc z80_e		; add sine lb
0020D5  3               	sta (z80_ix),y		; store new coordinate lb.
0020D5  3               	ldy #3
0020D5  3               	lda (z80_ix),y
0020D5  3               	adc z80_d		; add sine hb
0020D5  3               	sta (z80_ix),y		; store new coordinate hb.
0020D5  3               
0020D5  3               	ldy #4
0020D5  3               	lda (z80_ix),y	 	; y coordinate in hl.
0020D5  3               	clc
0020D5  3               	adc z80_c		; add cosine lb
0020D5  3               	sta (z80_ix),y		; store new coordinate lb.
0020D5  3               	ldy #5
0020D5  3               	lda (z80_ix),y
0020D5  3               	adc z80_b		; add cosine lb
0020D5  3               	sta (z80_ix),y		; store new coordinate hb.
0020D5  3               
0020D5  3               	rts
0020D5  3               
0020D5  3               ;----------------------------------------------------
0020D5  3               ; Move dots
0020D5  3               ;----------------------------------------------------
0020D5  3               
0020D5  3               dotl:
0020D5  3               	ldy #5
0020D5  3               	lda (z80_ix),y
0020D5  3               	sec
0020D5  3               	sbc #1		 	; move left.
0020D5  3               	sta (z80_ix),y
0020D5  3               	rts
0020D5  3               dotr:
0020D5  3               	ldy #5
0020D5  3               	lda (z80_ix),y
0020D5  3               	clc
0020D5  3               	adc #1		 	; move left.
0020D5  3               	sta (z80_ix),y
0020D5  3               	rts
0020D5  3               dotu:
0020D5  3               	ldy #3
0020D5  3               	lda (z80_ix),y
0020D5  3               	sec
0020D5  3               	sbc #1		 	; move up.
0020D5  3               	sta (z80_ix),y
0020D5  3               	rts
0020D5  3               dotd:
0020D5  3               	ldy #3
0020D5  3               	lda (z80_ix),y
0020D5  3               	clc
0020D5  3               	adc #1			; move down.
0020D5  3               	sta (z80_ix),y
0020D5  3               	rts
0020D5  3               
0020D5  3               ;----------------------------------------------------
0020D5  3               ; Check if coordinates are ok before redrawing at new position.
0020D5  3               ;
0020D5  3               ; left:   X>L		X=L	Ok
0020D5  3               ; right:  R+15>X	X=R	Ok
0020D5  3               ; top:    Y>T		Y=T	Ok
0020D5  3               ; bottom: B+15>Y	Y=B	Ok
0020D5  3               ;----------------------------------------------------
0020D5  3               
0020D5  3               chkxy:
0020D5  3               
0020D5  3               ; top:    Y>T		Y=T	Ok
0020D5  3               
0020D5  3               	ldy #3
0020D5  3               	lda (z80_ix),y	 	; fetch shrapnel coordinate.
0020D5  3               	cmp wntopx		; window top.
0020D5  3               	bcs :+			; compare with top window limit.
0020D5  3               	jmp kilshr		; out of window, kill shrapnel.
0020D5  3               :
0020D5  3               ; left:   X>L		X=L	Ok
0020D5  3               
0020D5  3               	ldy #5
0020D5  3               	lda (z80_ix),y	 	; fetch shrapnel coordinate.
0020D5  3               	cmp wnlftx		; left edge.
0020D5  3               	bcs :+			; compare with left window limit.
0020D5  3               	jmp kilshr		; out of window, kill shrapnel.
0020D5  3               :
0020D5  3               ; bottom: B+15>Y	Y=B	Ok
0020D5  3               
0020D5  3               	lda wnbotx		; point to bottom.
0020D5  3               	clc
0020D5  3               	adc #15
0020D5  3               	ldy #3
0020D5  3               	cmp (z80_ix),y	 	; fetch shrapnel coordinate.
0020D5  3               	bcs :+			; compare with shrapnel x coordinate.
0020D5  3               	jmp kilshr		; off screen, kill shrapnel..
0020D5  3               :
0020D5  3               ; right:  R+15>X	X=R	Ok
0020D5  3               
0020D5  3               	lda wnrgtx		; point to right edge.
0020D5  3               	clc
0020D5  3               	adc #15
0020D5  3               	ldy #5
0020D5  3               	cmp (z80_ix),y	 	; fetch shrapnel coordinate.
0020D5  3               	bcs :+			; compare with window limit.
0020D5  3               	jmp kilshr		; off screen, kill shrapnel.
0020D5  3               :
0020D5  3               
0020D5  3               ;----------------------------------------------------
0020D5  3               ; Drop through.
0020D5  3               ; Display shrapnel.
0020D5  3               ;----------------------------------------------------
0020D5  3               
0020D5  3               plot:
0020D5  3               	ldy #3
0020D5  3               	lda (z80_ix),y		; y integer.
0020D5  3               	sta dispy	 	; workspace coordinates.
0020D5  3               	ldy #5
0020D5  3               	lda (z80_ix),y	 	; x integer.
0020D5  3               	sta dispx 		; workspace coordinates.
0020D5  3               
0020D5  3               	ldy #0
0020D5  3               	lda (z80_ix),y 		; type.
0020D5  3               	bne :+			; is it a laser?
0020D5  3               	jmp plot1 		; yes, draw laser instead.
0020D5  3               :
0020D5  3               plot0:
0020D5  3               	lda dispx		; which pixel within byte do we
0020D5  3               	and #7			; want to set first?
0020D5  3               	tay
0020D5  3               	lda dots,y 		; table of small pixel positions.
0020D5  3               	sta z80_e 		; get value.
0020D5  3               
0020D5  3               	jsr scadd 		; screen address.
0020D5  3               	ldy #0
0020D5  3               	lda (scraddr),y		; see what's already there.
0020D5  3               	eor z80_e
0020D5  3               	sta (scraddr),y 	; put back on screen.
0020D5  3               	rts
0020D5  3               
0020D5  3               plot1:
0020D5  3               	jsr scadd 		; screen address.
0020D5  3               	ldy #0
0020D5  3               	lda (scraddr),y 	; fetch byte there.
0020D5  3               	eor #255 		; toggle all bits.
0020D5  3               	sta (scraddr),y 	; new byte.
0020D5  3               	rts
0020D5  3               
0020D5  3               ;----------------------------------------------------
0020D5  3               ; Switch off shrapnel
0020D5  3               ;----------------------------------------------------
0020D5  3               
0020D5  3               kilshr:
0020D5  3               	lda #128
0020D5  3               	ldy #0
0020D5  3               	sta (z80_ix),y	; switch off shrapnel.
0020D5  3               	rts
0020D5  3               
0020D5  3               ;----------------------------------------------------
0020D5  3               ; Sine/cosine table
0020D5  3               ;----------------------------------------------------
0020D5  3               
0020D5  3               shrsin:	.word 0,1024,391,946,724,724,946,391
0020D5  3               	.word 1024,0,946,65144,724,64811,391,64589
0020D5  3               	.word 0,64512,65144,64589,64811,64811,64589,65144
0020D5  3               	.word 64512,0,64589,391,64811,724,65144,946
0020D5  3               
0020D5  3               ;----------------------------------------------------
0020D5  3               ; Create trail
0020D5  3               ;----------------------------------------------------
0020D5  3               
0020D5  3               trail:
0020D5  3               	ldy #1
0020D5  3               	lda (z80_ix),y 	; time remaining.
0020D5  3               	sec
0020D5  3               	sbc #1
0020D5  3               	sta (z80_ix),y
0020D5  3               	bne :+
0020D5  3               	jmp trailk		; time to switch it off.
0020D5  3               :
0020D5  3               	jsr qrand		; get a random number.
0020D5  3               	lsr a 			; x or y axis?
0020D5  3               	bcc :+
0020D5  3               	jmp trailv		; use y.
0020D5  3               :
0020D5  3               ; Trail horizontal
0020D5  3               
0020D5  3               	lsr a 			; which direction?
0020D5  3               	bcc :+
0020D5  3               	jmp traill		; go left.
0020D5  3               :
0020D5  3               ; Trail right
0020D5  3               
0020D5  3               	ldy #5
0020D5  3               	lda (z80_ix),y
0020D5  3               	clc
0020D5  3               	adc #1	 		; go right.
0020D5  3               	sta (z80_ix),y
0020D5  3               	rts
0020D5  3               
0020D5  3               ; Trail left
0020D5  3               
0020D5  3               traill:
0020D5  3               	ldy #5
0020D5  3               	lda (z80_ix),y
0020D5  3               	sec
0020D5  3               	sbc #1 			; go left.
0020D5  3               	sta (z80_ix),y
0020D5  3               	rts
0020D5  3               
0020D5  3               ; Trail vertical
0020D5  3               
0020D5  3               trailv:
0020D5  3               	lsr a		 	; which direction?
0020D5  3               	bcc :+
0020D5  3               	jmp trailu		; go up.
0020D5  3               :
0020D5  3               ; Trail down
0020D5  3               
0020D5  3               	ldy #3
0020D5  3               	lda (z80_ix),y
0020D5  3               	clc
0020D5  3               	adc #1 			; go down.
0020D5  3               	sta (z80_ix),y
0020D5  3               	rts
0020D5  3               
0020D5  3               ; Trail up
0020D5  3               
0020D5  3               trailu:
0020D5  3               	ldy #3
0020D5  3               	lda (z80_ix),y
0020D5  3               	sec
0020D5  3               	sbc #1 			; go up.
0020D5  3               	sta (z80_ix),y
0020D5  3               	rts
0020D5  3               
0020D5  3               ; Kill trail
0020D5  3               
0020D5  3               trailk:
0020D5  3               	lda #200		; set off-screen to kill vapour trail.
0020D5  3               	ldy #3
0020D5  3               	sta (z80_ix),y
0020D5  3               	rts
0020D5  3               
0020D5  3               ;----------------------------------------------------
0020D5  3               ; Create laser beam
0020D5  3               ;----------------------------------------------------
0020D5  3               
0020D5  3               laser:
0020D5  3               	ldy #1
0020D5  3               	lda (z80_ix),y 		; direction.
0020D5  3               	ror a 			; left or right?
0020D5  3               	bcc :+
0020D5  3               	jmp laserl		; move left.
0020D5  3               :
0020D5  3               ; Laser right
0020D5  3               
0020D5  3               	lda #8			; distance to travel.
0020D5  3               	sta z80_b
0020D5  3               	jmp laserm		; move laser.
0020D5  3               
0020D5  3               ; Laser left
0020D5  3               
0020D5  3               laserl:
0020D5  3               	lda #248		; distance to travel.
0020D5  3               	sta z80_b
0020D5  3               laserm:
0020D5  3               	ldy #5
0020D5  3               	lda (z80_ix),y		; x position.
0020D5  3               	clc
0020D5  3               	adc z80_b		; add distance.
0020D5  3               	sta (z80_ix),y		; set new x coordinate.
0020D5  3               
0020D5  3               ; Test new block.
0020D5  3               
0020D5  3               	sta dispx 		; set x for block collision detection purposes.
0020D5  3               	ldy #3
0020D5  3               	lda (z80_ix),y 		; get y.
0020D5  3               	sta dispy		; set coordinate for collision test.
0020D5  3               	jsr tstbl 		; get block type there.
0020D5  3               	cmp #WALL		; is it solid?
0020D5  3               	bne :+
0020D5  3               	jmp trailk		; yes, it cannot pass.
0020D5  3               :
0020D5  3               .if pflag .or dflag
0020D5  3                       cmp #FODDER             ; is it fodder?
0020D5  3                       bne :+
0020D5  3                       jsr fdchk               ; remove fodder block.
0020D5  3                       jmp trailk              ; destroy laser.
0020D5  3               :
0020D5  3               .endif
0020D5  3                       rts                     ; no, ignore it.
0020D5  3               
0020D5  3               ;----------------------------------------------------
0020D5  3               ; Dots mask
0020D5  3               ;----------------------------------------------------
0020D5  3               
0020D5  3               dots:	.byte 128,64,32,16,8,4,2,1
0020D5  3               
0020D5  3               
0020D5  3               ;----------------------------------------------------
0020D5  3               ; Plot, preserving de.
0020D5  3               ;----------------------------------------------------
0020D5  3               
0020D5  3               plotde:
0020D5  3               	lda z80_d 		; put de on stack.
0020D5  3               	pha
0020D5  3               	lda z80_e
0020D5  3               	pha
0020D5  3               
0020D5  3               	jsr plot 		; plot pixel.
0020D5  3               
0020D5  3               	pla			; restore de from stack.
0020D5  3               	sta z80_e
0020D5  3               	pla
0020D5  3               	sta z80_d
0020D5  3               
0020D5  3               	rts
0020D5  3               
0020D5  3               ;----------------------------------------------------
0020D5  3               ; Shoot a laser.
0020D5  3               ;----------------------------------------------------
0020D5  3               
0020D5  3               shoot:
0020D5  3               	sta z80_c		; store direction in c register.
0020D5  3               	ldy #8
0020D5  3               	lda (z80_ix),y 		; y coordinate.
0020D5  3               	clc
0020D5  3               shoot1:
0020D5  3               	adc #(SPR_HGT/2-1)	; down 7 pixels.
0020D5  3               	sta z80_l 		; puty y coordinate in l.
0020D5  3               
0020D5  3               	ldy #9
0020D5  3               	lda (z80_ix),y 		; x coordinate in h.
0020D5  3               	sta z80_h
0020D5  3               
0020D5  3               	lda z80_i		; store pointer to sprite.
0020D5  3               	pha
0020D5  3               	lda z80_x
0020D5  3               	pha
0020D5  3               
0020D5  3               	jsr fpslot 		; find particle slot.
0020D5  3               	bcs :+
0020D5  3               	jmp vapou2		; failed, restore ix.
0020D5  3               :
0020D5  3               	lda #0
0020D5  3               	ldy #0
0020D5  3               	sta (z80_ix),y 		; set up a laser.
0020D5  3               
0020D5  3               	lda z80_c
0020D5  3               	ldy #1
0020D5  3               	sta (z80_ix),y 		; set the direction.
0020D5  3               
0020D5  3               	lda z80_l
0020D5  3               	ldy #3
0020D5  3               	sta (z80_ix),y		; set y coordinate.
0020D5  3               
0020D5  3               	ror z80_c		; check direction we want.
0020D5  3               	bcc :+
0020D5  3               	jmp shootr		; shoot right.
0020D5  3               :
0020D5  3               	lda z80_h		; X position.
0020D5  3               shoot0:
0020D5  3               	and #248		; align on character boundary.
0020D5  3               	ldy #5
0020D5  3               	sta (z80_ix),y		; set x coordinate.
0020D5  3               	jmp vapou0 		; draw first image.
0020D5  3               shootr:
0020D5  3               	lda z80_h		; x position.
0020D5  3               	clc
0020D5  3               	adc #15			; look right.
0020D5  3               	jmp shoot0		; align and continue.
0020D5  3               
0020D5  3               ;----------------------------------------------------
0020D5  3               ; Create a bit of vapour trail.
0020D5  3               ;----------------------------------------------------
0020D5  3               
0020D5  3               vapour:
0020D5  3               	lda z80_i		; store pointer to sprite.
0020D5  3               	pha
0020D5  3               	lda z80_x
0020D5  3               	pha
0020D5  3               
0020D5  3               	ldy #8
0020D5  3               	lda (z80_ix),y 		; y coordinate.
0020D5  3               	clc
0020D5  3               vapou3:
0020D5  3               	adc #(SPR_HGT/2-1)	; mid-point of sprite.
0020D5  3               	sta z80_l
0020D5  3               
0020D5  3               	ldy #9
0020D5  3               	lda (z80_ix),y 		; x coordinate.
0020D5  3               	adc #7
0020D5  3               	sta z80_h
0020D5  3               
0020D5  3               	jsr fpslot 		; find particle slot.
0020D5  3               	bcc :+
0020D5  3               	jmp vapou1		; no, we can use it.
0020D5  3               :
0020D5  3               vapou2:
0020D5  3               	pla
0020D5  3               	sta z80_x
0020D5  3               	pla
0020D5  3               	sta z80_i
0020D5  3               	rts
0020D5  3               vapou1:
0020D5  3               	lda z80_l
0020D5  3               	ldy #3
0020D5  3               	sta (z80_ix),y		; set up y.
0020D5  3               
0020D5  3               	lda z80_h
0020D5  3               	ldy #5
0020D5  3               	sta (z80_ix),y 		; set up x coordinate.
0020D5  3               
0020D5  3               	jsr qrand		; get quick random number.
0020D5  3               	and #15			; random time.
0020D5  3               	clc
0020D5  3               	adc #15			; minimum time on screen.
0020D5  3               	ldy #1
0020D5  3               	sta (z80_ix),y		; set time on screen.
0020D5  3               
0020D5  3               	lda #1
0020D5  3               	ldy #0
0020D5  3               	sta (z80_ix),y		; define particle as vapour trail.
0020D5  3               vapou0:
0020D5  3               	jsr chkxy		; plot first position.
0020D5  3               	jmp vapou2
0020D5  3               
0020D5  3               ;----------------------------------------------------
0020D5  3               ; Create a user particle.
0020D5  3               ;----------------------------------------------------
0020D5  3               
0020D5  3               ptusr:
0020D5  3               	sta z80_f		; store timer.
0020D5  3               
0020D5  3               	ldy #8
0020D5  3               	lda (z80_ix),y 		; y coordinate.
0020D5  3               	clc
0020D5  3               	adc #7			; mid-point of sprite.
0020D5  3               	sta z80_l
0020D5  3               
0020D5  3               	ldy #9
0020D5  3               	lda (z80_ix),y 		; x coordinate.
0020D5  3               	clc
0020D5  3               	adc #7			; mid-point of sprite.
0020D5  3               	sta z80_h
0020D5  3               
0020D5  3               	jsr fpslot 		; find particle slot.
0020D5  3               	bcs ptusr1
0020D5  3               	rts 			; out of slots, can't generate anything.
0020D5  3               ptusr1:
0020D5  3               	lda z80_l
0020D5  3               	ldy #3
0020D5  3               	sta (z80_ix),y 		; set up y.
0020D5  3               
0020D5  3               	lda z80_h
0020D5  3               	ldy #5
0020D5  3               	sta (z80_ix),y		; set up x coordinate.
0020D5  3               
0020D5  3               	lda z80_f 		; restore timer.
0020D5  3               	ldy #1
0020D5  3               	sta (z80_ix),y		; set time on screen.
0020D5  3               
0020D5  3               	lda #7
0020D5  3               	ldy #0
0020D5  3               	sta (z80_ix),y		; define particle as user particle.
0020D5  3               
0020D5  3               	jmp chkxy		; plot first position.
0020D5  3               
0020D5  3               ;----------------------------------------------------
0020D5  3               ; Create a vertical or horizontal star.
0020D5  3               ;----------------------------------------------------
0020D5  3               
0020D5  3               star:
0020D5  3               	lda z80_i		; store pointer to sprite.
0020D5  3               	pha
0020D5  3               	lda z80_x
0020D5  3               	pha
0020D5  3               
0020D5  3               	jsr fpslot 		; find particle slot.
0020D5  3               	bcs star7		; found one we can use.
0020D5  3               star0:
0020D5  3               	pla 			; restore sprite pointer.
0020D5  3               	sta z80_x
0020D5  3               	pla
0020D5  3               	sta z80_i
0020D5  3               	rts 			; out of slots, can't generate anything.
0020D5  3               star7:
0020D5  3               	lda z80_c		; direction.
0020D5  3               	and #3 			; is it left?
0020D5  3               	bne :+
0020D5  3               	jmp star1 		; yes, it's left.
0020D5  3               :
0020D5  3               	cmp #1 			; is it right?
0020D5  3               	bne :+
0020D5  3               	jmp star2 		; yes, it's right.
0020D5  3               :
0020D5  3               	cmp #2 			; is it up?
0020D5  3               	bne :+
0020D5  3               	jmp star3 		; yes, it's up.
0020D5  3               :
0020D5  3               	ldy wntopx 		; get edge of screen.
0020D5  3               	iny			; down one pixel.
0020D5  3               	tya
0020D5  3               star8:
0020D5  3               	ldy #3
0020D5  3               	sta (z80_ix),y 		; set y coord.
0020D5  3               	jsr qrand 		; get quick random number.
0020D5  3               star9:
0020D5  3               	ldy #5
0020D5  3               	sta (z80_ix),y		; set x position.
0020D5  3               
0020D5  3               	lda z80_c		; direction.
0020D5  3               	and #3			; zero to three.
0020D5  3               	clc
0020D5  3               	adc #3			; 3 to 6 for starfield.
0020D5  3               	ldy #0
0020D5  3               	sta (z80_ix),y		; define particle as star.
0020D5  3               	jsr chkxy		; plot first position.
0020D5  3               	jmp star0
0020D5  3               star1:
0020D5  3               	jsr qrand		; get quick random number.
0020D5  3               	ldy #3
0020D5  3               	sta (z80_ix),y 		; set y coord.
0020D5  3               
0020D5  3               	lda wnrgtx 		; get edge of screen.
0020D5  3               	clc
0020D5  3               	adc #15			; add width of sprite minus 1.
0020D5  3               	jmp star9
0020D5  3               star2:
0020D5  3               	jsr qrand 		; get quick random number.
0020D5  3               	ldy #3
0020D5  3               	sta (z80_ix),y		; set y coord.
0020D5  3               
0020D5  3               	lda wnlftx		; get edge of screen.
0020D5  3               	jmp star9
0020D5  3               star3:
0020D5  3               	lda wnbotx 		; get edge of screen.
0020D5  3               	clc
0020D5  3               	adc #15 		; height of sprite minus one pixel.
0020D5  3               	jmp star8
0020D5  3               
0020D5  3               ;----------------------------------------------------
0020D5  3               ; Find particle slot for lasers or vapour trail.
0020D5  3               ; can't use alternate accumulator.
0020D5  3               ;----------------------------------------------------
0020D5  3               
0020D5  3               fpslot:
0020D5  3               	lda #<SHRAPN 		; shrapnel table.
0020D5  3               	sta z80_x
0020D5  3               	lda #>SHRAPN
0020D5  3               	sta z80_i
0020D5  3               
0020D5  3               	lda #NUMSHR		; number of pieces in table.
0020D5  3               	sta z80_b
0020D5  3               fpslt0:
0020D5  3               	ldy #0
0020D5  3               	lda (z80_ix),y		; get type.
0020D5  3               	asl a  			; is this slot in use?
0020D5  3               	bcc :+
0020D5  3               	rts			; no, we can use it.
0020D5  3               :
0020D5  3               	clc			; point to more shrapnel.
0020D5  3               	lda z80_x
0020D5  3               	adc #SHRSIZ
0020D5  3               	sta z80_x
0020D5  3               	bcc :+
0020D5  3               	inc z80_i
0020D5  3               :
0020D5  3               	dec z80_b		; repeat for all shrapnel.
0020D5  3               	bne fpslt0
0020D5  3               
0020D5  3               	clc
0020D5  3               	rts 			; out of slots, can't generate anything.
0020D5  3               
0020D5  3               ;----------------------------------------------------
0020D5  3               ; Create an explosion at sprite position.
0020D5  3               ;----------------------------------------------------
0020D5  3               
0020D5  3               explod:
0020D5  3               	sta z80_c 		; particles to create.
0020D5  3               
0020D5  3               	lda z80_i 		; store pointer to sprite.
0020D5  3               	pha
0020D5  3               	lda z80_x
0020D5  3               	pha
0020D5  3               
0020D5  3               	ldy #8
0020D5  3               	lda (z80_ix),y 		; y coordinate.
0020D5  3               	sta z80_l
0020D5  3               	ldy #9
0020D5  3               	lda (z80_ix),y		; x coordinate.
0020D5  3               	sta z80_h
0020D5  3               
0020D5  3               	lda #<SHRAPN		; shrapnel table.
0020D5  3               	sta z80_x
0020D5  3               	lda #>SHRAPN
0020D5  3               	sta z80_i
0020D5  3               
0020D5  3               	lda #NUMSHR		; number of pieces in table.
0020D5  3               	sta explcnt
0020D5  3               expld0:
0020D5  3               	ldy #0
0020D5  3               	lda (z80_ix),y		; get type.
0020D5  3               	asl a 			; is this slot in use?
0020D5  3               	bcs expld1		; no, we can use it.
0020D5  3               expld2:
0020D5  3               	clc
0020D5  3               	lda z80_x
0020D5  3               	adc #SHRSIZ
0020D5  3               	sta z80_x
0020D5  3               	bcc :+
0020D5  3               	inc z80_i
0020D5  3               :
0020D5  3               	dec explcnt		; repeat for all shrapnel.
0020D5  3               	bne expld0
0020D5  3               expld3:
0020D5  3               	pla			; restore sprite pointer.
0020D5  3               	sta z80_x
0020D5  3               	pla
0020D5  3               	sta z80_i
0020D5  3               	rts 			; out of slots, can't generate any more.
0020D5  3               
0020D5  3               expld1:
0020D5  3               	lda z80_c		; shrapnel counter.
0020D5  3               	and #15			; 0 to 15.
0020D5  3               	clc			; add to x.
0020D5  3               	adc z80_l
0020D5  3               	ldy #3
0020D5  3               	sta (z80_ix),y		; y coord.
0020D5  3               
0020D5  3               	lda seed3 		; crap random number.
0020D5  3               	and #15			; 0 to 15.
0020D5  3               	clc 			; add to y.
0020D5  3               	adc z80_h
0020D5  3               	ldy #5
0020D5  3               	sta (z80_ix),y		; x coord.
0020D5  3               
0020D5  3               	lda #2
0020D5  3               	ldy #0
0020D5  3               	sta (z80_ix),y		; switch it on.
0020D5  3               
0020D5  3               	jsr chkxy		; plot first position.
0020D5  3               	jsr qrand		; quick random angle.
0020D5  3               	and #60 		; keep within range.
0020D5  3               	ldy #1
0020D5  3               	sta (z80_ix),y		; angle.
0020D5  3               
0020D5  3               	dec z80_c		; one less piece of shrapnel to generate.
0020D5  3               	bne expld2 		; back to main explosion loop.
0020D5  3               	jmp expld3 		; restore sprite pointer and exit.
0020D5  3               
0020D5  3               ;explcnt:	.byte 0
0020D5  3               
0020D5  3               ;----------------------------------------------------
0020D5  3               ; Quick random
0020D5  3               ;----------------------------------------------------
0020D5  3               
0020D5  3               qrand:
0020D5  3               	jsr random		; r register.
0020D5  3               	eor seed3		; combine with seed.
0020D5  3               	sta seed3 		; new seed.
0020D5  3               	rts
0020D5  3               
0020D5  3               ;seed3:	.byte 0
0020D5  3               
0020D5  3               ;----------------------------------------------------
0020D5  3               ; Display all shrapnel.
0020D5  3               ;----------------------------------------------------
0020D5  3               
0020D5  3               dshrp:
0020D5  3               	lda #<plotde		; display routine.
0020D5  3               	sta proshx+1
0020D5  3               	lda #>plotde
0020D5  3               	sta proshx+2
0020D5  3               	jsr proshr		; process shrapnel.
0020D5  3               
0020D5  3               	lda #<prosh1		; processing routine.
0020D5  3               	sta proshx+1
0020D5  3               	lda #>prosh1
0020D5  3               	sta proshx+2
0020D5  3               	rts
0020D5  3               
0020D5  3               ;------------------------------------------------------
0020D5  3               ; Particle engine.
0020D5  3               ;
0020D5  3               ; Init particle data for 55 particles in SHRAPN table.
0020D5  3               ; Every particle has 6 bytes.
0020D5  3               ;
0020D5  3               ; global:	-
0020D5  3               ; local:	x,y,hl
0020D5  3               ; calls:	-
0020D5  3               ;------------------------------------------------------
0020D5  3               
0020D5  3               inishr:
0020D5  3               	lda #<SHRAPN 		; table.
0020D5  3               	sta z80_l
0020D5  3               	lda #>SHRAPN
0020D5  3               	sta z80_h
0020D5  3               
0020D5  3               	ldy #0
0020D5  3               	ldx #NUMSHR		; shrapnel pieces to process.
0020D5  3               inish0:
0020D5  3               	lda #255 		; kill the shrapnel.
0020D5  3               	sta (z80_hl),y
0020D5  3               
0020D5  3               	clc 			; point there.
0020D5  3               	lda z80_l
0020D5  3               	adc #SHRSIZ		; distance to next.
0020D5  3               	sta z80_l
0020D5  3               	bcc :+
0020D5  3               	inc z80_h
0020D5  3               :
0020D5  3               	dex
0020D5  3               	bne inish0 		; round again.
0020D5  3               	rts
0020D5  3               
0020D5  3               ;------------------------------------------------------
0020D5  3               ; Check for collision between laser and sprite.
0020D5  3               ;------------------------------------------------------
0020D5  3               
0020D5  3               lcol:
0020D5  3               	lda #<SHRAPN		; shrapnel table.
0020D5  3               	sta z80_l
0020D5  3               	lda #>SHRAPN
0020D5  3               	sta z80_h
0020D5  3               
0020D5  3               	lda #NUMSHR		; number of pieces in table.
0020D5  3               	sta z80_b
0020D5  3               lcol0:
0020D5  3               	ldy #0
0020D5  3               	lda (z80_hl),y 		; get type.
0020D5  3               	beq lcol1		; yes, check collision.
0020D5  3               lcol3:
0020D5  3               	clc			; point to more shrapnel.
0020D5  3               	lda z80_l
0020D5  3               	adc #SHRSIZ
0020D5  3               	sta z80_l
0020D5  3               	bcc :+
0020D5  3               	inc z80_h
0020D5  3               :
0020D5  3               	dec z80_b		; repeat for all shrapnel.
0020D5  3               	bne lcol0
0020D5  3               	rts 			; no collision, carry not set.
0020D5  3               lcol1:
0020D5  3               	ldy #3
0020D5  3               	lda (z80_hl),y		; get y.
0020D5  3               	sec
0020D5  3               	ldy #8
0020D5  3               	sbc (z80_ix),y		; subtract sprite y.
0020D5  3               lcolh:
0020D5  3               	cmp #SPR_HGT 		; within range?
0020D5  3               	bcc :+
0020D5  3               	jmp lcol2		; no, missed.
0020D5  3               :
0020D5  3               	ldy #5
0020D5  3               	lda (z80_hl),y 		; get x.
0020D5  3               	sec
0020D5  3               	ldy #9
0020D5  3               	sbc (z80_ix),y 		; subtract sprite y.
0020D5  3               	cmp #16			; within range?
0020D5  3               	bcs :+
0020D5  3               	jmp lcol4 		; yes, collision occurred.
0020D5  3               :
0020D5  3               lcol2:
0020D5  3               	jmp lcol3
0020D5  3               lcol4:
0020D5  3               	sec
0020D5  3               	rts 			; return with carry set for collision.
0020D5  3               .endif
0020D5  3               
0020D5  3               ;------------------------------------------------------
0020D5  3               ; Main game engine code starts here.
0020D5  3               ; After initialisation, mloop is the main loop
0020D5  3               ;------------------------------------------------------
0020D5  3               
0020D5  3               game:
0020D5  3               
0020D5  3               ; Set up screen address table.
0020D5  3               
0020D5  3               setsat:
0020D5  3  A9 00        	lda #<ScreenAddr		; start of screen.
0020D7  3  85 rr        	sta scraddr
0020D9  3  A9 E4        	lda #>ScreenAddr
0020DB  3  85 rr        	sta scraddr+1
0020DD  3               
0020DD  3  A0 00        	ldy #0			; vertical lines on screen.
0020DF  3               setsa0:
0020DF  3  A5 rr        	lda scraddr
0020E1  3  99 00 E0     	sta SCADTB_lb,y		; write low byte.
0020E4  3  A5 rr        	lda scraddr+1
0020E6  3  C0 C0        	cpy #192		; vertical lines on screen.
0020E8  3  90 02        	bcc :+
0020EA  3  09 F0        	ora #$F0		; plot sprites in rom if of screen
0020EC  3               :
0020EC  3  99 00 E1     	sta SCADTB_hb,y		; write high byte.
0020EF  3  20 EB 2D     	jsr nline		; next line down.
0020F2  3  C8           	iny			; next position in table.
0020F3  3  D0 EA        	bne setsa0
0020F5  3               
0020F5  3               ; Init graphics mode
0020F5  3               
0020F5  3  A9 F0        	lda #ScrMode		; graphics mode
0020F7  3  8D 00 B0     	sta ScrSelAddr 		; screen selection address
0020FA  3  20 D3 20     	jsr setpal 		; set up palette.
0020FD  3               
0020FD  3               ; Init AtoMMC joystick
0020FD  3  20 E3 38     	jsr joyinit		; AtoMMC joystick on PORT B
002100  3               
002100  3               rpblc2:
002100  3               .if pflag
002100  3               	jsr inishr 		; initialise particle engine.
002100  3               .endif
002100  3               evintr:
002100  3  20 D2 33     	jsr evnt12 		; call intro/menu event.
002103  3               
002103  3  A9 02        	lda #WALL 		; write default property.
002105  3  A2 00        	ldx #0
002107  3               clrmap:
002107  3  9D 00 DD     	sta MAP,x 		; block properties.
00210A  3  9D 00 DE     	sta MAP+256,x
00210D  3  9D 00 DF     	sta MAP+512,x
002110  3  E8           	inx			; next byte.
002111  3  D0 F4        	bne clrmap
002113  3               .if oflag
002113  3               	jsr iniob 		; initialise objects.
002113  3               .endif
002113  3  A9 00        	lda #0			; put zero in accumulator.
002115  3  85 rr        	sta gamwon		; reset game won flag.
002117  3               
002117  3  20 80 22     	jsr inisc 		; init the score.
00211A  3               mapst:
00211A  3  AD 22 33     	lda stmap 		; start position on map.
00211D  3  8D 16 33     	sta roomtb		; set up position in table, if there is one.
002120  3               
002120  3               inipbl:
002120  3               .if aflag
002120  3               	lda #<eop		; reset blockpointer
002120  3               	sta pbptr
002120  3               	lda #>eop
002120  3               	sta pbptr+1
002120  3               .endif
002120  3  20 FE 2E     	jsr initsc 		; set up first screen.
002123  3               
002123  3  A9 05        	lda #<ssprit 		; default to spare sprite in table.
002125  3  85 68        	sta z80_x
002127  3  A9 33        	lda #>ssprit
002129  3  85 69        	sta z80_i
00212B  3               evini:
00212B  3  20 04 34     	jsr evnt13 		; initialisation.
00212E  3               
00212E  3               ; Two restarts.
00212E  3               ; First restart - clear all sprites and initialise everything.
00212E  3               
00212E  3               rstrt:
00212E  3  20 20 22     	jsr rsevt 		; restart events.
002131  3  20 38 20     	jsr xspr 		; clear sprite table.
002134  3  20 6A 30     	jsr sprlst 		; fetch pointer to screen sprites.
002137  3  20 F3 30     	jsr ispr 		; initialise sprite table.
00213A  3               
00213A  3  4C 49 21     	jmp rstrt0
00213D  3               
00213D  3               ; Second restart - clear all but player, and don't initialise him.
00213D  3               
00213D  3               rstrtn:
00213D  3  20 20 22     	jsr rsevt		; restart events.
002140  3  20 97 30     	jsr nspr 		; clear all non-player sprites.
002143  3  20 6A 30     	jsr sprlst 		; fetch pointer to screen sprites.
002146  3  20 30 31     	jsr kspr 		; initialise sprite table, no more players.
002149  3               
002149  3               ; Set up the player and/or enemy sprites.
002149  3               
002149  3               rstrt0:
002149  3  A9 00        	lda #0 			; zero in accumulator.
00214B  3  85 rr        	sta nexlev 		; reset next level flag.
00214D  3  85 rr        	sta restfl 		; reset restart flag.
00214F  3  85 rr        	sta deadf 		; reset dead flag.
002151  3  20 F4 25     	jsr droom 		; show screen layout.
002154  3               rpblc0:
002154  3               .if pflag
002154  3               	jsr inishr 		; initialise particle engine.
002154  3               .endif
002154  3               .if aflag
002154  3               	jsr rbloc		; draw blocks for this screen
002154  3               .endif
002154  3               .if oflag
002154  3               	jsr shwob		; draw objects.
002154  3               .endif
002154  3               
002154  3  A9 39        	lda #<sprtab 		; address of sprite table, even sprites.
002156  3  85 68        	sta z80_x
002158  3  A9 32        	lda #>sprtab
00215A  3  85 69        	sta z80_i
00215C  3  20 DC 2B     	jsr dspr 		; display sprites.
00215F  3               
00215F  3  A9 4A        	lda #<(sprtab+TABSIZ) 	; address of first odd sprite.
002161  3  85 68        	sta z80_x
002163  3  A9 32        	lda #>(sprtab+TABSIZ)
002165  3  85 69        	sta z80_i
002167  3  20 DC 2B     	jsr dspr 		; display sprites.
00216A  3               mloop:
00216A  3  20 45 20     	jsr vsync 		; synchronise with display.
00216D  3  A9 39        	lda #<sprtab 		; address of sprite table, even sprites.
00216F  3  85 68        	sta z80_x
002171  3  A9 32        	lda #>sprtab
002173  3  85 69        	sta z80_i
002175  3  20 DC 2B     	jsr dspr 		; display even sprites.
002178  3               
002178  3               ;	jsr plsnd 		; play sounds.
002178  3               
002178  3  20 D4 20     	jsr proshr
00217B  3  A9 4A        	lda #<(sprtab+TABSIZ) 	; address of first odd sprite.
00217D  3  85 68        	sta z80_x
00217F  3  A9 32        	lda #>(sprtab+TABSIZ)
002181  3  85 69        	sta z80_i
002183  3  20 DC 2B     	jsr dspr 		; display odd sprites.
002186  3               
002186  3  A9 05        	lda #<(ssprit) 		; point to spare sprite for spawning purposes.
002188  3  85 68        	sta z80_x
00218A  3  A9 33        	lda #>(ssprit)
00218C  3  85 69        	sta z80_i
00218E  3               evlp1:
00218E  3  20 2D 33     	jsr evnt10 		; called once per main loop.
002191  3  20 5A 2B     	jsr pspr 		; process sprites.
002194  3               
002194  3               ; Main loop events.
002194  3               
002194  3  A9 05        	lda #<ssprit 		; point to spare sprite for spawning purposes.
002196  3  85 68        	sta z80_x
002198  3  A9 33        	lda #>ssprit
00219A  3  85 69        	sta z80_i
00219C  3               evlp2:
00219C  3  20 D1 33     	jsr evnt11 		; called once per main loop.
00219F  3               bsortx:
00219F  3  20 D0 2A     	jsr bsort 		; sort sprites.
0021A2  3               
0021A2  3  A5 rr        	lda nexlev		; finished level flag.
0021A4  3  F0 03        	beq :+
0021A6  3  4C CE 21     	jmp newlev		; is set, go to next level.
0021A9  3               :
0021A9  3  A5 rr        	lda gamwon		; finished game flag.
0021AB  3  F0 03        	beq :+
0021AD  3  4C DD 21     	jmp evwon		; is set, finish the game.
0021B0  3               :
0021B0  3  A5 rr        	lda restfl 		; finished level flag.
0021B2  3  C9 01        	cmp #1			; has it been set?
0021B4  3  D0 03        	bne :+
0021B6  3  4C 2E 21     	jmp rstrt		; yes, go to next level.
0021B9  3               :
0021B9  3  C9 02        	cmp #2			; has it been set?
0021BB  3  D0 03        	bne :+
0021BD  3  4C 3D 21     	jmp rstrtn		; yes, go to next level.
0021C0  3               :
0021C0  3  A5 rr        	lda deadf 		; dead flag.
0021C2  3  F0 03        	beq :+
0021C4  3  4C E3 21     	jmp pdead		; yes, player dead.
0021C7  3               :
0021C7  3               ; back to start of main loop.
0021C7  3               
0021C7  3  E6 rr        	inc frmno
0021C9  3  E6 rr        	inc clock
0021CB  3  4C 6A 21     	jmp mloop		; switched to a jmp mloop during test mode.
0021CE  3               
0021CE  3               ;----------------------------------------------------------
0021CE  3               ; Read blocks from list and update screen accordingly.
0021CE  3               ;----------------------------------------------------------
0021CE  3               
0021CE  3               .if aflag
0021CE  3               rbloc:
0021CE  3               	lda #<eop		; reset temp blockpointer
0021CE  3               	sta pbbuf
0021CE  3               	lda #>eop
0021CE  3               	sta pbbuf+1
0021CE  3               
0021CE  3               rbloc2:
0021CE  3               	lda pbbuf			; check for last block
0021CE  3               	cmp pbptr
0021CE  3               	bne rbloc1
0021CE  3               	lda pbbuf+1
0021CE  3               	cmp pbptr+1
0021CE  3               	bne rbloc1
0021CE  3               	rts
0021CE  3               rbloc1:
0021CE  3               	ldy #0
0021CE  3               	lda (pbbuf),y		; check if block for this scno
0021CE  3               	cmp scno
0021CE  3               	bne rbloc0		; if not, skip
0021CE  3               	iny
0021CE  3               	lda (pbbuf),y		; get y
0021CE  3               	sta dispy
0021CE  3               	iny
0021CE  3               	lda (pbbuf),y		; get x
0021CE  3               	sta dispx
0021CE  3               	iny
0021CE  3               	lda (pbbuf),y		; get blocknr
0021CE  3               	jsr pattr2		; draw block
0021CE  3               rbloc0:
0021CE  3               	clc			; point to next block
0021CE  3               	lda pbbuf
0021CE  3               	adc #4
0021CE  3               	sta pbbuf
0021CE  3               	bcc rbloc2
0021CE  3               	inc pbbuf+1
0021CE  3               	jmp rbloc2
0021CE  3               .endif
0021CE  3               
0021CE  3               ;----------------------------------------------------------
0021CE  3               ; New level
0021CE  3               ;----------------------------------------------------------
0021CE  3               
0021CE  3               ;.repeat 270
0021CE  3               ;  .byte 0
0021CE  3               ;.endrep
0021CE  3               
0021CE  3               newlev:
0021CE  3  A5 rr        	lda scno 			; current screen.
0021D0  3  18           	clc
0021D1  3  69 01        	adc #1				; next screen.
0021D3  3  CD F3 34     	cmp numsc			; total number of screens.
0021D6  3  B0 05        	bcs evwon			; yes, game finished.
0021D8  3  85 rr        	sta scno			; set new level number.
0021DA  3  4C 2E 21     	jmp rstrt			; restart, clearing all aliens.
0021DD  3               
0021DD  3               evwon:
0021DD  3  20 09 34     	jsr evnt18		 	; game completed.
0021E0  3  4C F5 21     	jmp tidyup			; tidy up and return to BASIC/calling routine.
0021E3  3               
0021E3  3               ;----------------------------------------------------------
0021E3  3               ; Player dead.
0021E3  3               ;----------------------------------------------------------
0021E3  3               
0021E3  3               ;.repeat 258
0021E3  3               ;  .byte 0
0021E3  3               ;.endrep
0021E3  3               
0021E3  3               pdead:
0021E3  3  A9 00        	lda #0				; zeroise accumulator.
0021E5  3  85 rr        	sta deadf			; reset dead flag.
0021E7  3               evdie:
0021E7  3  20 07 34     	jsr evnt16 			; death subroutine.
0021EA  3  A5 rr        	lda numlif			; number of lives.
0021EC  3  F0 03        	beq :+
0021EE  3  4C 2E 21     	jmp rstrt 			; restart game.
0021F1  3               :
0021F1  3               evfail:
0021F1  3  20 08 34     	jsr evnt17 			; failure event.
0021F4  3  60           	rts			; restart game
0021F5  3               
0021F5  3               ;----------------------------------------------------------
0021F5  3               ; Tidy things up
0021F5  3               ;----------------------------------------------------------
0021F5  3               
0021F5  3               ;.repeat 291
0021F5  3               ;  .byte 0
0021F5  3               ;.endrep
0021F5  3               
0021F5  3               tidyup:
0021F5  3  A0 00        	ldy #0				; digits to check.
0021F7  3               tidyu2:
0021F7  3  B9 69 23     	lda score,y 			; get score digit.
0021FA  3  CD 6F 23     	cmp hiscor 			; are we larger than high score digit?
0021FD  3  90 07        	bcc tidyu0			; high score is bigger.
0021FF  3  D0 0E        	bne tidyu1			; score is greater, record new high score.
002201  3  C8           	iny				; next digit of high score.
002202  3  C0 06        	cpy #6
002204  3  D0 F1        	bne tidyu2			; repeat for all digits
002206  3               tidyu0:
002206  3  A9 69        	lda #<score			; return pointing to score.
002208  3  85 62        	sta z80_c
00220A  3  A9 23        	lda #>score
00220C  3  85 63        	sta z80_b
00220E  3  60           	rts
00220F  3               tidyu1:
00220F  3  A0 05        	ldy #5
002211  3               tidyu3:
002211  3  B9 69 23     	lda score,y			; score.
002214  3  99 6F 23     	sta hiscor,y			; high score.
002217  3  88           	dey
002218  3  10 F7        	bpl tidyu3 			; copy score to high score.
00221A  3               evnewh:
00221A  3  20 0A 34     	jsr evnt19			; new high score event.
00221D  3  4C 06 22     	jmp tidyu0			; tidy up.
002220  3               
002220  3               ;--------------------------------------------------
002220  3               ; Restart event.
002220  3               ;--------------------------------------------------
002220  3               
002220  3               rsevt:
002220  3  A9 05        	lda #<ssprit 			; default to spare element in table.
002222  3  85 68        	sta z80_x
002224  3  A9 33        	lda #>ssprit
002226  3  85 69        	sta z80_i
002228  3               evrs:
002228  3  4C 05 34     	jmp evnt14	 		; call restart event.
00222B  3               
00222B  3               ;------------------------------------------------------------------
00222B  3               ; Copy number passed in a to string position bc, right-justified.
00222B  3               ;
00222B  3               ; Input:
00222B  3               ;  A  = number
00222B  3               ;  BC = string address
00222B  3               ;
00222B  3               ; Output:
00222B  3               ;  BC = string with number
00222B  3               ;-----------------------------------------------------------------
00222B  3               
00222B  3               num2ch:
00222B  3  85 65        	sta z80_d		; Save number
00222D  3               
00222D  3  A9 00        	lda #0
00222F  3  85 rr        	sta flag
002231  3               numdg3:
002231  3  A2 64        	ldx #100		; hundreds column.
002233  3  86 64        	stx z80_e
002235  3  20 45 22     	jsr numdg		; show digit.
002238  3               numdg2:
002238  3  A2 0A        	ldx #10			; tens column.
00223A  3  86 64        	stx z80_e
00223C  3  20 45 22     	jsr numdg		; show digit.
00223F  3               
00223F  3  E6 rr        	inc flag
002241  3  A2 01        	ldx #1			; units column.
002243  3  86 64        	stx z80_e
002245  3               numdg:
002245  3  A9 30        	lda #48			; clear digit.
002247  3  85 61        	sta z80_a
002249  3               numdg1:
002249  3  A5 65        	lda z80_d
00224B  3  C5 64        	cmp z80_e
00224D  3  90 0E        	bcc numdg0		; nothing to show.
00224F  3  38           	sec
002250  3  A5 65        	lda z80_d
002252  3  E5 64        	sbc z80_e		; subtract from column.
002254  3  85 65        	sta z80_d
002256  3  E6 61        	inc z80_a		; increment digit.
002258  3  E6 rr        	inc flag
00225A  3  4C 49 22     	jmp numdg1		; repeat until column is zero.
00225D  3               numdg0:
00225D  3  A0 00        	ldy #0
00225F  3  A5 61        	lda z80_a
002261  3  91 62        	sta (z80_bc),y		; write digit to buffer.
002263  3  A5 rr        	lda flag
002265  3  F0 06        	beq :+
002267  3  E6 62        	inc z80_c		; next buffer position.
002269  3  D0 02        	bne :+
00226B  3  E6 63        	inc z80_b
00226D  3               :
00226D  3  60           	rts
00226E  3               num2dd:
00226E  3  85 65        	sta z80_d		; Save number
002270  3               
002270  3  A9 01        	lda #1
002272  3  85 rr        	sta flag
002274  3               
002274  3  4C 38 22     	jmp numdg2
002277  3               num2td:
002277  3  85 65        	sta z80_d		; Save number
002279  3               
002279  3  A9 01        	lda #1
00227B  3  85 rr        	sta flag
00227D  3  4C 31 22     	jmp numdg3
002280  3               
002280  3               ;flag:	.byte 0
002280  3               
002280  3               ;---------------------------------------------------------
002280  3               ; Reset score to "000000"
002280  3               ;---------------------------------------------------------
002280  3               
002280  3               inisc:
002280  3  A9 30        	lda #'0'
002282  3  A2 05        	ldx #5			; digits to initialise.
002284  3               inisc0:
002284  3  9D 69 23     	sta score,x 		; write zero digit.
002287  3  CA           	dex			; next column.
002288  3  10 FA        	bpl inisc0		; repeat for all digits.
00228A  3               
00228A  3  60           	rts
00228B  3               
00228B  3               ;-----------------------------------------------------
00228B  3               ; Multiply h by d and return in hl.
00228B  3               ;
00228B  3               ; Input:
00228B  3               ;  H = first number
00228B  3               ;  D = second number
00228B  3               ;
00228B  3               ; Output:
00228B  3               ;  HL = result H x D
00228B  3               ;-----------------------------------------------------
00228B  3               
00228B  3               imul:
00228B  3  A5 65        	lda z80_d		; HL = H * D
00228D  3  85 64        	sta z80_e
00228F  3  A5 67        	lda z80_h
002291  3  85 62        	sta z80_c		; make c first multiplier.
002293  3               imul0:
002293  3  A9 00        	lda #0			; zeroise total.
002295  3  85 66        	sta z80_l
002297  3  85 67        	sta z80_h
002299  3               
002299  3  A5 67        	lda z80_h
00229B  3  85 65        	sta z80_d		; zeroise high byte.
00229D  3               
00229D  3  A9 08        	lda #8			; repeat 8 times.
00229F  3  85 63        	sta z80_b
0022A1  3               imul1:
0022A1  3  46 62        	lsr z80_c		; rotate rightmost bit into carry.
0022A3  3  90 0E        	bcc imul2		; wasn't set.
0022A5  3  18           	clc			; bit was set, so add de.
0022A6  3  A5 66        	lda z80_l
0022A8  3  65 64        	adc z80_e
0022AA  3  85 66        	sta z80_l
0022AC  3  A5 67        	lda z80_h
0022AE  3  65 65        	adc z80_d
0022B0  3  85 67        	sta z80_h
0022B2  3  18           	clc 			; reset carry.
0022B3  3               imul2:
0022B3  3  06 64        	asl z80_e 		; shift de 1 bit left.
0022B5  3  26 65        	rol z80_d
0022B7  3  C6 63        	dec z80_b
0022B9  3  D0 E6        	bne imul1		; repeat 8 times.
0022BB  3               
0022BB  3  60           	rts
0022BC  3               
0022BC  3               ;-----------------------------------------------
0022BC  3               ; Divide d by e and return in d, remainder in a.
0022BC  3               ;
0022BC  3               ; Input:
0022BC  3               ;  D = first number
0022BC  3               ;  E = second number
0022BC  3               ;
0022BC  3               ; Output:
0022BC  3               ;  D = result D/E
0022BC  3               ;  A = remainder
0022BC  3               ;-----------------------------------------------
0022BC  3               
0022BC  3               idiv:
0022BC  3  A9 00        	lda #0
0022BE  3  A0 08        	ldy #8		 	; bits to shift.
0022C0  3  06 65        	asl z80_d
0022C2  3               idiv0:
0022C2  3  2A           	rol a 			; multiply d by 2.
0022C3  3  C5 64        	cmp z80_e 		; test if e is smaller.
0022C5  3  90 02        	bcc idiv1		; e is greater, no division this time.
0022C7  3  E5 64        	sbc z80_e		; subtract it.
0022C9  3               idiv1:
0022C9  3  26 65        	rol z80_d		; rotate into d.
0022CB  3  88           	dey
0022CC  3  D0 F4        	bne idiv0		; repeat
0022CE  3  60           	rts
0022CF  3               
0022CF  3               ;---------------------------------------------------
0022CF  3               ; Play AY sound effect
0022CF  3               ;---------------------------------------------------
0022CF  3               
0022CF  3               plsnd:
0022CF  3  60           	rts
0022D0  3               
0022D0  3               ;---------------------------------------------------
0022D0  3               ; Objects handling.
0022D0  3               ; 32 bytes for image
0022D0  3               ; 3 for room, y and x
0022D0  3               ; 3 for starting room, y and x.
0022D0  3               ; 254 = disabled.
0022D0  3               ; 255 = object in player"s pockets.
0022D0  3               ;---------------------------------------------------
0022D0  3               
0022D0  3               ;---------------------------------------------------
0022D0  3               ; Show items present.
0022D0  3               ;---------------------------------------------------
0022D0  3               
0022D0  3               .if oflag
0022D0  3               shwob:
0022D0  3               	lda #<objdta 			; objects table.
0022D0  3               	sta z80_l
0022D0  3               	lda #>objdta
0022D0  3               	sta z80_h
0022D0  3               
0022D0  3               	lda numob 			; number of objects in the game.
0022D0  3               	sta sprcnt
0022D0  3               shwob0:
0022D0  3               	ldy #32 			; distance to room number.
0022D0  3               	lda (z80_hl),y 			; same as an item?
0022D0  3               	cmp scno 			; current location.
0022D0  3               	bne :+
0022D0  3               	jsr dobj 			; yes, display object.
0022D0  3               :
0022D0  3               	clc
0022D0  3               	lda z80_l
0022D0  3               	adc #38 			; distance to next item.
0022D0  3               	sta z80_l
0022D0  3               	lda z80_h
0022D0  3               	adc #0
0022D0  3               	sta z80_h	 		; point to it.
0022D0  3               	dec sprcnt
0022D0  3               	bne shwob0 			; repeat for others.
0022D0  3               	rts
0022D0  3               
0022D0  3               ;---------------------------------------------------
0022D0  3               ; Display object.
0022D0  3               ; hl must point to object's start address.
0022D0  3               ;
0022D0  3               ; Input:
0022D0  3               ;  HL = object address
0022D0  3               ;---------------------------------------------------
0022D0  3               
0022D0  3               dobj:
0022D0  3               	ldy #33
0022D0  3               	lda (z80_hl),y 			; point to y.
0022D0  3               	sta dispy
0022D0  3               	iny
0022D0  3               	lda (z80_hl),y 			; point to x.
0022D0  3               	sta dispx
0022D0  3               dobj1:
0022D0  3               	jmp sprite 			; draw this sprite.
0022D0  3               
0022D0  3               ;--------------------------------------
0022D0  3               ; Remove an object.
0022D0  3               ;
0022D0  3               ; Input:
0022D0  3               ;  A = object number
0022D0  3               ;--------------------------------------
0022D0  3               
0022D0  3               remob:
0022D0  3               	cmp numob			; number of objects in game.
0022D0  3               	bcc :+				; are we checking past the end?
0022D0  3               	rts				; yes, can't get non-existent item.
0022D0  3               :
0022D0  3               	pha				; remember object.
0022D0  3               	jsr getob			; pick it up if we haven't already got it.
0022D0  3               	pla				; retrieve object number.
0022D0  3               	jsr gotob			; get its address.
0022D0  3               	lda #254
0022D0  3               	ldy #32
0022D0  3               	sta (z80_hl),y			; remove it.
0022D0  3               	rts
0022D0  3               
0022D0  3               ;---------------------------------------------------
0022D0  3               ; Pick up object number held in the accumulator.
0022D0  3               ;
0022D0  3               ; Input:
0022D0  3               ;  A = object number
0022D0  3               ;---------------------------------------------------
0022D0  3               
0022D0  3               getob:
0022D0  3               	cmp numob 		; number of objects in game.
0022D0  3               	bcc :+			; are we checking past the end?
0022D0  3               	rts			; yes, can't get non-existent item.
0022D0  3               :
0022D0  3               	jsr gotob 		; check if we already have it.
0022D0  3               	cmp #255
0022D0  3               	bne :+
0022D0  3               	rts			; we already do.
0022D0  3               :
0022D0  3               	ldy #32
0022D0  3               	lda (z80_hl),y		; is it on this screen?
0022D0  3               	cmp scno 		; current screen.
0022D0  3               	bne getob0		; not on screen, so nothing to delete.
0022D0  3               
0022D0  3               	lda #255
0022D0  3               	sta (z80_hl),y		; pick it up.
0022D0  3               	iny 			; point to y coord.
0022D0  3               getob1:
0022D0  3               	ldy #33
0022D0  3               	lda (z80_hl),y		; y coord.
0022D0  3               	sta dispy
0022D0  3               	ldy #34
0022D0  3               	lda (z80_hl),y 		; x coord.
0022D0  3               	sta dispx
0022D0  3               	jmp dobj1 		; delete object sprite.
0022D0  3               getob0:
0022D0  3               	lda #255
0022D0  3               	sta (z80_hl),y 		; pick it up.
0022D0  3               	rts
0022D0  3               .endif
0022D0  3               
0022D0  3               ;-----------------------------------------------------------------
0022D0  3               ; Got object check.
0022D0  3               ; Call with object in accumulator, returns zero set if in pockets.
0022D0  3               ;
0022D0  3               ; Input:
0022D0  3               ;  A = object number
0022D0  3               ;-----------------------------------------------------------------
0022D0  3               .if oflag .or mflag
0022D0  3               gotob:
0022D0  3               	cmp numob 		; number of objects in game.
0022D0  3               	bcc :+ 			; are we checking past the end?
0022D0  3               	jmp gotob0 		; yes, we can't have a non-existent object.
0022D0  3               :
0022D0  3               	jsr findob		; find the object.
0022D0  3               gotob1:
0022D0  3               	rts
0022D0  3               
0022D0  3               gotob0:
0022D0  3               	lda #254 		; missing.
0022D0  3               	jmp gotob1
0022D0  3               
0022D0  3               findob:
0022D0  3               	pha			; save object number
0022D0  3               	lda #<objdta 		; objects.
0022D0  3               	sta z80_l
0022D0  3               	lda #>objdta
0022D0  3               	sta z80_h
0022D0  3               	pla			; retreive object number
0022D0  3               	beq fndob1 		; is it zero? yes, skip loop.
0022D0  3               	tax 			; loop counter
0022D0  3               fndob2:
0022D0  3               	clc
0022D0  3               	lda z80_l
0022D0  3               	adc #38 		; size of each object.
0022D0  3               	sta z80_l
0022D0  3               	bcc :+
0022D0  3               	inc z80_h
0022D0  3               :
0022D0  3               	dex 			; repeat until we find address.
0022D0  3               	bne fndob2
0022D0  3               fndob1:
0022D0  3               	ldy #32			; distance to room it's in.
0022D0  3               	lda (z80_hl),y		; fetch status.
0022D0  3               	rts
0022D0  3               .endif
0022D0  3               
0022D0  3               ;---------------------------------------------
0022D0  3               ; Drop object number at (dispx, dispy).
0022D0  3               ;
0022D0  3               ; Input:
0022D0  3               ;  A = object number
0022D0  3               ;---------------------------------------------
0022D0  3               
0022D0  3               .if oflag
0022D0  3               drpob:
0022D0  3               	cmp numob 		; are we checking past the end?
0022D0  3               	bcc :+
0022D0  3               	rts			; yes, can't drop non-existent item.
0022D0  3               :
0022D0  3               	jsr gotob		; make sure object is in inventory.
0022D0  3               	cmp scno		; already on this screen?
0022D0  3               	bne :+
0022D0  3               	rts			; yes, nothing to do.
0022D0  3               :
0022D0  3               	ldy #32
0022D0  3               	lda scno
0022D0  3               	sta (z80_hl),y		; bring onto screen.
0022D0  3               	lda dispy		; sprite y coordinate.
0022D0  3               	iny
0022D0  3               	sta (z80_hl),y		; point to object y.
0022D0  3               	lda dispx 		; sprite x coordinate.
0022D0  3               	iny
0022D0  3               	sta (z80_hl),y 		; point to object x
0022D0  3               	jmp dobj		; draw the object sprite.
0022D0  3               
0022D0  3               ;-----------------------------------------------
0022D0  3               ; Seek objects at sprite position.
0022D0  3               ;
0022D0  3               ; Output:
0022D0  3               ;  A = object number, if not found A=255
0022D0  3               ;-----------------------------------------------
0022D0  3               
0022D0  3               skobj:
0022D0  3               	lda #<objdta 		; pointer to objects.
0022D0  3               	sta z80_l
0022D0  3               	lda #>objdta
0022D0  3               	sta z80_h
0022D0  3               
0022D0  3               	lda numob 		; number of objects in game.
0022D0  3               	sta z80_b 		; set up the loop counter.
0022D0  3               skobj0:
0022D0  3               	lda scno		; current room number.
0022D0  3               	ldy #32
0022D0  3               	cmp (z80_hl),y		; is object in here?
0022D0  3               	bne :+
0022D0  3               	jsr skobj1		; yes, check coordinates.
0022D0  3               :
0022D0  3               	clc			; point to next object in table.
0022D0  3               	lda z80_l
0022D0  3               	adc #38			; size of each object.
0022D0  3               	sta z80_l
0022D0  3               	bcc :+
0022D0  3               	inc z80_h
0022D0  3               :
0022D0  3               	dec z80_b
0022D0  3               	bne skobj0		; repeat for all objects.
0022D0  3               
0022D0  3               	lda #255		; end of list and nothing found, return 255.
0022D0  3               	rts
0022D0  3               
0022D0  3               skobj1:
0022D0  3               	ldy #33			; point to y coordinate.
0022D0  3               	lda (z80_hl),y		; point to y coordinate.
0022D0  3               	sec
0022D0  3               	ldy #8
0022D0  3               	sbc (z80_ix),y 		; subtract sprite y.
0022D0  3               	clc
0022D0  3               	adc #15			; add sprite height minus one.
0022D0  3               	cmp #31			; within range?
0022D0  3               	bcs skobj2		; no, ignore object.
0022D0  3               
0022D0  3               	ldy #34			; point to x coordinate now.
0022D0  3               	lda (z80_hl),y 		; get coordinate.
0022D0  3               	sec
0022D0  3               	ldy #9
0022D0  3               	sbc (z80_ix),y 		; subtract the sprite x.
0022D0  3               	clc			; add sprite width minus one.
0022D0  3               	adc #15
0022D0  3               	cmp #31			; within range?
0022D0  3               	bcs skobj2		; no, ignore object.
0022D0  3               
0022D0  3               	pla			; remove return address from stack.
0022D0  3               	pla
0022D0  3               
0022D0  3               	lda numob 		; objects in game.
0022D0  3               	sec
0022D0  3               	sbc z80_b		; subtract loop counter.
0022D0  3               skobj2:
0022D0  3               	rts			; accumulator now points to object.
0022D0  3               .endif
0022D0  3               
0022D0  3               ;---------------------------------------------------------------------
0022D0  3               ; Spawn a new sprite.
0022D0  3               ;---------------------------------------------------------------------
0022D0  3               
0022D0  3                 offset = 20
0022D0  3               
0022D0  3               ;.repeat 343
0022D0  3               ;  .byte 0
0022D0  3               ;.endrep
0022D0  3               
0022D0  3               spawn:
0022D0  3  A9 39        	lda #<sprtab		; sprite table.
0022D2  3  85 66        	sta z80_l
0022D4  3  A9 32        	lda #>sprtab
0022D6  3  85 67        	sta z80_h
0022D8  3               numsp1:
0022D8  3  A9 0C        	lda #NUMSPR		; number of sprites.
0022DA  3  85 rr        	sta spcnt
0022DC  3               spaw0:
0022DC  3  A0 00        	ldy #0
0022DE  3  B1 66        	lda (z80_hl),y		; get sprite type.
0022E0  3  C9 FF        	cmp #255		; is it an unused slot?
0022E2  3  F0 0F        	beq spaw1 		; yes, we can use this one.
0022E4  3               
0022E4  3  18           	clc 			; point to next sprite in table.
0022E5  3  A5 66        	lda z80_l
0022E7  3  69 11        	adc #TABSIZ		; size of each entry.
0022E9  3  85 66        	sta z80_l
0022EB  3  90 02        	bcc :+
0022ED  3  E6 67        	inc z80_h
0022EF  3               :
0022EF  3  C6 rr        	dec spcnt		; one less iteration.
0022F1  3  D0 E9        	bne spaw0		; keep going until we find a slot.
0022F3  3               
0022F3  3               ; Didn't find one but drop through and set up a dummy sprite instead.
0022F3  3               
0022F3  3               spaw1:
0022F3  3  A5 69        	lda z80_i		; address of original sprite.
0022F5  3  48           	pha
0022F6  3  A5 68        	lda z80_x
0022F8  3  48           	pha
0022F9  3               
0022F9  3  A5 66        	lda z80_l		; store spawned sprite address.
0022FB  3  85 rr        	sta spptr
0022FD  3  A5 67        	lda z80_h
0022FF  3  85 rr        	sta spptr+1
002301  3               
002301  3  A5 62        	lda z80_c
002303  3  A0 00        	ldy #0
002305  3  91 66        	sta (z80_hl),y 		; set the type.
002307  3  A0 05        	ldy #5
002309  3  91 66        	sta (z80_hl),y		; copy
00230B  3               
00230B  3  A5 63        	lda z80_b
00230D  3  A0 01        	ldy #1
00230F  3  91 66        	sta (z80_hl),y		; set the image.
002311  3  A0 06        	ldy #6
002313  3  91 66        	sta (z80_hl),y		; copy
002315  3               
002315  3  A9 00        	lda #0 			; frame zero.
002317  3  A0 02        	ldy #2
002319  3  91 66        	sta (z80_hl),y		; set frame.
00231B  3  A0 07        	ldy #7
00231D  3  91 66        	sta (z80_hl),y		; copy
00231F  3               
00231F  3  A0 08        	ldy #8
002321  3  B1 68        	lda (z80_ix),y 		; x coordinate.
002323  3  A0 03        	ldy #3
002325  3  91 66        	sta (z80_hl),y		; set sprite coordinate.
002327  3  A0 08        	ldy #8
002329  3  91 66        	sta (z80_hl),y		; copy
00232B  3               
00232B  3  A0 09        	ldy #9
00232D  3  B1 68        	lda (z80_ix),y 		; y coordinate.
00232F  3  A0 04        	ldy #4
002331  3  91 66        	sta (z80_hl),y		; set sprite coordinate.
002333  3  A0 09        	ldy #9
002335  3  91 66        	sta (z80_hl),y		; copy
002337  3               
002337  3  A0 0A        	ldy #10			; direction of original.
002339  3  B1 68        	lda (z80_ix),y
00233B  3  91 66        	sta (z80_hl),y		; direction
00233D  3               
00233D  3  A9 00        	lda #0
00233F  3  A0 0B        	ldy #11
002341  3  91 66        	sta (z80_hl),y		; reset parameter.
002343  3  C8           	iny
002344  3  91 66        	sta (z80_hl),y		; reset parameter.
002346  3  C8           	iny
002347  3  91 66        	sta (z80_hl),y		; reset parameter.
002349  3  C8           	iny
00234A  3  91 66        	sta (z80_hl),y		; reset parameter.
00234C  3               rtssp:
00234C  3  A5 rr        	lda spptr		; address of new sprite.
00234E  3  85 68        	sta z80_x
002350  3  A5 rr        	lda spptr+1
002352  3  85 69        	sta z80_i
002354  3               evis1:
002354  3  20 2C 33     	jsr evnt09 		; call sprite initialisation event.
002357  3               
002357  3  A5 rr        	lda spptr 		; address of new sprite.
002359  3  85 68        	sta z80_x
00235B  3  A5 rr        	lda spptr+1
00235D  3  85 69        	sta z80_i
00235F  3  20 02 2D     	jsr sspria 		; display the new sprite.
002362  3               
002362  3  68           	pla			; address of original sprite.
002363  3  85 68        	sta z80_x
002365  3  68           	pla
002366  3  85 69        	sta z80_i
002368  3               
002368  3  60           	rts
002369  3               
002369  3               ;spcnt:	.byte 0
002369  3               ;spptr:	.word 0			; spawned sprite pointer.
002369  3               ;seed:	.byte 0			; seed for random numbers.
002369  3  30 30 30 30  score:	.byte "000000"		; player"s score.
00236D  3  30 30        
00236F  3  30 30 30 30  hiscor:	.byte "000000"		; high score.
002373  3  30 30        
002375  3  30 30 30 30  bonus:	.byte "000000"		; bonus.
002379  3  30 30        
00237B  3  00 E4        grbase:	.word ScreenAddr	; graphics base address.
00237D  3               
00237D  3               ;----------------------------------------------------
00237D  3               ; Check y-pos
00237D  3               ;----------------------------------------------------
00237D  3               
00237D  3               checkx:
00237D  3  A5 rr        	lda dispy		; y position.
00237F  3  C9 18        	cmp #24			; off screen?
002381  3  B0 01        	bcs :+
002383  3  60           	rts			; no, it's okay.
002384  3               :
002384  3  68           	pla			; remove return address from stack.
002385  3  85 66        	sta z80_l
002387  3  68           	pla
002388  3  85 67        	sta z80_h
00238A  3  60           	rts
00238B  3               
00238B  3               ;-----------------------------------------------
00238B  3               ; Displays the current high score.
00238B  3               ;-----------------------------------------------
00238B  3               
00238B  3               dhisc:
00238B  3  A9 6F        	lda #<hiscor 		; high score text.
00238D  3  8D C2 23     	sta dscor3+1
002390  3  8D DD 23     	sta bscor3+1
002393  3  A9 23        	lda #>hiscor
002395  3  8D C3 23     	sta dscor3+2
002398  3  8D DE 23     	sta bscor3+2
00239B  3  4C AE 23     	jmp dscor1		; check in printable range then show 6 digits.
00239E  3               
00239E  3               ;------------------------------------------------------
00239E  3               ; Displays the current score.
00239E  3               ;------------------------------------------------------
00239E  3               
00239E  3               ;.repeat 322
00239E  3               ;  .byte 0
00239E  3               ;.endrep
00239E  3               
00239E  3               dscor:
00239E  3  A9 69        	lda #<score		; score text.
0023A0  3  8D C2 23     	sta dscor3+1
0023A3  3  8D DD 23     	sta bscor3+1
0023A6  3  A9 23        	lda #>score
0023A8  3  8D C3 23     	sta dscor3+2
0023AB  3  8D DE 23     	sta bscor3+2
0023AE  3               dscor1:
0023AE  3  8C D9 23     	sty tmpscr
0023B1  3  20 A4 2A     	jsr preprt		; set up font and print position.
0023B4  3  20 7D 23     	jsr checkx		; make sure we're in a printable range.
0023B7  3               
0023B7  3               ;	lda #6			; digits to display.
0023B7  3               ;	sta z80_b
0023B7  3  A5 rr        	lda prtmod		; get print mode.
0023B9  3  F0 03        	beq :+			; standard size text?
0023BB  3  4C DA 23     	jmp bscor0		; no, show double-height.
0023BE  3               :
0023BE  3               dscor0:
0023BE  3               ;	ldy #0
0023BE  3               ;	lda (z80_hl),y 		; fetch character.
0023BE  3  AC D9 23     	ldy tmpscr
0023C1  3               dscor3:
0023C1  3  B9 69 23     	lda score,y
0023C4  3  20 11 25     	jsr pchar 		; display character.
0023C7  3  E6 rr        	inc dispx		; move along x coordinate
0023C9  3               
0023C9  3               ;	inc z80_l		; next score column.
0023C9  3               ;	bne :+
0023C9  3               ;	inc z80_h
0023C9  3               ;:
0023C9  3  EE D9 23     	inc tmpscr
0023CC  3  C6 63        	dec z80_b
0023CE  3  D0 EE        	bne dscor0 		; repeat for all digits.
0023D0  3               dscor2:
0023D0  3  A5 rr        	lda dispx 		; set up display coordinates.
0023D2  3  85 rr        	sta charx
0023D4  3  A5 rr        	lda dispy
0023D6  3  85 rr        	sta chary
0023D8  3  60           	rts
0023D9  3               
0023D9  3  00           tmpscr:	.byte 0
0023DA  3               ;------------------------------------------------------
0023DA  3               ; Displays the current score in double-height characters.
0023DA  3               ;
0023DA  3               ; Input:
0023DA  3               ;  B  = digit number
0023DA  3               ;  HL = score string
0023DA  3               ;------------------------------------------------------
0023DA  3               
0023DA  3               bscor0:
0023DA  3               ;	ldy #0
0023DA  3               
0023DA  3               ;	lda (z80_hl),y 		; fetch character.
0023DA  3  A4 rr        	ldy tmp
0023DC  3               bscor3:
0023DC  3  B9 69 23     	lda score,y
0023DF  3  20 25 2A     	jsr bchar 		; display big char.
0023E2  3               
0023E2  3               ;	inc z80_l 		; next score column.
0023E2  3               ;	bne :+
0023E2  3               ;	inc z80_h
0023E2  3               ;:
0023E2  3  E6 rr        	inc tmp
0023E4  3  C6 63        	dec z80_b
0023E6  3  F0 03        	beq :+
0023E8  3  4C DA 23     	jmp bscor0 		; repeat for all digits.
0023EB  3               :
0023EB  3  4C D0 23     	jmp dscor2 		; tidy up line and column variables.
0023EE  3               
0023EE  3               ;-----------------------------------------------------
0023EE  3               ; Adds number in the hl pair to the score.
0023EE  3               ;-----------------------------------------------------
0023EE  3               
0023EE  3               addsc:
0023EE  3  A9 6A        	lda #<(score+1) 	; ten thousands column.
0023F0  3  85 64        	sta z80_e
0023F2  3  A9 23        	lda #>(score+1)
0023F4  3  85 65        	sta z80_d
0023F6  3  A9 10        	lda #<10000		; amount to add each time.
0023F8  3  85 62        	sta z80_c
0023FA  3  A9 27        	lda #>10000
0023FC  3  85 63        	sta z80_b
0023FE  3  20 42 24     	jsr incsc		; add to score.
002401  3               
002401  3  E6 64        	inc z80_e		; thousands column.
002403  3  D0 02        	bne :+
002405  3  E6 65        	inc z80_d
002407  3               :
002407  3  A9 E8        	lda #<1000		; amount to add each time.
002409  3  85 62        	sta z80_c
00240B  3  A9 03        	lda #>1000
00240D  3  85 63        	sta z80_b
00240F  3  20 42 24     	jsr incsc 		; add to score.
002412  3               
002412  3  E6 64        	inc z80_e		; hundreds column.
002414  3  D0 02        	bne :+
002416  3  E6 65        	inc z80_d
002418  3               :
002418  3  A9 64        	lda #<100		; amount to add each time.
00241A  3  85 62        	sta z80_c
00241C  3  A9 00        	lda #>100
00241E  3  85 63        	sta z80_b
002420  3  20 42 24     	jsr incsc		; add to score.
002423  3               
002423  3  E6 64        	inc z80_e 		; tens column.
002425  3  D0 02        	bne :+
002427  3  E6 65        	inc z80_d
002429  3               :
002429  3  A9 0A        	lda #<10		; amount to add each time.
00242B  3  85 62        	sta z80_c
00242D  3  A9 00        	lda #>10
00242F  3  85 63        	sta z80_b
002431  3  20 42 24     	jsr incsc 		; add to score.
002434  3               
002434  3  E6 64        	inc z80_e		; units column.
002436  3  D0 02        	bne :+
002438  3  E6 65        	inc z80_d
00243A  3               :
00243A  3  A9 01        	lda #<1			; units.
00243C  3  85 62        	sta z80_c
00243E  3  A9 00        	lda #>1
002440  3  85 63        	sta z80_b
002442  3               incsc:
002442  3  A5 67        	lda z80_h		; store amount to add.
002444  3  48           	pha
002445  3  A5 66        	lda z80_l
002447  3  48           	pha
002448  3               
002448  3  38           	sec			; subtract from amount to add.
002449  3  A5 66        	lda z80_l
00244B  3  E5 62        	sbc z80_c
00244D  3  85 66        	sta z80_l
00244F  3  A5 67        	lda z80_h
002451  3  E5 63        	sbc z80_b
002453  3  85 67        	sta z80_h
002455  3  90 14        	bcc incsc0		; too much, restore value.
002457  3               
002457  3  68           	pla			; delete the previous amount from the stack.
002458  3  68           	pla
002459  3               
002459  3  A5 65        	lda z80_d 		; store column position.
00245B  3  48           	pha
00245C  3  A5 64        	lda z80_e
00245E  3  48           	pha
00245F  3  20 72 24     	jsr incsc2		; do the increment.
002462  3               
002462  3  68           	pla			; restore column.
002463  3  85 64        	sta z80_e
002465  3  68           	pla
002466  3  85 65        	sta z80_d
002468  3  4C 42 24     	jmp incsc		; repeat until all added.
00246B  3               
00246B  3               incsc0:
00246B  3  68           	pla			; restore previous value.
00246C  3  85 66        	sta z80_l
00246E  3  68           	pla
00246F  3  85 67        	sta z80_h
002471  3  60           	rts
002472  3               incsc2:
002472  3  A0 00        	ldy #0
002474  3  B1 64        	lda (z80_de),y 		; get amount.
002476  3  18           	clc
002477  3  69 01        	adc #1			; add one to column.
002479  3  91 64        	sta (z80_de),y		; write new column total.
00247B  3  C9 3A        	cmp #'9'+1		; gone beyond range of digits?
00247D  3  B0 01        	bcs :+
00247F  3  60           	rts			; no, carry on.
002480  3               :
002480  3  A9 30        	lda #'0'		; make it zero.
002482  3  91 64        	sta (z80_de),y		; write new column total.
002484  3  C6 64        	dec z80_e		; back one column.
002486  3  D0 02        	bne :+
002488  3  C6 65        	dec z80_d
00248A  3               :
00248A  3  4C 72 24     	jmp incsc2
00248D  3               
00248D  3               ;------------------------------------
00248D  3               ; Add bonus to score and reset bonus
00248D  3               ;------------------------------------
00248D  3               
00248D  3               addbo:
00248D  3  A2 05        	ldx #5			; last digit.
00248F  3  18           	clc
002490  3               addbo0:
002490  3  BD 69 23     	lda score,x		; get score.
002493  3  7D 75 23     	adc bonus,x		; add bonus.
002496  3  38           	sec			; 0 to 18.
002497  3  E9 30        	sbc #48
002499  3  48           	pha
00249A  3  A9 30        	lda #'0'
00249C  3  9D 75 23     	sta bonus,x
00249F  3  68           	pla
0024A0  3  C9 3A        	cmp #58
0024A2  3  90 03        	bcc addbo1
0024A4  3  38           	sec
0024A5  3  E9 0A        	sbc #10
0024A7  3               addbo1:
0024A7  3  9D 69 23     	sta score,x		; zeroise bonus.
0024AA  3  CA           	dex			; next digit.
0024AB  3  10 E3        	bpl addbo0		; repeat for all 6 digits.
0024AD  3  60           	rts
0024AE  3               
0024AE  3               ;------------------------------------
0024AE  3               ; Swap score and bonus.
0024AE  3               ;------------------------------------
0024AE  3               
0024AE  3               swpsb:
0024AE  3  A2 05        	ldx #5			; digits to add.
0024B0  3               swpsb0:
0024B0  3  BD 69 23     	lda score,x 		; get score digits.
0024B3  3  48           	pha			; save digit
0024B4  3  BD 75 23     	lda bonus,x 		; get bonus digits.
0024B7  3  9D 69 23     	sta score,x		; switch score-bonus
0024BA  3  68           	pla
0024BB  3  9D 75 23     	sta bonus,x
0024BE  3  CA           	dex 			; repeat for all 6 digits.
0024BF  3  10 EF        	bpl swpsb0
0024C1  3  60           	rts
0024C2  3               
0024C2  3               ;----------------------------------------------------
0024C2  3               ; Get print address.
0024C2  3               ;----------------------------------------------------
0024C2  3               
0024C2  3               gprad:
0024C2  3  A5 rr        	lda dispx		; get x
0024C4  3  85 rr        	sta scraddr		; store lb address
0024C6  3               
0024C6  3  2A           	rol a
0024C7  3  26 rr        	rol tmp
0024C9  3  2A           	rol a
0024CA  3  26 rr        	rol tmp
0024CC  3  2A           	rol a
0024CD  3  26 rr        	rol tmp
0024CF  3  A5 rr        	lda tmp
0024D1  3  29 07        	and #7
0024D3  3  85 rr        	sta tmp
0024D5  3  A5 rr        	lda prtmod
0024D7  3  F0 02        	beq :+
0024D9  3  06 rr        	asl tmp
0024DB  3               :
0024DB  3  A5 rr        	lda tmp
0024DD  3  18           	clc
0024DE  3  65 rr        	adc dispy		; get y
0024E0  3  69 E4        	adc #>ScreenAddr		; add $80
0024E2  3  85 rr        	sta scraddr+1		; store hb address
0024E4  3  60           	rts
0024E5  3               
0024E5  3               ;--------------------------------------------------------------
0024E5  3               ; Get property buffer address of char at (dispx, dispy) in hl.
0024E5  3               ;
0024E5  3               ; Output:
0024E5  3               ;  bufaddr = MAP + dispy*32 + dispx
0024E5  3               ;--------------------------------------------------------------
0024E5  3               
0024E5  3               pradd:
0024E5  3  A5 rr        	lda dispy 		; y coordinate.
0024E7  3  85 rr        	sta bufaddr
0024E9  3  A9 00        	lda #0
0024EB  3  85 rr        	sta bufaddr+1
0024ED  3  06 rr        	asl bufaddr  		; multiply char by 32
0024EF  3  26 rr        	rol bufaddr+1
0024F1  3  06 rr        	asl bufaddr
0024F3  3  26 rr        	rol bufaddr+1
0024F5  3  06 rr        	asl bufaddr
0024F7  3  26 rr        	rol bufaddr+1
0024F9  3  06 rr        	asl bufaddr
0024FB  3  26 rr        	rol bufaddr+1
0024FD  3  06 rr        	asl bufaddr
0024FF  3  26 rr        	rol bufaddr+1
002501  3  18           	clc			; add address of MAP graphics.
002502  3  A5 rr        	lda bufaddr
002504  3  65 rr        	adc dispx
002506  3  69 00        	adc #<MAP
002508  3  85 rr        	sta bufaddr
00250A  3  A5 rr        	lda bufaddr+1
00250C  3  69 DD        	adc #>MAP
00250E  3  85 rr        	sta bufaddr+1
002510  3  60           	rts
002511  3               
002511  3               ;----------------------------------------------------
002511  3               ; Display character in A at dispx,dispy.
002511  3               ;
002511  3               ; Input:
002511  3               ;  A 	   = character to print
002511  3               ;----------------------------------------------------
002511  3               
002511  3               pchar:
002511  3  85 rr        	sta fntaddr
002513  3  A9 00        	lda #0
002515  3  85 rr        	sta fntaddr+1
002517  3  06 rr        	asl fntaddr  		; multiply char by 8.
002519  3  26 rr        	rol fntaddr+1
00251B  3  06 rr        	asl fntaddr
00251D  3  26 rr        	rol fntaddr+1
00251F  3  06 rr        	asl fntaddr
002521  3  26 rr        	rol fntaddr+1
002523  3               
002523  3  A5 rr        	lda fntaddr
002525  3  18           	clc
002526  3  69 1F        	adc #<(FONT-256)
002528  3  85 rr        	sta fntaddr		; that's the low byte.
00252A  3  A5 rr        	lda fntaddr+1
00252C  3  69 34        	adc #>(FONT-256)
00252E  3  85 rr        	sta fntaddr+1		; add displacement.
002530  3               pchark:
002530  3  20 C2 24     	jsr gprad		; get screen address.
002533  3  A2 07        	ldx #7			; lines to write.
002535  3               pchar0:
002535  3  A0 00        	ldy #0
002537  3  B1 rr        	lda (fntaddr),y 	; get image byte.
002539  3  BC 4E 25     	ldy scrtab,x		; Get rowoffset
00253C  3               .if gflag
00253C  3  2D 6B 39     	and andeor
00253F  3  4D 6C 39     	eor andeor+1
002542  3               .endif
002542  3               .if iflag
002542  3               	eor #$ff
002542  3               .endif
002542  3  91 rr        	sta (scraddr),y 	; copy to screen.
002544  3  E6 rr        	inc fntaddr		; next image byte.
002546  3  D0 02        	bne :+
002548  3  E6 rr        	inc fntaddr+1
00254A  3               :
00254A  3  CA           	dex			; next screen row down.
00254B  3  10 E8        	bpl pchar0		; repeat.
00254D  3  60           	rts
00254E  3               
00254E  3  E0 C0 A0 80  scrtab:		.byte $e0,$c0,$a0,$80,$60,$40,$20,$00
002552  3  60 40 20 00  
002556  3               
002556  3               ;----------------------------------------------
002556  3               
002556  3               ; Print attributes, properties and pixels.
002556  3               ;
002556  3               ; Input:
002556  3               ;  A	= tile number
002556  3               ;----------------------------------------------
002556  3               
002556  3               ;.repeat 294
002556  3               ;  .byte 0
002556  3               ;.endrep
002556  3               
002556  3               pbpattr:			; entry PUTBLOCK command
002556  3  A4 rr        	ldy charx
002558  3  84 rr        	sty dispx
00255A  3  A4 rr        	ldy chary
00255C  3  84 rr        	sty dispy
00255E  3               pattr:
00255E  3               .if aflag
00255E  3               	pha
00255E  3               	jsr wbloc		; save blockinfo
00255E  3               	pla
00255E  3               .endif
00255E  3               
00255E  3               pattr2:
00255E  3  85 63        	sta z80_b		; store cell in b register for now.
002560  3  AA           	tax
002561  3  BD 69 34     	lda bprop,x 		; block properties.
002564  3  85 62        	sta z80_c
002566  3  C9 08        	cmp #COLECT
002568  3  D0 05        	bne :+
00256A  3  A5 63        	lda z80_b
00256C  3  8D 7D 25     	sta colpatt
00256F  3               :
00256F  3  20 E5 24     	jsr pradd 		; get property buffer address.
002572  3  A5 62        	lda z80_c
002574  3  A0 00        	ldy #0
002576  3  91 rr        	sta (bufaddr),y 	; write property.
002578  3  A5 63        	lda z80_b 		; restore cell.
00257A  3  4C 7E 25     	jmp panp
00257D  3               ; Print attributes, no properties.
00257D  3               
00257D  3               ;.repeat 263
00257D  3               ; .byte 0
00257D  3               ;.endrep
00257D  3               
00257D  3  00           colpatt:	.byte 0
00257E  3               
00257E  3               panp:
00257E  3  85 64        	sta z80_e		; displacement in e.
002580  3  A9 00        	lda #0
002582  3  85 65        	sta z80_d		; no high byte.
002584  3  06 64        	asl z80_e  		; multiply char by 8.
002586  3  26 65        	rol z80_d
002588  3  06 64        	asl z80_e
00258A  3  26 65        	rol z80_d
00258C  3  06 64        	asl z80_e
00258E  3  26 65        	rol z80_d
002590  3  18           	clc
002591  3  A5 64        	lda z80_e
002593  3  69 61        	adc #<chgfx 		; address of graphics.
002595  3  85 rr        	sta tileaddr
002597  3  A5 65        	lda z80_d
002599  3  69 34        	adc #>chgfx
00259B  3  85 rr        	sta tileaddr+1
00259D  3  20 C2 24     	jsr gprad 		; get screen address.
0025A0  3  A2 07        	ldx #7			; number of pixel rows to write.
0025A2  3               panp0:
0025A2  3  A0 00        	ldy #0
0025A4  3  B1 rr        	lda (tileaddr),y 	; get image byte.
0025A6  3               .if iflag
0025A6  3               	eor #$ff		; Invert
0025A6  3               .endif
0025A6  3  BC 4E 25     	ldy scrtab,x
0025A9  3  91 rr        	sta (scraddr),y 	; copy to screen.
0025AB  3  E6 rr        	inc tileaddr 		; next image byte.
0025AD  3  D0 02        	bne :+
0025AF  3  E6 rr        	inc tileaddr+1
0025B1  3               :
0025B1  3  CA           	dex	 		; repeat for 8 pixel rows.
0025B2  3  10 EE        	bpl panp0
0025B4  3  E6 rr        	inc dispx 		; move along one.
0025B6  3  E6 rr        	inc charx
0025B8  3  60           	rts
0025B9  3               
0025B9  3               ;----------------------------------------------
0025B9  3               ; Write block
0025B9  3               ;----------------------------------------------
0025B9  3               
0025B9  3               .if aflag
0025B9  3               wbloc:
0025B9  3               	ldy #3
0025B9  3               	sta (pbptr),y		; store block number
0025B9  3               	dey
0025B9  3               	lda dispx
0025B9  3               	sta (pbptr),y		; write x position of block.
0025B9  3               	dey
0025B9  3               	lda dispy
0025B9  3               	sta (pbptr),y		; write y position of block.
0025B9  3               	dey
0025B9  3               	lda scno
0025B9  3               	sta (pbptr),y		; write screen.
0025B9  3               	clc			; point to next free location
0025B9  3               	lda pbptr
0025B9  3               	adc #4
0025B9  3               	sta pbptr
0025B9  3               	bcc :+
0025B9  3               	inc pbptr+1
0025B9  3               :
0025B9  3               	rts
0025B9  3               .endif
0025B9  3               
0025B9  3               ;----------------------------------------------
0025B9  3               ; Print character pixels, no more.
0025B9  3               ;
0025B9  3               ; Input:
0025B9  3               ;  A	= character to print
0025B9  3               ;----------------------------------------------
0025B9  3               
0025B9  3               pchr:
0025B9  3  20 11 25     	jsr pchar 		; show character in accumulator.
0025BC  3  E6 rr        	inc dispx		; move along one.
0025BE  3  60           	rts
0025BF  3               
0025BF  3               ;----------------------------------------------------
0025BF  3               ; Shifter sprite routine for objects.
0025BF  3               ;----------------------------------------------------
0025BF  3               
0025BF  3               .if oflag
0025BF  3               sprit7:
0025BF  3               	lda z80_b
0025BF  3               	beq sprit0
0025BF  3               	sta z80_a
0025BF  3               sprit3:
0025BF  3               	lsr spr			; shift into position.
0025BF  3               	ror spr+1
0025BF  3               	ror spr+2
0025BF  3               	dec z80_a		; one less iteration.
0025BF  3               	bne sprit3
0025BF  3               sprit0:
0025BF  3               	rts 			; now apply to screen.
0025BF  3               
0025BF  3               ;----------------------------------------------------
0025BF  3               ; Draw sprite
0025BF  3               ;----------------------------------------------------
0025BF  3               
0025BF  3               sprite:
0025BF  3               	stx xtmp		; Save X-reg
0025BF  3               	jsr scadd 		; get screen address in scraddr.
0025BF  3               
0025BF  3               	lda dispx 		; x position.
0025BF  3               	and #7 			; position straddling cells.
0025BF  3               	sta z80_b		; store in b register.
0025BF  3               
0025BF  3               	lda z80_l		; store sprite graphic address.
0025BF  3               	sta sprit1+1
0025BF  3               	sta sprit2+1
0025BF  3               	lda z80_h
0025BF  3               	sta sprit1+2
0025BF  3               	sta sprit2+2
0025BF  3               
0025BF  3               	ldx #0			; pixel height.
0025BF  3               	ldy #0
0025BF  3               sprit1:
0025BF  3               	lda objdta,x		; fetch first byte.
0025BF  3               	sta spr
0025BF  3               	inx
0025BF  3               sprit2:
0025BF  3               	lda objdta,x
0025BF  3               	sta spr+1
0025BF  3               
0025BF  3               	lda #0
0025BF  3               	sta spr+2
0025BF  3               	jsr sprit7		; shift sprite
0025BF  3               
0025BF  3               	dex
0025BF  3               	lda spr			; fetch graphic.
0025BF  3               	ldy spritetab,x
0025BF  3               	eor (scraddr),y		; merge with screen image.
0025BF  3               	sta (scraddr),y		; write to screen.
0025BF  3               	inx			; next screen byte.
0025BF  3               
0025BF  3               	lda spr+1		; fetch graphic.
0025BF  3               	ldy spritetab,x
0025BF  3               	eor (scraddr),y		; merge with screen image.
0025BF  3               	sta (scraddr),y		; write to screen.
0025BF  3               	iny
0025BF  3               
0025BF  3               	lda spr+2		; fetch graphic.
0025BF  3               	eor (scraddr),y		; merge with screen image.
0025BF  3               	sta (scraddr),y		; write to screen.
0025BF  3               
0025BF  3               	inx			; next source byte.
0025BF  3               	cpx #16
0025BF  3               	bne :+
0025BF  3               	inc scraddr+1
0025BF  3               :
0025BF  3               	cpx #32
0025BF  3               	bne sprit1		; repeat
0025BF  3               
0025BF  3               	ldx xtmp		; retreive X-reg
0025BF  3               	rts
0025BF  3               
0025BF  3               spritetab:
0025BF  3               	.byte $00,$01,$20,$21,$40,$41,$60,$61
0025BF  3               	.byte $80,$81,$a0,$a1,$c0,$c1,$e0,$e1
0025BF  3               	.byte $00,$01,$20,$21,$40,$41,$60,$61
0025BF  3               	.byte $80,$81,$a0,$a1,$c0,$c1,$e0,$e1
0025BF  3               
0025BF  3               spr:	.byte 0,0,0
0025BF  3               
0025BF  3               ;xtmp:	.byte 0
0025BF  3               .endif
0025BF  3               
0025BF  3               ;-----------------------------------------------------------
0025BF  3               ; Get room address.
0025BF  3               ;-----------------------------------------------------------
0025BF  3               
0025BF  3               ;.repeat 273
0025BF  3               ;  .byte 0
0025BF  3               ;.endrep
0025BF  3               
0025BF  3               groom:
0025BF  3  A6 rr        	ldx scno 		; screen number.
0025C1  3  A0 00        	ldy #0
0025C3  3               groomx:
0025C3  3  A9 EE        	lda #<scdat 		; pointer to screens.
0025C5  3  85 66        	sta z80_l
0025C7  3  A9 34        	lda #>scdat
0025C9  3  85 67        	sta z80_h
0025CB  3               groom1:
0025CB  3  E0 00        	cpx #0			; is it the first one?
0025CD  3  F0 15        	beq groom0 		; no more screens to skip.
0025CF  3               
0025CF  3  18           	clc
0025D0  3  A5 66        	lda z80_l
0025D2  3  79 EE 34     	adc scdat,y 		; low byte of screen size.
0025D5  3  85 66        	sta z80_l
0025D7  3  C8           	iny			; point to high byte.
0025D8  3  A5 67        	lda z80_h
0025DA  3  79 EE 34     	adc scdat,y 		; high byte of screen size.
0025DD  3  85 67        	sta z80_h
0025DF  3  C8           	iny			; next address.
0025E0  3               
0025E0  3  CA           	dex 			; one less iteration.
0025E1  3  4C CB 25     	jmp groom1 		; loop until we reach the end.
0025E4  3               groom0:
0025E4  3  AD F3 34     	lda numsc 		; add displacement.
0025E7  3  0A           	asl a
0025E8  3  18           	clc			; add double displacement to address.
0025E9  3  65 66        	adc z80_l
0025EB  3  85 66        	sta z80_l
0025ED  3  A5 67        	lda z80_h
0025EF  3  69 00        	adc #0
0025F1  3  85 67        	sta z80_h
0025F3  3  60           	rts
0025F4  3               
0025F4  3               ;-----------------------------------------------------------
0025F4  3               ; Draw present room.
0025F4  3               ;-----------------------------------------------------------
0025F4  3               
0025F4  3               droom:
0025F4  3  AD 26 20     	lda wintop 		; window top.
0025F7  3  85 rr        	sta dispy		; set cursor y position.
0025F9  3               droom2:
0025F9  3  20 BF 25     	jsr groom 		; get address of current room.
0025FC  3  A9 00        	lda #0	 		; zero in accumulator.
0025FE  3  85 rr        	sta comcnt 		; reset compression counter.
002600  3  AD 28 20     	lda winhgt 		; height of window.
002603  3  85 rr        	sta rrow		; set row counter
002605  3               droom0:
002605  3  AD 27 20     	lda winlft 		; window left edge.
002608  3  85 rr        	sta dispx 		; set cursor x position.
00260A  3  AD 29 20     	lda winwid 		; width of window.
00260D  3  85 rr        	sta rcol		; set column counter
00260F  3               droom1:
00260F  3  20 20 26     	jsr flbyt 		; decompress next byte on the fly.
002612  3  20 5E 25     	jsr pattr2 		; show attributes and block.
002615  3  C6 rr        	dec rcol		; one less column.
002617  3  D0 F6        	bne droom1 		; repeat for entire line.
002619  3  E6 rr        	inc dispy		; move down one line.
00261B  3  C6 rr        	dec rrow 		; one less row.
00261D  3  D0 E6        	bne droom0 		; repeat for all rows.
00261F  3  60           	rts
002620  3               
002620  3               ;rcol:	.byte 0
002620  3               ;rrow:	.byte 0
002620  3               
002620  3               ;----------------------------------------------
002620  3               ; Decompress bytes on-the-fly.
002620  3               ;----------------------------------------------
002620  3               
002620  3               flbyt:
002620  3  A5 rr        	lda comcnt 		; compression counter.
002622  3  D0 21        	bne flbyt1		; any more to decompress?  yes.
002624  3               
002624  3  A0 00        	ldy #0
002626  3  B1 66        	lda (z80_hl),y 		; fetch next byte.
002628  3  E6 66        	inc z80_l 		; point to next cell.
00262A  3  D0 02        	bne :+
00262C  3  E6 67        	inc z80_h
00262E  3               :
00262E  3  C9 FF        	cmp #255 		; is this byte a control code?
002630  3  F0 01        	beq :+
002632  3  60           	rts 			; no, this byte is uncompressed.
002633  3               :
002633  3  B1 66        	lda (z80_hl),y 		; fetch byte type.
002635  3  85 rr        	sta combyt 		; set up the type.
002637  3  E6 66        	inc z80_l 		; point to quantity.
002639  3  D0 02        	bne :+
00263B  3  E6 67        	inc z80_h
00263D  3               :
00263D  3  B1 66        	lda (z80_hl),y 		; get quantity.
00263F  3  E6 66        	inc z80_l 		; point to next byte.
002641  3  D0 02        	bne :+
002643  3  E6 67        	inc z80_h
002645  3               :
002645  3               flbyt1:
002645  3  85 rr        	sta comcnt 		; store new quantity.
002647  3  C6 rr        	dec comcnt		; one less.
002649  3  A5 rr        	lda combyt 		; byte to expand.
00264B  3  60           	rts
00264C  3               
00264C  3               ;combyt:	.byte 0			; byte type compressed.
00264C  3               ;comcnt:	.byte 0			; compression counter.
00264C  3               
00264C  3               ;------------------------------------------
00264C  3               ; Ladder down check.
00264C  3               ;
00264C  3               ; Input:
00264C  3               ;  IX = sprite pointer
00264C  3               ;------------------------------------------
00264C  3               
00264C  3               .if lflag
00264C  3               laddd:
00264C  3               	ldy #9
00264C  3               	lda (z80_ix),y		; x coordinate.
00264C  3               	sta dispx
00264C  3               
00264C  3               	ldy #8
00264C  3               	lda (z80_ix),y		; y coordinate.
00264C  3               	and #254		; make it even.
00264C  3               	sta (z80_ix),y 		; reset it.
00264C  3               	clc 			; look down 16 pixels.
00264C  3               numsp5:
00264C  3               	adc #SPR_HGT
00264C  3               	sta dispy		; coords in dispx,dispy.
00264C  3               	jmp laddv
00264C  3               
00264C  3               ;------------------------------------------
00264C  3               ; Ladder up check.
00264C  3               ;
00264C  3               ; Input:
00264C  3               ;  IX = sprite pointer
00264C  3               ;
00264C  3               ; Output:
00264C  3               ;  A  = 0 is ok, A <>0 is not ok
00264C  3               ;------------------------------------------
00264C  3               
00264C  3               laddu:
00264C  3               	ldy #9
00264C  3               	lda (z80_ix),y		; x coordinate.
00264C  3               	sta dispx
00264C  3               
00264C  3               	ldy #8
00264C  3               	lda (z80_ix),y		; y coordinate.
00264C  3               	and #254 		; make it even.
00264C  3               	sta (z80_ix),y		; reset it.
00264C  3               	clc 			; look 2 pixels above feet.
00264C  3               numsp6:
00264C  3               	adc #SPR_HGT-2
00264C  3               	sta dispy		; coords in dispx,dispy.
00264C  3               laddv:
00264C  3               	jsr tstbl 		; get map address.
00264C  3               	jsr ldchk 		; standard ladder check.
00264C  3               	beq :+
00264C  3               	rts 			; no way through.
00264C  3               :
00264C  3               	inc bufaddr 		; look right one cell.
00264C  3               	bne :+
00264C  3               	inc bufaddr+1
00264C  3               :
00264C  3               	jsr ldchk 		; do the check.
00264C  3               	beq :+
00264C  3               	rts 			; impassable.
00264C  3               :
00264C  3               	lda dispx 		; y coordinate.
00264C  3               	and #7 			; position straddling block cells.
00264C  3               	bne :+
00264C  3               	rts 			; no more checks needed.
00264C  3               :
00264C  3               	inc bufaddr 		; look to third cell.
00264C  3               	bne :+
00264C  3               	inc bufaddr+1
00264C  3               :
00264C  3               	jsr ldchk 		; do the check.
00264C  3               	rts  			; return with zero flag set accordingly.
00264C  3               .endif
00264C  3               
00264C  3               ;---------------------------------------------------------
00264C  3               ; Can go up check.
00264C  3               ;
00264C  3               ; Input:
00264C  3               ;  IX = sprite pointer
00264C  3               ;
00264C  3               ; Output:
00264C  3               ;  A  = 0 is ok, A <>0 is not ok
00264C  3               ;---------------------------------------------------------
00264C  3               
00264C  3               cangu:
00264C  3  A0 09        	ldy #9
00264E  3  B1 68        	lda (z80_ix),y		; x coordinate.
002650  3  85 rr        	sta dispx
002652  3  A0 08        	ldy #8
002654  3  B1 68        	lda (z80_ix),y 		; y coordinate.
002656  3  38           	sec
002657  3  E9 02        	sbc #2
002659  3  85 rr        	sta dispy		; coords in dispx,dispy.
00265B  3  20 F6 28     	jsr tstbl 		; get map address.
00265E  3  20 0E 28     	jsr lrchk 		; standard left/right check.
002661  3  F0 01        	beq :+
002663  3  60           	rts			; no way through.
002664  3               :
002664  3  E6 rr        	inc bufaddr		; look right one cell.
002666  3  D0 02        	bne :+
002668  3  E6 rr        	inc bufaddr+1
00266A  3               :
00266A  3  20 0E 28     	jsr lrchk 		; do the check.
00266D  3  F0 01        	beq :+
00266F  3  60           	rts			; impassable.
002670  3               :
002670  3  A5 rr        	lda dispx		; x coordinate.
002672  3  29 07        	and #7			; position straddling block cells.
002674  3  D0 01        	bne :+
002676  3  60           	rts			; no more checks needed.
002677  3               :
002677  3  E6 rr        	inc bufaddr		; look to third cell.
002679  3  D0 02        	bne :+
00267B  3  E6 rr        	inc bufaddr+1
00267D  3               :
00267D  3  20 0E 28     	jsr lrchk		; do the check.
002680  3  60           	rts 			; return with zero flag set accordingly.
002681  3               
002681  3               ;---------------------------------------------------------
002681  3               ; Can go down check.
002681  3               ;
002681  3               ; Input:
002681  3               ;  IX = sprite pointer
002681  3               ;
002681  3               ; Output:
002681  3               ;  A  = 0 is ok, A <>0 is not ok
002681  3               ;---------------------------------------------------------
002681  3               
002681  3               ;.repeat 264
002681  3               ;  .byte 0
002681  3               ;.endrep
002681  3               
002681  3               cangd:
002681  3  A0 09        	ldy #9
002683  3  B1 68        	lda (z80_ix),y 		; x coordinate.
002685  3  85 rr        	sta dispx
002687  3  A0 08        	ldy #8
002689  3  B1 68        	lda (z80_ix),y		; y coordinate.
00268B  3  18           	clc
00268C  3               numsp3:
00268C  3  69 10        	adc #SPR_HGT 		; look down 16 pixels.
00268E  3  85 rr        	sta dispy		; coords in dispx,dispy.
002690  3  20 F6 28     	jsr tstbl 		; get map address.
002693  3  20 23 28     	jsr plchk 		; block, platform check.
002696  3  F0 01        	beq :+
002698  3  60           	rts			; no way through.
002699  3               :
002699  3  E6 rr        	inc bufaddr		; look right one cell.
00269B  3  D0 02        	bne :+
00269D  3  E6 rr        	inc bufaddr+1
00269F  3               :
00269F  3  20 23 28     	jsr plchk		; block, platform check.
0026A2  3  F0 01        	beq :+
0026A4  3  60           	rts			; impassable.
0026A5  3               :
0026A5  3  A5 rr        	lda dispx		; x coordinate.
0026A7  3  29 07        	and #7			; position straddling block cells.
0026A9  3  D0 01        	bne :+
0026AB  3  60           	rts			; no more checks needed.
0026AC  3               :
0026AC  3  E6 rr        	inc bufaddr		; look to third cell.
0026AE  3  D0 02        	bne :+
0026B0  3  E6 rr        	inc bufaddr+1
0026B2  3               :
0026B2  3  20 23 28     	jsr plchk		; block, platform check.
0026B5  3  60           	rts			; return with zero flag set accordingly.
0026B6  3               
0026B6  3               ;---------------------------------------------------------
0026B6  3               ; Can go left check.
0026B6  3               ;
0026B6  3               ; Input:
0026B6  3               ;  IX = sprite pointer
0026B6  3               ;
0026B6  3               ; Output:
0026B6  3               ;  A  = 0 is ok, A <>0 is not ok
0026B6  3               ;---------------------------------------------------------
0026B6  3               
0026B6  3               cangl:
0026B6  3  A0 08        	ldy #8
0026B8  3  B1 68        	lda (z80_ix),y 		; y coordinate.
0026BA  3  85 rr        	sta dispy
0026BC  3  A0 09        	ldy #9
0026BE  3  B1 68        	lda (z80_ix),y 		; x coordinate.
0026C0  3  38           	sec
0026C1  3  E9 02        	sbc #2			; look left 2 pixels.
0026C3  3  85 rr        	sta dispx		; coords in dispx,dispy.
0026C5  3  4C E7 27     	jmp cangh		; test if we can go there.
0026C8  3               
0026C8  3               ;---------------------------------------------------------
0026C8  3               ; Can go right check.
0026C8  3               ;
0026C8  3               ; Input:
0026C8  3               ;  IX = sprite pointer
0026C8  3               ;
0026C8  3               ; Output:
0026C8  3               ;  A  = 0 is ok, A <>0 is not ok
0026C8  3               ;---------------------------------------------------------
0026C8  3               
0026C8  3  00 00 00 00  .repeat 272
0026CC  3  00 00 00 00  
0026D0  3  00 00 00 00  
0027D8  3                 .byte 0
0027D8  3               .endrep
0027D8  3               
0027D8  3               cangr:
0027D8  3  A0 08        	ldy #8
0027DA  3  B1 68        	lda (z80_ix),y		; y coordinate.
0027DC  3  85 rr        	sta dispy
0027DE  3  A0 09        	ldy #9
0027E0  3  B1 68        	lda (z80_ix),y		; x coordinate.
0027E2  3  18           	clc
0027E3  3  69 10        	adc #16			; look right 16 pixels.
0027E5  3  85 rr        	sta dispx		; coords in dispx,dispy.
0027E7  3               cangh:
0027E7  3               cangh2:
0027E7  3  A9 03        	lda #(SPR_HGT/8+1)	; default rows to write.
0027E9  3  85 63        	sta z80_b
0027EB  3  A5 rr        	lda dispy		; y position.
0027ED  3  29 07        	and #7			; does x straddle cells?
0027EF  3  D0 02        	bne cangh0		; yes, loop counter is good.
0027F1  3  C6 63        	dec z80_b		; one less row to write.
0027F3  3               cangh0:
0027F3  3  20 F6 28     	jsr tstbl		; get map address.
0027F6  3               cangh1:
0027F6  3  20 0E 28     	jsr lrchk		; standard left/right check.
0027F9  3  F0 01        	beq :+
0027FB  3  60           	rts			; no way through.
0027FC  3               :
0027FC  3  48           	pha
0027FD  3  18           	clc
0027FE  3  A5 rr        	lda bufaddr
002800  3  69 20        	adc #32			; look down.
002802  3  85 rr        	sta bufaddr
002804  3  90 02        	bcc :+
002806  3  E6 rr        	inc bufaddr+1
002808  3               :
002808  3  68           	pla
002809  3               
002809  3  C6 63        	dec z80_b
00280B  3  D0 E9        	bne cangh1
00280D  3  60           	rts
00280E  3               
00280E  3               ;-------------------------------------
00280E  3               ; Check left/right movement is okay.
00280E  3               ;
00280E  3               ; Input:
00280E  3               ;  bufaddr = MAP + x/8 + y/8*32
00280E  3               ;
00280E  3               ; Output:
00280E  3               ;  A  = 0 is ok, A <>0 is not ok
00280E  3               ;-------------------------------------
00280E  3               
00280E  3               lrchk:
00280E  3  A0 00        	ldy #0
002810  3  B1 rr        	lda (bufaddr),y		; fetch map cell.
002812  3  C9 02        	cmp #WALL 		; is it passable?
002814  3  F0 0A        	beq lrchkx		; no.
002816  3               
002816  3  C9 04        	cmp #FODDER		; fodder has to be dug.
002818  3  F0 06        	beq lrchkx		; not passable.
00281A  3  A9 00        	lda #0
00281C  3  60           	rts
00281D  3               
00281D  3               ;--------------------------------------------------------------
00281D  3               ; Called by mmenu
00281D  3               ;--------------------------------------------------------------
00281D  3               
00281D  3               always:
00281D  3  A9 FF        	lda #255		; report it as okay.
00281F  3  60           	rts
002820  3               
002820  3               lrchkx:
002820  3  A9 01        	lda #1 			; reset all bits.
002822  3  60           	rts
002823  3               
002823  3               
002823  3               ;--------------------------------------------------------------
002823  3               ; Check platform or solid item is not in way.
002823  3               ;
002823  3               ; Input:
002823  3               ;  bufaddr = MAP + x/8 + y/8*32
002823  3               ;
002823  3               ; Output:
002823  3               ;  A  = 0 is ok, A <>0 is not ok
002823  3               ;--------------------------------------------------------------
002823  3               
002823  3               plchk:
002823  3  A0 00        	ldy #0
002825  3  B1 rr        	lda (bufaddr),y 	; fetch map cell.
002827  3  C9 02        	cmp #WALL 		; is it passable?
002829  3  F0 F5        	beq lrchkx		; no.
00282B  3               .if pflag .or dflag
00282B  3               	cmp #FODDER		; fodder has to be dug.
00282B  3               	beq lrchkx		; not passable.
00282B  3               .endif
00282B  3  C9 01        	cmp #PLATFM		; platform is solid.
00282D  3  F0 03        	beq plchkx		; not passable.
00282F  3               .if lflag
00282F  3               	cmp #LADDER		; is it a ladder?
00282F  3               	beq lrchkx		; on ladder, deny movement.
00282F  3               .endif
00282F  3               plchk0:
00282F  3  A9 00        	lda #0			; report as ok
002831  3  60           	rts
002832  3               plchkx:
002832  3  A5 rr        	lda dispy		; x coordinate.
002834  3  29 07        	and #7			; position straddling blocks.
002836  3  F0 E8        	beq lrchkx		; on platform, deny movement.
002838  3  4C 2F 28     	jmp plchk0
00283B  3               
00283B  3               ;--------------------------------------------------------------
00283B  3               ; Check ladder is available.
00283B  3               ;
00283B  3               ; Input:
00283B  3               ;  bufaddr = MAP + x/8 + y/8*32
00283B  3               ;
00283B  3               ; Output:
00283B  3               ;  A  = 0 is ok, A <>0 is not ok
00283B  3               ;--------------------------------------------------------------
00283B  3               
00283B  3               .if lflag
00283B  3               ldchk:
00283B  3               	ldy #0
00283B  3               	lda (bufaddr),y 	; fetch cell.
00283B  3               	cmp #LADDER 		; is it a ladder?
00283B  3               	beq :+
00283B  3               	lda #1
00283B  3               	rts  			; return with zero flag set accordingly.
00283B  3               :
00283B  3               	lda #0
00283B  3               	rts
00283B  3               .endif
00283B  3               
00283B  3               ;--------------------------------------------------------------
00283B  3               ; Get collectables.
00283B  3               ;--------------------------------------------------------------
00283B  3               
00283B  3               .if cflag
00283B  3               getcol:
00283B  3                       lda #COLECT             ; collectable blocks.
00283B  3                       sta z80_b
00283B  3                       jsr tded                ; test for collectable blocks.
00283B  3                       cmp z80_b               ; did we find one?
00283B  3                       beq :+
00283B  3                       rts                     ; none were found, job done.
00283B  3               :
00283B  3                       jsr gtblk               ; get block.
00283B  3                       jsr evnt20              ; collected block event.
00283B  3                       jmp getcol              ; repeat until none left.
00283B  3               
00283B  3               ; Get collectable block.
00283B  3               
00283B  3               gtblk:
00283B  3               	ldy #0
00283B  3               	lda (bufaddr),y
00283B  3               	sta z80_a
00283B  3                       lda #0
00283B  3                       sta (bufaddr),y		; make it empty now.
00283B  3               
00283B  3               	lda bufaddr		; set dispx
00283B  3               	and #31
00283B  3               	sta dispx
00283B  3               
00283B  3               	lda bufaddr+1		; Set dispy
00283B  3               	sec
00283B  3               	sbc #>MAP
00283B  3               	sta bufaddr+1
00283B  3               	asl bufaddr
00283B  3               	rol bufaddr+1
00283B  3               	asl bufaddr
00283B  3               	rol bufaddr+1
00283B  3               	asl bufaddr
00283B  3               	rol bufaddr+1
00283B  3               	lda bufaddr+1
00283B  3               	sta dispy
00283B  3               
00283B  3               	lda colpatt		; get blocknr
00283B  3               	sta z80_e		; displacement in e.
00283B  3               	lda #0
00283B  3               	sta z80_d		; no high byte.
00283B  3               	asl z80_e  		; multiply char by 8.
00283B  3               	rol z80_d
00283B  3               	asl z80_e
00283B  3               	rol z80_d
00283B  3               	asl z80_e
00283B  3               	rol z80_d
00283B  3               	clc
00283B  3               	lda z80_e
00283B  3               	adc #<chgfx 		; address of graphics.
00283B  3               	sta tileaddr
00283B  3               	lda z80_d
00283B  3               	adc #>chgfx
00283B  3               	sta tileaddr+1
00283B  3               	jsr gprad 		; get screen address.
00283B  3               	ldx #7			; number of pixel rows to write.
00283B  3               gtblk0:
00283B  3               	ldy #0
00283B  3               	lda (tileaddr),y 	; get image byte.
00283B  3               	ldy scrtab,x
00283B  3               	eor (scraddr),y 	; XOR tile on screen
00283B  3               	sta (scraddr),y 	; copy to screen.
00283B  3               	inc tileaddr 		; next image byte.
00283B  3               	bne :+
00283B  3               	inc tileaddr+1
00283B  3               :
00283B  3               	dex	 		; repeat for 8 pixel rows.
00283B  3               	bpl gtblk0
00283B  3               	rts
00283B  3               .endif
00283B  3               
00283B  3               ;--------------------------------------------------------------
00283B  3               ; Touched deadly block check.
00283B  3               ; returns with DEADLY (must be non-zero) in accumulator if true.
00283B  3               ;
00283B  3               ; Input:
00283B  3               ;  IX = sprite address
00283B  3               ;
00283B  3               ; Output:
00283B  3               ;  A  = 0 is ok, A=5 is not ok
00283B  3               ;--------------------------------------------------------------
00283B  3               
00283B  3               tded:
00283B  3  A0 08        	ldy #8
00283D  3  B1 68        	lda (z80_ix),y 		; y coordinate.
00283F  3  85 rr        	sta dispy
002841  3  C8           	iny
002842  3  B1 68        	lda (z80_ix),y 		; x coordinate.
002844  3  85 rr        	sta dispx		; coords in dispx,dispy.
002846  3  20 F6 28     	jsr tstbl		; get map address.
002849  3  48           	pha
00284A  3  A9 1F        	lda #31			; default distance to next line down.
00284C  3  85 64        	sta z80_e
00284E  3  68           	pla
00284F  3  C5 63        	cmp z80_b		; is this the required block?
002851  3  D0 01        	bne :+
002853  3  60           	rts			; yes.
002854  3               :
002854  3  E6 rr        	inc bufaddr 		; next cell.
002856  3  D0 02        	bne :+
002858  3  E6 rr        	inc bufaddr+1
00285A  3               :
00285A  3  A0 00        	ldy #0
00285C  3  B1 rr        	lda (bufaddr),y		; fetch type.
00285E  3  C5 63        	cmp z80_b 		; is this deadly/custom?
002860  3  D0 01        	bne :+
002862  3  60           	rts			; yes.
002863  3               :
002863  3  A5 rr        	lda dispx		; horizontal position.
002865  3  85 62        	sta z80_c 		; store column in c register.
002867  3  29 07        	and #7			; is it straddling cells?
002869  3  D0 03        	bne :+
00286B  3  4C 7F 28     	jmp tded0		; no.
00286E  3               :
00286E  3  E6 rr        	inc bufaddr 		; last cell.
002870  3  D0 02        	bne :+
002872  3  E6 rr        	inc bufaddr+1
002874  3               :
002874  3  A0 00        	ldy #0
002876  3  B1 rr        	lda (bufaddr),y 	; fetch type.
002878  3  C5 63        	cmp z80_b		; is this the block?
00287A  3  D0 01        	bne :+
00287C  3  60           	rts			; yes.
00287D  3               :
00287D  3  C6 64        	dec z80_e		; one less cell to next row down.
00287F  3               tded0:
00287F  3  18           	clc 			; point to next row.
002880  3  A5 rr        	lda bufaddr
002882  3  65 64        	adc z80_e
002884  3  85 rr        	sta bufaddr
002886  3  90 02        	bcc :+
002888  3  E6 rr        	inc bufaddr+1
00288A  3               :
00288A  3  A0 00        	ldy #0
00288C  3  B1 rr        	lda (bufaddr),y		; fetch left cell block.
00288E  3  C5 63        	cmp z80_b		; is this fatal?
002890  3  D0 01        	bne :+
002892  3  60           	rts			; yes.
002893  3               :
002893  3  E6 rr        	inc bufaddr 		; next cell.
002895  3  D0 02        	bne :+
002897  3  E6 rr        	inc bufaddr+1
002899  3               :
002899  3  A0 00        	ldy #0
00289B  3  B1 rr        	lda (bufaddr),y 	; fetch type.
00289D  3  C5 63        	cmp z80_b		; is this fatal?
00289F  3  D0 01        	bne :+
0028A1  3  60           	rts			; yes.
0028A2  3               :
0028A2  3  A5 62        	lda z80_c		; horizontal position.
0028A4  3  29 07        	and #7			; is it straddling cells?
0028A6  3  D0 03        	bne :+
0028A8  3  4C BA 28     	jmp tded1 		; no.
0028AB  3               :
0028AB  3  E6 rr        	inc bufaddr		; last cell.
0028AD  3  D0 02        	bne :+
0028AF  3  E6 rr        	inc bufaddr+1
0028B1  3               :
0028B1  3  A0 00        	ldy #0
0028B3  3  B1 rr        	lda (bufaddr),y		; fetch type.
0028B5  3  C5 63        	cmp z80_b		; is this fatal?
0028B7  3  D0 01        	bne :+
0028B9  3  60           	rts			; yes.
0028BA  3               :
0028BA  3               tded1:
0028BA  3  A5 rr        	lda dispy		; vertical position.
0028BC  3  29 07        	and #7 			; is it straddling cells?
0028BE  3  D0 01        	bne :+
0028C0  3  60           	rts			; no, job done.
0028C1  3               :
0028C1  3  18           	clc			; point to next row.
0028C2  3  A5 rr        	lda bufaddr
0028C4  3  65 64        	adc z80_e
0028C6  3  85 rr        	sta bufaddr
0028C8  3  90 02        	bcc :+
0028CA  3  E6 rr        	inc bufaddr+1
0028CC  3               :
0028CC  3  A0 00        	ldy #0
0028CE  3  B1 rr        	lda (bufaddr),y 	; fetch left cell block.
0028D0  3  C5 63        	cmp z80_b		; is this fatal?
0028D2  3  D0 01        	bne :+
0028D4  3  60           	rts			; yes.
0028D5  3               :
0028D5  3  E6 rr        	inc bufaddr		; next cell.
0028D7  3  D0 02        	bne :+
0028D9  3  E6 rr        	inc bufaddr+1
0028DB  3               :
0028DB  3  A0 00        	ldy #0
0028DD  3  B1 rr        	lda (bufaddr),y 	; fetch type.
0028DF  3  C5 63        	cmp z80_b		; is this fatal?
0028E1  3  D0 01        	bne :+
0028E3  3  60           	rts			; yes.
0028E4  3               :
0028E4  3  A5 62        	lda z80_c		; horizontal position.
0028E6  3  29 07        	and #7			; is it straddling cells?
0028E8  3  D0 01        	bne :+
0028EA  3  60           	rts			; no.
0028EB  3               :
0028EB  3  E6 rr        	inc bufaddr		; last cell.
0028ED  3  D0 02        	bne :+
0028EF  3  E6 rr        	inc bufaddr+1
0028F1  3               :
0028F1  3  A0 00        	ldy #0
0028F3  3  B1 rr        	lda (bufaddr),y		; fetch final type.
0028F5  3  60           	rts 			; return with final type in accumulator.
0028F6  3               
0028F6  3               ;---------------------------------------------------
0028F6  3               ; Fetch block type at (dispx, dispy).
0028F6  3               ;
0028F6  3               ; Output:
0028F6  3               ;  A = block type
0028F6  3               ;---------------------------------------------------
0028F6  3               
0028F6  3               tstbl:
0028F6  3  A5 rr        	lda dispy 		; fetch y coord.
0028F8  3  4A           	lsr a			; bufaddr = y/8
0028F9  3  4A           	lsr a
0028FA  3  4A           	lsr a
0028FB  3  85 rr        	sta chary
0028FD  3               
0028FD  3  85 rr        	sta bufaddr
0028FF  3  A9 00        	lda #0
002901  3  85 rr        	sta bufaddr+1
002903  3               
002903  3  06 rr        	asl bufaddr  		; bufaddr = y/8 * 32
002905  3  26 rr        	rol bufaddr+1
002907  3  06 rr        	asl bufaddr
002909  3  26 rr        	rol bufaddr+1
00290B  3  06 rr        	asl bufaddr
00290D  3  26 rr        	rol bufaddr+1
00290F  3  06 rr        	asl bufaddr
002911  3  26 rr        	rol bufaddr+1
002913  3  06 rr        	asl bufaddr
002915  3  26 rr        	rol bufaddr+1
002917  3               
002917  3  A5 rr        	lda dispx		; x/8
002919  3  4A           	lsr a
00291A  3  4A           	lsr a
00291B  3  4A           	lsr a
00291C  3  85 rr        	sta charx
00291E  3               
00291E  3  18           	clc			; bufaddr = MAP + x/8 + y/8*32
00291F  3  65 rr        	adc bufaddr
002921  3  69 00        	adc #<MAP
002923  3  85 rr        	sta bufaddr
002925  3  A5 rr        	lda bufaddr+1
002927  3  69 DD        	adc #>MAP
002929  3  85 rr        	sta bufaddr+1
00292B  3               
00292B  3  A0 00        	ldy #0
00292D  3  B1 rr        	lda (bufaddr),y 	; fetch byte there.
00292F  3  60           	rts
002930  3               
002930  3               
002930  3               ;-------------------------------------------------------------------
002930  3               ; Jump - if we can.
002930  3               ; Requires initial speed to be set up in accumulator prior to call.
002930  3               ;
002930  3               ; Input:
002930  3               ;  IX = sprite address
002930  3               ;-------------------------------------------------------------------
002930  3               
002930  3               jump:
002930  3  A0 0D        	ldy #13
002932  3  B1 68        	lda (z80_ix),y		; jump table low.
002934  3  A0 0E        	ldy #14
002936  3  11 68        	ora (z80_ix),y		; jump table high.
002938  3  F0 01        	beq :+
00293A  3  60           	rts			; already in the air.
00293B  3               :
00293B  3  A9 38        	lda #>jtab
00293D  3  A0 0E        	ldy #14
00293F  3  91 68        	sta (z80_ix),y		; set jump high.
002941  3  A9 1F        	lda #<jtab		; jump table start.
002943  3  A0 0D        	ldy #13
002945  3  91 68        	sta (z80_ix),y		; set jump low.
002947  3  60           	rts
002948  3               
002948  3               ; Jump table.
002948  3               
002948  3               ;jtab:
002948  3               ;	.byte 248,250,252
002948  3               ;	.byte 254,254,255
002948  3               ;	.byte 255,255,0,0
002948  3               ;	.byte 0,1,1,1,2,2
002948  3               ;	.byte 4,6,8,8,8,99
002948  3               
002948  3               ;------------------------------------------------
002948  3               ; Random numbers code.
002948  3               ; Pseudo-random number generator, 8-bit.
002948  3               ;
002948  3               ; Output:
002948  3               ;  RND = random number
002948  3               ;------------------------------------------------
002948  3               
002948  3               random:
002948  3  A5 rr        	lda seed
00294A  3  F0 05        	beq doEor
00294C  3  0A           	asl a
00294D  3  F0 04        	beq noEor
00294F  3  90 02        	bcc noEor
002951  3  49 1D        doEor:	eor #$1d
002953  3  85 rr        noEor:	sta seed
002955  3  60           	rts
002956  3               
002956  3  A5 rr        	lda seed		; get last random number.
002958  3  0A           	asl a
002959  3  0A           	asl a
00295A  3  18           	clc
00295B  3  65 rr        	adc seed
00295D  3  18           	clc
00295E  3  69 45        	adc #$45
002960  3  85 rr        	sta seed		; store new seed.
002962  3  85 rr        	sta varrnd		; return number in variable.
002964  3  60           	rts
002965  3               
002965  3               ;--------------------------------------------------------
002965  3               ; Keys
002965  3               ;
002965  3               ; Out: joyval=x65FUDLR (bit cleared if key pressed)
002965  3               ;             ||||||||
002965  3               ;             |||||||+> Right    KEY 0  - X
002965  3               ;             ||||||+-> Left     KEY 1  - Z
002965  3               ;             |||||+--> Down     KEY 2  - .
002965  3               ;             ||||+---> Up       KEY 3  - ;
002965  3               ;             |||+----> Fire1    KEY 4  - SPC
002965  3               ;             ||+-----> Fire2    KEY 5  - Q
002965  3               ;             |+------> Fire3    KEY 6  - P
002965  3               ;             +-------> Not used
002965  3               ;
002965  3               ;                       Option1  KEY 7  - 1
002965  3               ;                       Option2  KEY 8  - 2
002965  3               ;                       Option3  KEY 9  - 3
002965  3               ;                       Option4  KEY 10 - 4
002965  3               ;--------------------------------------------------------
002965  3               
002965  3               ;              X   Z   .   ;  SPC  Q   P
002965  3               ;keys:   .byte $35,$15,$93,$22,$90,$04,$14       ; Keys defined by game designer.
002965  3               ;        .byte $21,$11,$01,$92                   ; menu options.
002965  3  03 01 02 04  jkeys:  .byte $03,$01,$02,$04,$00,$04,$14       ; Joykey keys
002969  3  00 04 14     
00296C  3  21 11 01 92          .byte $21,$11,$01,$92                   ; menu options.
002970  3               
002970  3               ;-------------------------------------------------------
002970  3               ; Joystick and keyboard reading routines.
002970  3               ;
002970  3               ; contrl = 0, Keyboard
002970  3               ;          1, JoyKeyb
002970  3               ;          2, JoyMMC
002970  3               ;-------------------------------------------------------
002970  3               
002970  3               joykey:
002970  3  A5 rr        	lda contrl 		; control flag.
002972  3  C9 01        	cmp #1
002974  3  D0 03        	bne :+
002976  3  4C E4 38     	jmp joy1 		; read keyboard joystick
002979  3               :
002979  3  C9 02        	cmp #2
00297B  3  D0 03        	bne :+
00297D  3  4C 14 39     	jmp joy2 		; read MMC joystick.
002980  3               :
002980  3               ; Keyboard controls.
002980  3               
002980  3  A9 00        	lda #0		 	; zero reading.
002982  3  85 64        	sta z80_e
002984  3               
002984  3  A0 06        	ldy #6	 		; address of last key.
002986  3               joyke0:
002986  3  B9 20 38     	lda keys,y 		; get key from table.
002989  3  20 BB 38     	jsr ktest		; being pressed?
00298C  3  26 64        	rol z80_e 		; rotate into reading.
00298E  3               
00298E  3  88           	dey		 	; next key.
00298F  3  10 F5        	bpl joyke0 		; repeat for all keys.
002991  3  A5 64        	lda z80_e 		; copy e register to accumulator.
002993  3  85 rr        	sta joyval		; remember value.
002995  3  60           	rts
002996  3               
002996  3               ;---------------------------------------------------------------
002996  3               ; Display message.
002996  3               ;
002996  3               ; Input:
002996  3               ;  A = message number
002996  3               ;---------------------------------------------------------------
002996  3               
002996  3               dmsg:
002996  3  AA           	tax
002997  3  A9 0D        	lda #<msgdat		; pointer to messages.
002999  3  85 66        	sta z80_l
00299B  3  A9 34        	lda #>msgdat
00299D  3  85 67        	sta z80_h
00299F  3  20 B7 2A     	jsr getwrd		; get message number.
0029A2  3               dmsg3:
0029A2  3  20 A4 2A     	jsr preprt		; pre-printing stuff.
0029A5  3  20 7D 23     	jsr checkx		; make sure we"re in a printable range.
0029A8  3  A5 rr        	lda prtmod		; print mode.
0029AA  3  D0 47        	bne bmsg1		; no, double-height text.
0029AC  3               dmsg0:
0029AC  3  A5 67        	lda z80_h		; store string pointer.
0029AE  3  48           	pha
0029AF  3  A5 66        	lda z80_l
0029B1  3  48           	pha
0029B2  3               
0029B2  3  A0 00        	ldy #0
0029B4  3  B1 66        	lda (z80_hl),y		; fetch byte to display.
0029B6  3  29 7F        	and #127		; remove any end marker.
0029B8  3  C9 0D        	cmp #13
0029BA  3  F0 24        	beq dmsg1
0029BC  3  20 11 25     	jsr pchar		; display character.
0029BF  3  20 91 2A     	jsr nexpos 		; display position.
0029C2  3  D0 03        	bne dmsg2		; not on a new line.
0029C4  3  20 96 2A     	jsr nexlin		; next line down.
0029C7  3               dmsg2:
0029C7  3  68           	pla			; retrieve string pointer
0029C8  3  85 66        	sta z80_l
0029CA  3  68           	pla
0029CB  3  85 67        	sta z80_h
0029CD  3               
0029CD  3  A0 00        	ldy #0
0029CF  3  B1 66        	lda (z80_hl),y		; fetch last character.
0029D1  3  0A           	asl a  			; was it the end?
0029D2  3  90 03        	bcc :+
0029D4  3  4C D0 23     	jmp dscor2		; yes, job done.
0029D7  3               :
0029D7  3  E6 66        	inc z80_l		; next character to display.
0029D9  3  D0 02        	bne :+
0029DB  3  E6 67        	inc z80_h
0029DD  3               :
0029DD  3  4C AC 29     	jmp dmsg0
0029E0  3               dmsg1:
0029E0  3  E6 rr        	inc dispy
0029E2  3  A5 rr        	lda dispy
0029E4  3  C9 18        	cmp #24
0029E6  3  90 04        	bcc dmsg4
0029E8  3  A9 00        	lda #0
0029EA  3  85 rr        	sta dispy
0029EC  3               dmsg4:
0029EC  3  A9 00        	lda #0
0029EE  3  85 rr        	sta dispx
0029F0  3  4C C7 29     	jmp dmsg2
0029F3  3               
0029F3  3               ;prtmod:	.byte 0            	; print mode, 0 = standard, 1 = double-height.
0029F3  3               
0029F3  3               ;----------------------------------------------------------
0029F3  3               ; Display message in big text.
0029F3  3               ;
0029F3  3               ; Input:
0029F3  3               ;  HL = string pointer
0029F3  3               ;----------------------------------------------------------
0029F3  3               
0029F3  3               bmsg1:
0029F3  3  A0 00        	ldy #0
0029F5  3  B1 66        	lda (z80_hl),y 		; get character to display.
0029F7  3  29 7F        	and #127		; only want 7 bits.
0029F9  3  C9 0D        	cmp #13
0029FB  3  F0 13        	beq bmsg2
0029FD  3  20 25 2A     	jsr bchar 		; display big char.
002A00  3               bmsg3:
002A00  3  A0 00        	ldy #0
002A02  3  B1 66        	lda (z80_hl),y 		; look at last character.
002A04  3  48           	pha
002A05  3  E6 66        	inc z80_l 		; next character in list.
002A07  3  D0 02        	bne :+
002A09  3  E6 67        	inc z80_h
002A0B  3               :
002A0B  3  68           	pla
002A0C  3  0A           	asl a  			; was terminator flag set?
002A0D  3  90 E4        	bcc bmsg1		; no, keep going.
002A0F  3  60           	rts
002A10  3               bmsg2:
002A10  3  A9 00        	lda #0
002A12  3  85 rr        	sta dispx
002A14  3  E6 rr        	inc dispy
002A16  3  E6 rr        	inc dispy
002A18  3  A5 rr        	lda dispy
002A1A  3  C9 17        	cmp #23
002A1C  3  90 E2        	bcc bmsg3
002A1E  3  A9 00        	lda #0
002A20  3  85 rr        	sta dispy
002A22  3  4C 00 2A     	jmp bmsg3
002A25  3               
002A25  3               ;----------------------------------------------------------
002A25  3               ; Big character display.
002A25  3               ;
002A25  3               ; Input:
002A25  3               ;  A = character
002A25  3               ;----------------------------------------------------------
002A25  3               
002A25  3               bchar:
002A25  3  85 64        	sta z80_e		; save char in lb
002A27  3  A9 00        	lda #0
002A29  3  85 65        	sta z80_d		; reset hb
002A2B  3               
002A2B  3  06 64        	asl z80_e 		; multiply char by 8.
002A2D  3  26 65        	rol z80_d
002A2F  3  06 64        	asl z80_e
002A31  3  26 65        	rol z80_d
002A33  3  06 64        	asl z80_e
002A35  3  26 65        	rol z80_d		; de = a*8
002A37  3               
002A37  3  18           	clc			; de = Fontpointer + a*8
002A38  3  A5 64        	lda z80_e
002A3A  3  69 1F        	adc #<(FONT-256) 		; address of font.
002A3C  3  85 64        	sta z80_e
002A3E  3  A5 65        	lda z80_d
002A40  3  69 34        	adc #>(FONT-256)
002A42  3  85 65        	sta z80_d
002A44  3               
002A44  3  20 C2 24     	jsr gprad 		; get screen address.
002A47  3               
002A47  3  A2 00        	ldx #0			; height of character in font.
002A49  3               bchar0:
002A49  3  A0 00        	ldy #0
002A4B  3  B1 64        	lda (z80_de),y 		; get a bit of the font.
002A4D  3               
002A4D  3               .if gflag
002A4D  3  2D 6B 39     	and andeor
002A50  3  4D 6C 39     	eor andeor+1
002A53  3               .endif
002A53  3               .if iflag
002A53  3               	eor #$ff
002A53  3               .endif
002A53  3               
002A53  3  91 rr        	sta (scraddr),y
002A55  3  48           	pha
002A56  3  20 EB 2D     	jsr nline 		; next line down.
002A59  3  68           	pla
002A5A  3  91 rr        	sta (scraddr),y
002A5C  3  20 EB 2D     	jsr nline 		; next line down.
002A5F  3               
002A5F  3  18           	clc
002A60  3  E6 64        	inc z80_e 		; next line of font.
002A62  3  D0 02        	bne :+
002A64  3  E6 65        	inc z80_d
002A66  3               :
002A66  3  E8           	inx
002A67  3  E0 08        	cpx #8
002A69  3  D0 DE        	bne bchar0
002A6B  3               
002A6B  3  20 91 2A     	jsr nexpos		; display position.
002A6E  3  D0 05        	bne bchar2 		; not on a new line.
002A70  3               bchar3:
002A70  3  E6 rr        	inc dispy
002A72  3  20 96 2A     	jsr nexlin 		; next line check.
002A75  3               bchar2:
002A75  3  4C D0 23     	jmp dscor2		; tidy up line and column variables.
002A78  3               
002A78  3               
002A78  3               ;-------------------------------------------------
002A78  3               ; Display a character.
002A78  3               ;
002A78  3               ; Input:
002A78  3               ;  A = character
002A78  3               ;-------------------------------------------------
002A78  3               
002A78  3               achar:
002A78  3  85 63        	sta z80_b 		; copy to b.
002A7A  3  20 A4 2A     	jsr preprt 		; get ready to print.
002A7D  3  A5 63        	lda z80_b		; character in accumulator.
002A7F  3  A6 rr        	ldx prtmod 		; print mode.
002A81  3  F0 03        	beq :+
002A83  3  4C 25 2A     	jmp bchar 		; no, double-height text.
002A86  3               :
002A86  3  20 11 25     	jsr pchar 		; display character.
002A89  3  20 91 2A     	jsr nexpos 		; display position.
002A8C  3  F0 E2        	beq bchar3		; next line down.
002A8E  3  4C 75 2A     	jmp bchar2 		; tidy up.
002A91  3               
002A91  3               
002A91  3               ;-------------------------------------------------
002A91  3               ; Get next print column position.
002A91  3               ;-------------------------------------------------
002A91  3               
002A91  3               nexpos:
002A91  3  E6 rr        	inc dispx		; move along one position.
002A93  3  A5 rr        	lda dispx 		; get coordinate.
002A95  3               ;	and #31
002A95  3  60           	rts 			; return with status in zero flag.
002A96  3               
002A96  3               ;-------------------------------------------------
002A96  3               ; Get next print line position.
002A96  3               ;-------------------------------------------------
002A96  3               
002A96  3               nexlin:
002A96  3  E6 rr        	inc dispy 		; newline.
002A98  3  A5 rr        	lda dispy		; vertical position.
002A9A  3  C9 18        	cmp #24			; past screen edge?
002A9C  3  B0 01        	bcs :+
002A9E  3  60           	rts			; no, still okay.
002A9F  3               :
002A9F  3  A9 00        	lda #0			; restart at top.
002AA1  3  85 rr        	sta dispy
002AA3  3  60           	rts
002AA4  3               
002AA4  3               ;--------------------------------------------------------
002AA4  3               ; Pre-print preliminaries.
002AA4  3               ;--------------------------------------------------------
002AA4  3               
002AA4  3               preprt:
002AA4  3  A9 1F        	lda #<(FONT-256)		; font pointer.
002AA6  3  8D 7B 23     	sta grbase		; set up graphics base.
002AA9  3  A9 34        	lda #>(FONT-256)
002AAB  3  8D 7C 23     	sta grbase+1
002AAE  3               prescr:
002AAE  3  A5 rr        	lda charx 		; display coordinates.
002AB0  3  85 rr        	sta dispx		; set up general coordinates.
002AB2  3  A5 rr        	lda chary
002AB4  3  85 rr        	sta dispy
002AB6  3  60           	rts
002AB7  3               
002AB7  3               ;--------------------------------------------------------------
002AB7  3               ; Get messagenr x in hl
002AB7  3               ;
002AB7  3               ; Input:
002AB7  3               ;  HL = pointer to message list
002AB7  3               ;  X  = message number.
002AB7  3               ;--------------------------------------------------------------
002AB7  3               
002AB7  3               getwrd:
002AB7  3  E0 00        	cpx #0
002AB9  3  D0 01        	bne:+ 			; first word in list?
002ABB  3  60           	rts 			; yep, don't search.
002ABC  3               :
002ABC  3  A0 00        	ldy #0
002ABE  3               getwd0:
002ABE  3  B1 66        	lda (z80_hl),y
002AC0  3  48           	pha
002AC1  3  E6 66        	inc z80_l
002AC3  3  D0 02        	bne :+
002AC5  3  E6 67        	inc z80_h
002AC7  3               :
002AC7  3  68           	pla
002AC8  3  C9 80        	cmp #128		; found end?
002ACA  3  30 F2        	bmi getwd0		; no, carry on.
002ACC  3  CA           	dex			; until we have right number.
002ACD  3  D0 EF        	bne getwd0
002ACF  3  60           	rts
002AD0  3               
002AD0  3               ;-----------------------------------------------------------
002AD0  3               ; Bubble sort.
002AD0  3               ;-----------------------------------------------------------
002AD0  3               
002AD0  3               bsort:
002AD0  3  A9 0B        	lda #NUMSPR - 1		; sprites to swap.
002AD2  3  85 rr        	sta qscnt
002AD4  3               
002AD4  3  A9 39        	lda #<sprtab 		; sprite table.
002AD6  3  85 68        	sta z80_x
002AD8  3  A9 32        	lda #>sprtab
002ADA  3  85 69        	sta z80_i
002ADC  3               bsort0:
002ADC  3  A0 00        	ldy #0
002ADE  3  B1 68        	lda (z80_ix),y 		; first sprite type.
002AE0  3  C9 FF        	cmp #255 		; is it switched off?
002AE2  3  F0 30        	beq swemp		; yes, may need to switch another in here.
002AE4  3               
002AE4  3  A0 11        	ldy #TABSIZ
002AE6  3  B1 68        	lda (z80_ix),y 		; check next slot exists.
002AE8  3  C9 FF        	cmp #255 		; is it enabled?
002AEA  3  F0 0A        	beq bsort2 		; no, nothing to swap.
002AEC  3               
002AEC  3  A0 14        	ldy #TABSIZ+3
002AEE  3  B1 68        	lda (z80_ix),y 		; fetch next sprite's coordinate.
002AF0  3  A0 03        	ldy #3
002AF2  3  D1 68        	cmp (z80_ix),y 		; compare with this x coordinate.
002AF4  3  90 10        	bcc bsort1		; next sprite is higher - may need to switch.
002AF6  3               bsort2:
002AF6  3  18           	clc
002AF7  3  A5 68        	lda z80_x
002AF9  3  69 11        	adc #TABSIZ 		; distance to next odd/even entry.
002AFB  3  85 68        	sta z80_x
002AFD  3  90 02        	bcc :+
002AFF  3  E6 69        	inc z80_i
002B01  3               :
002B01  3  C6 rr        	dec qscnt
002B03  3  D0 D7        	bne bsort0		; repeat for remaining sprites.
002B05  3  60           	rts
002B06  3               
002B06  3               ;qscnt:	.byte 0
002B06  3               
002B06  3               bsort1:
002B06  3  A0 11        	ldy #TABSIZ
002B08  3  B1 68        	lda (z80_ix),y		; sprite on/off flag.
002B0A  3  C9 FF        	cmp #255		; is it enabled?
002B0C  3  F0 E8        	beq bsort2		; no, nothing to swap.
002B0E  3  20 22 2B     	jsr swspr		; swap positions.
002B11  3  4C F6 2A     	jmp bsort2
002B14  3               swemp:
002B14  3  A0 11        	ldy #TABSIZ
002B16  3  B1 68        	lda (z80_ix),y		; next table entry.
002B18  3  C9 FF        	cmp #255		; is that one on?
002B1A  3  F0 DA        	beq bsort2		; no, nothing to swap.
002B1C  3  20 22 2B     	jsr swspr		; swap positions.
002B1F  3  4C F6 2A     	jmp bsort2
002B22  3               
002B22  3               ; Swap sprites.
002B22  3               
002B22  3               swspr:
002B22  3  A5 68        	lda z80_x		; table address
002B24  3  85 64        	sta z80_e		; copy to de pair.
002B26  3  85 66        	sta z80_l		; copy to hl pair.
002B28  3  A5 69        	lda z80_i
002B2A  3  85 67        	sta z80_h
002B2C  3  85 65        	sta z80_d
002B2E  3               
002B2E  3  18           	clc
002B2F  3  A5 66        	lda z80_l
002B31  3  69 11        	adc #TABSIZ		; distance to second entry.
002B33  3  85 66        	sta z80_l
002B35  3  90 02        	bcc :+
002B37  3  E6 67        	inc z80_h
002B39  3               :
002B39  3  A9 11        	lda #TABSIZ		; bytes to swap.
002B3B  3  85 63        	sta z80_b
002B3D  3  A0 00        	ldy #0
002B3F  3               swspr0:
002B3F  3  B1 66        	lda (z80_hl),y		; fetch second byte.
002B41  3  48           	pha
002B42  3  B1 64        	lda (z80_de),y 		; fetch first byte.
002B44  3  91 66        	sta (z80_hl),y 		; copy to second.
002B46  3  68           	pla
002B47  3  91 64        	sta (z80_de),y 		; copy to first sprite entry.
002B49  3               
002B49  3  E6 64        	inc z80_e 		; next byte.
002B4B  3  D0 02        	bne :+
002B4D  3  E6 65        	inc z80_d
002B4F  3               :
002B4F  3  E6 66        	inc z80_l 		; next byte.
002B51  3  D0 02        	bne :+
002B53  3  E6 67        	inc z80_h
002B55  3               :
002B55  3  C6 63        	dec z80_b
002B57  3  D0 E6        	bne swspr0 		; swap all bytes in table entry.
002B59  3  60           	rts
002B5A  3               
002B5A  3               ;----------------------------------------------------
002B5A  3               ; Process sprites.
002B5A  3               ;----------------------------------------------------
002B5A  3               
002B5A  3               pspr:
002B5A  3  A9 0C        	lda #NUMSPR		; sprites to process.
002B5C  3  85 rr        	sta sprptr
002B5E  3               
002B5E  3  A9 39        	lda #<sprtab 		; sprite table.
002B60  3  85 68        	sta z80_x
002B62  3  A9 32        	lda #>sprtab
002B64  3  85 69        	sta z80_i
002B66  3               pspr1:
002B66  3  A0 00        	ldy #0
002B68  3  B1 68        	lda (z80_ix),y		; fetch sprite type.
002B6A  3  C9 09        	cmp #9 			; within range of sprite types?
002B6C  3  B0 03        	bcs :+
002B6E  3  20 81 2B     	jsr pspr2 		; yes, process this one.
002B71  3               :
002B71  3  18           	clc
002B72  3  A5 68        	lda z80_x
002B74  3  69 11        	adc #TABSIZ 		; distance to next odd/even entry.
002B76  3  85 68        	sta z80_x
002B78  3  90 02        	bcc :+
002B7A  3  E6 69        	inc z80_i		; next sprite.
002B7C  3               :
002B7C  3  C6 rr        	dec sprptr 		; repeat for remaining sprites.
002B7E  3  D0 E6        	bne pspr1
002B80  3  60           	rts
002B81  3               
002B81  3               ;sprptr:	.byte 0
002B81  3               
002B81  3               pspr2:
002B81  3  A5 68        	lda z80_x 		; store original sprite pointer.
002B83  3  85 rr        	sta ogptr
002B85  3  A5 69        	lda z80_i
002B87  3  85 rr        	sta ogptr+1
002B89  3  20 95 2B     	jsr pspr3		; do the routine.
002B8C  3               rtorg:
002B8C  3  A5 rr        	lda ogptr 		; restore original pointer to sprite.
002B8E  3  85 68        	sta z80_x
002B90  3  A5 rr        	lda ogptr+1
002B92  3  85 69        	sta z80_i
002B94  3               rtorg0:
002B94  3  60           	rts
002B95  3               
002B95  3               pspr3:
002B95  3  A9 CA        	lda #<evtyp0		; sprite type events list.
002B97  3  85 66        	sta z80_l
002B99  3  A9 2B        	lda #>evtyp0
002B9B  3  85 67        	sta z80_h
002B9D  3               pspr4:
002B9D  3  B1 68        	lda (z80_ix),y
002B9F  3  0A           	asl a			; double accumulator.
002BA0  3  18           	clc
002BA1  3  65 66        	adc z80_l
002BA3  3  85 66        	sta z80_l
002BA5  3  90 02        	bcc :+
002BA7  3  E6 67        	inc z80_h
002BA9  3               :
002BA9  3  B1 66        	lda (z80_hl),y
002BAB  3  85 64        	sta z80_e 		; copy to de.
002BAD  3  48           	pha
002BAE  3               
002BAE  3  E6 66        	inc z80_l 		; next byte of address.
002BB0  3  D0 02        	bne :+
002BB2  3  E6 67        	inc z80_h
002BB4  3               :
002BB4  3  B1 66        	lda (z80_hl),y 		; address high.
002BB6  3  85 65        	sta z80_d
002BB8  3               
002BB8  3  48           	pha	 		; swap address into hl.
002BB9  3  A5 67        	lda z80_h
002BBB  3  85 65        	sta z80_d
002BBD  3  68           	pla
002BBE  3  85 67        	sta z80_h
002BC0  3  68           	pla
002BC1  3  85 66        	sta z80_l
002BC3  3  A5 66        	lda z80_l
002BC5  3  85 64        	sta z80_e
002BC7  3               
002BC7  3  6C 66 00     	jmp (z80_hl) 		; go there.
002BCA  3               
002BCA  3               ;ogptr:	.word 0			; original sprite pointer.
002BCA  3               
002BCA  3               ; Address of each sprite type's routine.
002BCA  3               
002BCA  3  23 33        evtyp0:	.word evnt00
002BCC  3  24 33        evtyp1:	.word evnt01
002BCE  3  25 33        evtyp2:	.word evnt02
002BD0  3  26 33        evtyp3:	.word evnt03
002BD2  3  27 33        evtyp4:	.word evnt04
002BD4  3  28 33        evtyp5:	.word evnt05
002BD6  3  29 33        evtyp6:	.word evnt06
002BD8  3  2A 33        evtyp7:	.word evnt07
002BDA  3  2B 33        evtyp8:	.word evnt08
002BDC  3               
002BDC  3               ;--------------------------------------------------------------
002BDC  3               ; Display sprites.
002BDC  3               ;
002BDC  3               ; Input:
002BDC  3               ;  IX = sprite table
002BDC  3               ;--------------------------------------------------------------
002BDC  3               
002BDC  3               dspr:
002BDC  3  A9 06        	lda #(NUMSPR/2)		; number of sprites to display.
002BDE  3  85 rr        	sta sprcnt
002BE0  3               dspr0:
002BE0  3  A0 00        	ldy #0
002BE2  3  B1 68        	lda (z80_ix),y 		; get sprite type.
002BE4  3  C9 FF        	cmp #255 		; is it enabled?
002BE6  3  D0 42        	bne dspr1 		; yes, it needs deleting.
002BE8  3               dspr5:
002BE8  3  A0 05        	ldy #5
002BEA  3  B1 68        	lda (z80_ix),y 		; new type.
002BEC  3  C9 FF        	cmp #255		; is it enabled?
002BEE  3  D0 77        	bne dspr3 		; yes, it needs drawing.
002BF0  3               dspr2:
002BF0  3  A0 05        	ldy #5
002BF2  3  B1 68        	lda (z80_ix),y 		; copy new type.
002BF4  3  A0 00        	ldy #0
002BF6  3  91 68        	sta (z80_ix),y
002BF8  3  A0 06        	ldy #6
002BFA  3  B1 68        	lda (z80_ix),y 		; copy new image number.
002BFC  3  A0 01        	ldy #1
002BFE  3  91 68        	sta (z80_ix),y
002C00  3  A0 07        	ldy #7
002C02  3  B1 68        	lda (z80_ix),y 		; copy new frame.
002C04  3  A0 02        	ldy #2
002C06  3  91 68        	sta (z80_ix),y
002C08  3  A0 08        	ldy #8
002C0A  3  B1 68        	lda (z80_ix),y 		; copy new y.
002C0C  3  A0 03        	ldy #3
002C0E  3  91 68        	sta (z80_ix),y
002C10  3  A0 09        	ldy #9
002C12  3  B1 68        	lda (z80_ix),y 		; copy new x.
002C14  3  A0 04        	ldy #4
002C16  3  91 68        	sta (z80_ix),y
002C18  3               
002C18  3  18           	clc
002C19  3  A5 68        	lda z80_x
002C1B  3  69 22        	adc #(TABSIZ*2)		; distance to next odd/even entry.
002C1D  3  85 68        	sta z80_x
002C1F  3  A5 69        	lda z80_i
002C21  3  69 00        	adc #0
002C23  3  85 69        	sta z80_i 		; next sprite.
002C25  3  C6 rr        	dec sprcnt
002C27  3  D0 B7        	bne dspr0		; repeat for remaining sprites.
002C29  3  60           	rts
002C2A  3               dspr1:
002C2A  3  A0 05        	ldy #5
002C2C  3  B1 68        	lda (z80_ix),y 		; type of new sprite.
002C2E  3  C9 FF        	cmp #255		; is this enabled?
002C30  3  D0 06        	bne dspr4 		; yes, display both.
002C32  3               dspr6:
002C32  3  20 02 2D     	jsr sspria 		; show single sprite.
002C35  3  4C F0 2B     	jmp dspr2
002C38  3               
002C38  3               ; Displaying two sprites.  Don't bother redrawing if nothing has changed.
002C38  3               
002C38  3               dspr4:
002C38  3  A0 04        	ldy #4
002C3A  3  B1 68        	lda (z80_ix),y		; old x.
002C3C  3  A0 09        	ldy #9
002C3E  3  D1 68        	cmp (z80_ix),y 		; compare with new value.
002C40  3  D0 1F        	bne dspr7 		; they differ, need to redraw.
002C42  3               
002C42  3  A0 03        	ldy #3
002C44  3  B1 68        	lda (z80_ix),y		; old y.
002C46  3  A0 08        	ldy #8
002C48  3  D1 68        	cmp (z80_ix),y 		; compare against new value.
002C4A  3  D0 15        	bne dspr7		; they differ, need to redraw.
002C4C  3               
002C4C  3  A0 02        	ldy #2
002C4E  3  B1 68        	lda (z80_ix),y 		; old frame.
002C50  3  A0 07        	ldy #7
002C52  3  D1 68        	cmp (z80_ix),y 		; compare against new value.
002C54  3  4C 61 2C     	jmp dspr7 		; they differ, need to redraw.
002C57  3               
002C57  3  A0 01        	ldy #1
002C59  3  B1 68        	lda (z80_ix),y 		; old image.
002C5B  3  A0 06        	ldy #6
002C5D  3  D1 68        	cmp (z80_ix),y 		; compare against new value.
002C5F  3  F0 8F        	beq dspr2		; everything is the same, don't redraw.
002C61  3               dspr7:
002C61  3  20 2F 2D     	jsr sspric 		; delete old sprite, draw new one simultaneously.
002C64  3  4C F0 2B     	jmp dspr2
002C67  3               dspr3:
002C67  3  20 29 2D     	jsr ssprib 		; show single sprite.
002C6A  3  4C F0 2B     	jmp dspr2
002C6D  3               
002C6D  3               ;sprcnt:	.byte 0
002C6D  3               
002C6D  3               ;-----------------------------------------
002C6D  3               ; Get sprite address calculations.
002C6D  3               ; gspran = new sprite, gsprad = old sprite.
002C6D  3               ;
002C6D  3               ; Input:
002C6D  3               ;  IX = sprite address
002C6D  3               ;-----------------------------------------
002C6D  3               
002C6D  3               gspran:
002C6D  3  A0 08        	ldy #8
002C6F  3  B1 68        	lda (z80_ix),y 		; new y coordinate.
002C71  3  85 rr        	sta dispy
002C73  3  A0 09        	ldy #9
002C75  3  B1 68        	lda (z80_ix),y 		; new x coordinate.
002C77  3  85 rr        	sta dispx
002C79  3  A0 06        	ldy #6
002C7B  3  B1 68        	lda (z80_ix),y 		; new sprite image.
002C7D  3  20 5B 30     	jsr gfrm		; fetch start frame for this sprite.
002C80  3               
002C80  3  A0 00        	ldy #0
002C82  3  B1 66        	lda (z80_hl),y 		; frame in accumulator.
002C84  3  A0 07        	ldy #7
002C86  3  18           	clc
002C87  3  71 68        	adc (z80_ix),y 		; new add frame number.
002C89  3  4C A8 2C     	jmp gspra0
002C8C  3               
002C8C  3               ;-----------------------------------------
002C8C  3               ; Calculate old sprite address
002C8C  3               ;
002C8C  3               ; Input:
002C8C  3               ;  IX = sprite address
002C8C  3               ;
002C8C  3               ; Output:
002C8C  3               ;  B  = right byte mask
002C8C  3               ;  C  = left byte mask
002C8C  3               ;  DE = spriteframe address
002C8C  3               ;  scraddr = screenaddress(dispx,dispy)
002C8C  3               ;-----------------------------------------
002C8C  3               
002C8C  3               gsprad:
002C8C  3  A0 03        	ldy #3
002C8E  3  B1 68        	lda (z80_ix),y		; y coordinate.
002C90  3  85 rr        	sta dispy
002C92  3  A0 04        	ldy #4
002C94  3  B1 68        	lda (z80_ix),y		; x coordinate.
002C96  3  85 rr        	sta dispx
002C98  3  A0 01        	ldy #1
002C9A  3  B1 68        	lda (z80_ix),y 		; sprite image.
002C9C  3  20 5B 30     	jsr gfrm 		; fetch start frame for this sprite.
002C9F  3               
002C9F  3  A0 00        	ldy #0
002CA1  3  B1 66        	lda (z80_hl),y 		; frame in accumulator.
002CA3  3  A0 02        	ldy #2
002CA5  3  18           	clc
002CA6  3  71 68        	adc (z80_ix),y 		; add frame number.
002CA8  3               gspra0:
002CA8  3  4A           	lsr a	  		; multiply by 128.
002CA9  3  85 65        	sta z80_d 		; store in d.
002CAB  3  8D 00 2D     	sta tmp1
002CAE  3  A9 00        	lda #0
002CB0  3  6A           	ror a
002CB1  3  85 64        	sta z80_e 		; got low byte.
002CB3  3  8D 01 2D     	sta tmp2
002CB6  3               .if bflag
002CB6  3               	lsr tmp1
002CB6  3               	ror tmp2
002CB6  3               	clc
002CB6  3               	lda tmp2
002CB6  3               	adc z80_e
002CB6  3               	sta z80_e
002CB6  3               	lda tmp1
002CB6  3               	adc z80_d
002CB6  3               	sta z80_d
002CB6  3               .endif
002CB6  3  18           	clc 			; address of play sprites.
002CB7  3  A5 64        	lda z80_e
002CB9  3  69 6A        	adc #<sprgfx
002CBB  3  85 64        	sta z80_e
002CBD  3  A5 65        	lda z80_d
002CBF  3  69 34        	adc #>sprgfx
002CC1  3  85 65        	sta z80_d
002CC3  3               
002CC3  3  A5 rr        	lda dispx 		; y coordinate.
002CC5  3  29 06        	and #6 			; position within byte boundary.
002CC7  3  AA           	tax	 		; low byte of table displacement.
002CC8  3               
002CC8  3  0A           	asl a	  		; multiply by 32.
002CC9  3  0A           	asl a  			; already a multiple
002CCA  3  0A           	asl a  			; of 2, so just 4
002CCB  3               .if bflag
002CCB  3               	sta tmp1
002CCB  3               	asl a  			; shifts needed.
002CCB  3               	clc
002CCB  3               	adc tmp1
002CCB  3               .else
002CCB  3  0A           	asl a  			; shifts needed.
002CCC  3               .endif
002CCC  3  18           	clc 			; add to sprite address.
002CCD  3  65 64        	adc z80_e
002CCF  3  85 64        	sta z80_e
002CD1  3  90 02        	bcc :+
002CD3  3  E6 65        	inc z80_d
002CD5  3               :
002CD5  3  BD F8 2C     	lda spmask,x		 ; pointer to mask table.
002CD8  3  85 62        	sta z80_c 		; left mask.
002CDA  3  BD F9 2C     	lda spmask+1,x
002CDD  3  85 63        	sta z80_b 		; right mask.
002CDF  3               
002CDF  3               ;------------------------------------------------------------------
002CDF  3               ; Drop into screen address routine.
002CDF  3               ; This routine returns a screen address for (dispx, dispy) in scraddr.
002CDF  3               ;------------------------------------------------------------------
002CDF  3               
002CDF  3               scadd:
002CDF  3  A6 rr        	ldx dispy
002CE1  3  E0 C0        	cpx #192
002CE3  3  90 02        	bcc :+
002CE5  3  A2 C0        	ldx #192
002CE7  3               :
002CE7  3  A5 rr        	lda dispx
002CE9  3  4A           	lsr a
002CEA  3  4A           	lsr a
002CEB  3  4A           	lsr a
002CEC  3  18           	clc
002CED  3  7D 00 E0     	adc SCADTB_lb,x
002CF0  3  85 rr        	sta scraddr
002CF2  3  BD 00 E1     	lda SCADTB_hb,x
002CF5  3  85 rr        	sta scraddr+1
002CF7  3  60           	rts
002CF8  3               
002CF8  3  FF 00        spmask:	.byte $ff,$00
002CFA  3  3F C0        	.byte $3f,$c0
002CFC  3  0F F0        	.byte $0f,$f0
002CFE  3  03 FC        	.byte $03,$fc
002D00  3               
002D00  3  00           tmp1:	.byte 0
002D01  3  00           tmp2:	.byte 0
002D02  3               
002D02  3               ;-----------------------------------------------------------------
002D02  3               ; These are the sprite routines.
002D02  3               ; sspria = single sprite, old (ix).
002D02  3               ; ssprib = single sprite, new (ix+5).
002D02  3               ; sspric = both sprites, old (ix) and new (ix+5).
002D02  3               ;-----------------------------------------------------------------
002D02  3               
002D02  3               sspria:
002D02  3  20 8C 2C     	jsr gsprad		; get old sprite address.
002D05  3               sspri2:
002D05  3  A5 64        	lda z80_e
002D07  3  8D 77 2D     	sta dline1+1		; Set spritedata address
002D0A  3  8D 86 2D     	sta dline2+1
002D0D  3  A5 65        	lda z80_d
002D0F  3  8D 78 2D     	sta dline1+2
002D12  3  8D 87 2D     	sta dline2+2
002D15  3  86 rr        	stx xtmp
002D17  3  A2 00        	ldx #0			; vertical lines.
002D19  3               sspri0:
002D19  3  20 73 2D     	jsr dline		; draw a line.
002D1C  3  E0 10        	cpx #16			; detect block boundery
002D1E  3  D0 02        	bne :+			; skip if not
002D20  3  E6 rr        	inc scraddr+1		; jump to next blockline
002D22  3               :
002D22  3  E0 20        	cpx #32			; check finished
002D24  3               .if bflag
002D24  3               	bne :+			; skip if not
002D24  3               	inc scraddr+1		; jump to next blockline
002D24  3               	inc z80_hlp+1		; jump to next blockline
002D24  3               :
002D24  3               	cpx #48			; check finished
002D24  3               .endif
002D24  3  D0 F3        	bne sspri0		; no, repeat
002D26  3  A6 rr        	ldx xtmp
002D28  3  60           	rts
002D29  3               
002D29  3               ;-----------------------------------------------------------------
002D29  3               
002D29  3               ssprib:
002D29  3  20 6D 2C     	jsr gspran 		; get new sprite address.
002D2C  3  4C 05 2D     	jmp sspri2
002D2F  3               
002D2F  3               ;-----------------------------------------------------------------
002D2F  3               
002D2F  3               sspric:
002D2F  3  20 8C 2C     	jsr gsprad 		; get old sprite address.
002D32  3  A5 64        	lda z80_e
002D34  3  8D 9B 2D     	sta ddline1+1		; Set spritedata address
002D37  3  8D AA 2D     	sta ddline2+1
002D3A  3  A5 65        	lda z80_d
002D3C  3  8D 9C 2D     	sta ddline1+2
002D3F  3  8D AB 2D     	sta ddline2+2
002D42  3  20 CA 3A     	jsr exx  		; store addresses.
002D45  3               
002D45  3  20 6D 2C     	jsr gspran 		; get new sprite addresses.
002D48  3  A5 64        	lda z80_e
002D4A  3  8D 77 2D     	sta dline1+1		; Set spritedata address
002D4D  3  8D 86 2D     	sta dline2+1
002D50  3  A5 65        	lda z80_d
002D52  3  8D 78 2D     	sta dline1+2
002D55  3  8D 87 2D     	sta dline2+2
002D58  3               
002D58  3  86 rr        	stx xtmp
002D5A  3  A2 00        	ldx #0			; vertical lines.
002D5C  3               lloop:
002D5C  3  20 73 2D     	jsr dline 		; draw a line.
002D5F  3  CA           	dex
002D60  3  CA           	dex
002D61  3  20 97 2D     	jsr ddline 		; delete a line.
002D64  3  E0 10        	cpx #16			; detect block boundery
002D66  3  D0 04        	bne :+			; skip if not
002D68  3  E6 rr        	inc scraddr+1		; jump to next blockline
002D6A  3  E6 73        	inc z80_hlp+1		; jump to next blockline
002D6C  3               :
002D6C  3  E0 20        	cpx #32			; check finished
002D6E  3               .if bflag
002D6E  3               	bne :+			; skip if not
002D6E  3               	inc scraddr+1		; jump to next blockline
002D6E  3               	inc z80_hlp+1		; jump to next blockline
002D6E  3               :
002D6E  3               	cpx #48			; check finished
002D6E  3               .endif
002D6E  3  D0 EC        	bne lloop		; no, repeat
002D70  3  A6 rr        	ldx xtmp
002D72  3  60           	rts
002D73  3               
002D73  3               
002D73  3               ;-----------------------------------------------------------------
002D73  3               
002D73  3               dline:
002D73  3  BC BB 2D     	ldy sprline,x		; point to screenleft
002D76  3               dline1:
002D76  3  BD F9 34     	lda objdta,x		; fetch spriteleft byte
002D79  3  85 61        	sta z80_a		; save spriteright byte
002D7B  3  A5 61        	lda z80_a
002D7D  3  25 62        	and z80_c		; mask left
002D7F  3  51 rr        	eor (scraddr),y		; merge with screenleft
002D81  3  91 rr        	sta (scraddr),y		; write screenleft
002D83  3               sline:
002D83  3  E8           	inx			; next spritebyte
002D84  3  C8           	iny			; point to screenmiddle
002D85  3               dline2:
002D85  3  BD F9 34     	lda objdta,x		; fetch spritemiddle byte
002D88  3  51 rr        	eor (scraddr),y		; merge with screenmiddle
002D8A  3  91 rr        	sta (scraddr),y		; write screenmiddle
002D8C  3               sline2:
002D8C  3  C8           	iny			; point to screenright
002D8D  3  A5 61        	lda z80_a		; fetch spriteright byte
002D8F  3  25 63        	and z80_b		; mask right
002D91  3  51 rr        	eor (scraddr),y		; merge with screenright
002D93  3  91 rr        	sta (scraddr),y		; write screenright
002D95  3               sline3:
002D95  3  E8           	inx			; next spritebyte
002D96  3               
002D96  3  60           	rts
002D97  3               
002D97  3               ;-----------------------------------------------------------------
002D97  3               
002D97  3               ddline:
002D97  3  BC BB 2D     	ldy sprline,x		; point to screenleft
002D9A  3               ddline1:
002D9A  3  BD F9 34     	lda objdta,x		; fetch spriteleft byte
002D9D  3  85 61        	sta z80_a		; save spriteright byte
002D9F  3  A5 61        	lda z80_a
002DA1  3  25 6E        	and z80_cp		; mask left
002DA3  3  51 72        	eor (z80_hlp),y		; merge with screenleft
002DA5  3  91 72        	sta (z80_hlp),y		; write screenleft
002DA7  3               dsline:
002DA7  3  E8           	inx			; next spritebyte
002DA8  3  C8           	iny			; point to screenmiddle
002DA9  3               ddline2:
002DA9  3  BD F9 34     	lda objdta,x		; fetch spritemiddle byte
002DAC  3  51 72        	eor (z80_hlp),y		; merge with screenmiddle
002DAE  3  91 72        	sta (z80_hlp),y		; write screenmiddle
002DB0  3               dsline2:
002DB0  3  C8           	iny			; point to screenright
002DB1  3  A5 61        	lda z80_a		; fetch spriteright byte
002DB3  3  25 6F        	and z80_bp		; mask right
002DB5  3  51 72        	eor (z80_hlp),y		; merge with screenright
002DB7  3  91 72        	sta (z80_hlp),y		; write screenright
002DB9  3               dsline3:
002DB9  3  E8           	inx			; next spritebyte
002DBA  3               
002DBA  3  60           	rts
002DBB  3               
002DBB  3               sprline:
002DBB  3  00 01 20 21  	.byte $00,$01,$20,$21,$40,$41,$60,$61
002DBF  3  40 41 60 61  
002DC3  3  80 81 A0 A1  	.byte $80,$81,$a0,$a1,$c0,$c1,$e0,$e1
002DC7  3  C0 C1 E0 E1  
002DCB  3  00 01 20 21  	.byte $00,$01,$20,$21,$40,$41,$60,$61
002DCF  3  40 41 60 61  
002DD3  3  80 81 A0 A1  	.byte $80,$81,$a0,$a1,$c0,$c1,$e0,$e1
002DD7  3  C0 C1 E0 E1  
002DDB  3  00 01 20 21  	.byte $00,$01,$20,$21,$40,$41,$60,$61
002DDF  3  40 41 60 61  
002DE3  3  80 81 A0 A1  	.byte $80,$81,$a0,$a1,$c0,$c1,$e0,$e1
002DE7  3  C0 C1 E0 E1  
002DEB  3               .if bflag
002DEB  3               	.byte $00,$01,$20,$21,$40,$41,$60,$61
002DEB  3               	.byte $80,$81,$a0,$a1,$c0,$c1,$e0,$e1
002DEB  3               .endif
002DEB  3               
002DEB  3               ;----------------------------------------------------------------------
002DEB  3               ; Line drawn, now work out next target address.
002DEB  3               ;----------------------------------------------------------------------
002DEB  3               
002DEB  3               nline:
002DEB  3  18           	clc
002DEC  3  A5 rr        	lda scraddr 		; get low byte of address.
002DEE  3  69 20        	adc #$20
002DF0  3  85 rr        	sta scraddr 		; new low byte of address.
002DF2  3  90 02        	bcc :+
002DF4  3  E6 rr        	inc scraddr+1 		; new high byte of address.
002DF6  3               :
002DF6  3  60           	rts
002DF7  3               
002DF7  3               ;-------------------------------------------------------------
002DF7  3               ; Line drawn, now work out next target address.
002DF7  3               ;
002DF7  3               ; Input:
002DF7  3               ;  BP  = right mask
002DF7  3               ;  CP  = left mask
002DF7  3               ;  DEP = spriteaddress
002DF7  3               ;  z80_hlp = screen address
002DF7  3               ;-------------------------------------------------------------
002DF7  3               
002DF7  3               
002DF7  3               ;-----------------------------------------------------------
002DF7  3               ; Animates a sprite.
002DF7  3               ;
002DF7  3               ; Input:
002DF7  3               ;  IX = sprite address
002DF7  3               ;  HL = last sprite address
002DF7  3               ;-----------------------------------------------------------
002DF7  3               
002DF7  3               animsp:
002DF7  3  25 rr        	and frmno
002DF9  3  F0 01        	beq :+
002DFB  3  60           	rts
002DFC  3               :
002DFC  3  A0 06        	ldy #6
002DFE  3  B1 68        	lda (z80_ix),y		; sprite image
002E00  3  20 5B 30     	jsr gfrm		; get frame data.
002E03  3               
002E03  3  E6 66        	inc z80_l		; point to frames.
002E05  3  D0 02        	bne :+
002E07  3  E6 67        	inc z80_h
002E09  3               :
002E09  3  A0 07        	ldy #7
002E0B  3  B1 68        	lda (z80_ix),y		; sprite frame.
002E0D  3  18           	clc
002E0E  3  69 01        	adc #1			; next one along.
002E10  3  A0 00        	ldy #0
002E12  3  D1 66        	cmp (z80_hl),y		; reached the last frame?
002E14  3  90 02        	bcc anims0		; no, not yet.
002E16  3  A9 00        	lda #0			; start at first frame.
002E18  3               anims0:
002E18  3  A0 07        	ldy #7
002E1A  3  91 68        	sta (z80_ix),y		; new frame.
002E1C  3  60           	rts
002E1D  3               
002E1D  3               ;--------------------------------------------------------------
002E1D  3               ; Animate back
002E1D  3               ;
002E1D  3               ; Input:
002E1D  3               ;  IX = sprite address
002E1D  3               ;  HL = last sprite address
002E1D  3               ;--------------------------------------------------------------
002E1D  3               
002E1D  3               animbk:
002E1D  3  25 rr        	and frmno
002E1F  3  F0 01        	beq :+
002E21  3  60           	rts
002E22  3               :
002E22  3  A0 06        	ldy #6
002E24  3  B1 68        	lda (z80_ix),y		; sprite image.
002E26  3  20 5B 30     	jsr gfrm		; get frame data.
002E29  3               
002E29  3  E6 66        	inc z80_l 		; point to frames.
002E2B  3  D0 02        	bne :+
002E2D  3  E6 67        	inc z80_h
002E2F  3               :
002E2F  3  A0 07        	ldy #7
002E31  3  B1 68        	lda (z80_ix),y 		; sprite frame.
002E33  3  F0 03        	beq :+
002E35  3  4C 3C 2E     	jmp rtanb0 		; yes, start at end.
002E38  3               :
002E38  3  A0 00        	ldy #0
002E3A  3  B1 66        	lda (z80_hl),y 		; last sprite.
002E3C  3               rtanb0:
002E3C  3  38           	sec
002E3D  3  E9 01        	sbc #1			; next one along.
002E3F  3  4C 18 2E     	jmp anims0		; set new frame.
002E42  3               
002E42  3               ;--------------------------------------------------------------
002E42  3               ; Check for collision with other sprite, strict enforcement.
002E42  3               ;
002E42  3               ; Input:
002E42  3               ;  b		= sprite to test for
002E42  3               ;  ix		= current sprite pointer
002E42  3               ;
002E42  3               ; global:	b
002E42  3               ; local:	x,y,hl,de,skptr
002E42  3               ; calls:	-
002E42  3               ;--------------------------------------------------------------
002E42  3               
002E42  3               sktyp:
002E42  3  A9 39        	lda #<sprtab				; sprite table.
002E44  3  85 66        	sta z80_l
002E46  3  A9 32        	lda #>sprtab
002E48  3  85 67        	sta z80_h
002E4A  3               numsp2:
002E4A  3  A9 0C        	lda #NUMSPR				; number of sprites.
002E4C  3  85 rr        	sta sktptr
002E4E  3               sktyp0:
002E4E  3  A5 66        	lda z80_l 				; store pointer to sprite.
002E50  3  85 rr        	sta skptr
002E52  3  A5 67        	lda z80_h
002E54  3  85 rr        	sta skptr+1
002E56  3               
002E56  3  A0 00        	ldy #0
002E58  3  B1 66        	lda (z80_hl),y 				; get sprite type.
002E5A  3  C5 63        	cmp z80_b				; is it the type we seek?
002E5C  3  F0 1D        	beq coltyp				; yes, we can use this one.
002E5E  3               sktyp1:
002E5E  3  18           	clc
002E5F  3  A5 rr        	lda skptr				; retrieve sprite pointer.
002E61  3  69 11        	adc #TABSIZ				; size of each entry.
002E63  3  85 66        	sta z80_l
002E65  3  A5 rr        	lda skptr+1
002E67  3  69 00        	adc #0
002E69  3  85 67        	sta z80_h
002E6B  3  C6 rr        	dec sktptr					; one less iteration.
002E6D  3  D0 DF        	bne sktyp0				; keep going until we find a slot.
002E6F  3  A9 00        	lda #0					; default to ROM address - no sprite.
002E71  3  85 66        	sta z80_l
002E73  3  85 67        	sta z80_h
002E75  3  85 rr        	sta skptr				; store pointer to sprite.
002E77  3  85 rr        	sta skptr+1
002E79  3               
002E79  3  18           	clc					; don't return with zero flag set.
002E7A  3  60           	rts 					; didn't find one.
002E7B  3               
002E7B  3               ;skptr:	.word 0					; search pointer.
002E7B  3               ;sktptr:	.byte 0
002E7B  3               
002E7B  3               coltyp:
002E7B  3  A0 00        	ldy #0
002E7D  3  B1 68        	lda (z80_ix),y				; current sprite type.
002E7F  3  C5 63        	cmp z80_b				; seeking sprite of same type?
002E81  3  F0 3D        	beq colty1				; yes, need to check we're not detecting ourselves.
002E83  3               colty0:
002E83  3  A0 09        	ldy #9					; distance to x position in table.
002E85  3  B1 66        	lda (z80_hl),y				; fetch x coordinate.
002E87  3  85 64        	sta z80_e
002E89  3  88           	dey
002E8A  3  B1 66        	lda (z80_hl),y				; fetch y coordinate.
002E8C  3  85 65        	sta z80_d
002E8E  3               
002E8E  3               ; Drop into collision detection.
002E8E  3               
002E8E  3               colc16:
002E8E  3  A0 09        	ldy #9
002E90  3  B1 68        	lda (z80_ix),y			 	; x coord.
002E92  3  38           	sec					; subtract x.
002E93  3  E5 64        	sbc z80_e
002E95  3  B0 05        	bcs  colc1a 				; result is positive.
002E97  3  49 FF        	eor #$ff				; make negative positive.
002E99  3  18           	clc
002E9A  3  69 01        	adc #1
002E9C  3               colc1a:
002E9C  3  C9 10        	cmp #16 				; within x range?
002E9E  3  B0 BE        	bcs sktyp1				; no - they"ve missed.
002EA0  3  85 62        	sta z80_c				; store difference.
002EA2  3               
002EA2  3  A0 08        	ldy #8
002EA4  3  B1 68        	lda (z80_ix),y				; y coord.
002EA6  3  38           	sec
002EA7  3  E5 65        	sbc z80_d				; subtract y.
002EA9  3  B0 05        	bcs colc1b				; result is positive.
002EAB  3  49 FF        	eor #$ff				; make negative positive.
002EAD  3  18           	clc
002EAE  3  69 01        	adc #1
002EB0  3               colc1b:
002EB0  3  C9 10        	cmp #16					; within y range?
002EB2  3  B0 AA        	bcs sktyp1 				; no - they've missed.
002EB4  3  18           	clc					; add x difference.
002EB5  3  65 62        	adc z80_c
002EB7  3  C9 1A        	cmp #26					; only 5 corner pixels touching?
002EB9  3  B0 02        	bcs :+
002EBB  3  38           	sec
002EBC  3  60           	rts 					; carry set if there's a collision.
002EBD  3               :
002EBD  3  4C 5E 2E     	jmp sktyp1				; try next sprite in table.
002EC0  3               colty1:
002EC0  3  A5 68        	lda z80_x  				; compare the two.
002EC2  3  C5 66        	cmp z80_l
002EC4  3  D0 09        	bne end_col
002EC6  3  A5 69        	lda z80_i
002EC8  3  C5 67        	cmp z80_h
002ECA  3  D0 03        	bne end_col
002ECC  3  4C 5E 2E     	jmp sktyp1 				; addresses are identical.
002ECF  3               end_col:
002ECF  3  4C 83 2E     	jmp colty0
002ED2  3               
002ED2  3               ;-----------------------------------------------------------
002ED2  3               ; Display number, left aligned
002ED2  3               ;
002ED2  3               ; Input:
002ED2  3               ;  a		= number
002ED2  3               ;
002ED2  3               ; global:	-
002ED2  3               ; local:	a,y,bc,hl,displ0
002ED2  3               ; calls:	num2ch,dmsg3
002ED2  3               ;-----------------------------------------------------------
002ED2  3               
002ED2  3               disply:
002ED2  3  85 61        	sta z80_a
002ED4  3  A9 FA        	lda #<displ0				; display workspace.
002ED6  3  85 62        	sta z80_c
002ED8  3  A9 2E        	lda #>displ0
002EDA  3  85 63        	sta z80_b
002EDC  3  A5 61        	lda z80_a
002EDE  3  20 2B 22     	jsr num2ch				; convert accumulator to string.
002EE1  3               displ1:
002EE1  3  C6 62        	dec z80_c				; back one character.
002EE3  3  D0 02        	bne :+
002EE5  3  C6 63        	dec z80_b
002EE7  3               :
002EE7  3  A0 00        	ldy #0
002EE9  3  B1 62        	lda (z80_bc),y				; fetch digit.
002EEB  3  09 80        	ora #128				; insert end marker.
002EED  3  91 62        	sta (z80_bc),y				; new value.
002EEF  3               
002EEF  3  A9 FA        	lda #<displ0				; display space.
002EF1  3  85 66        	sta z80_l
002EF3  3  A9 2E        	lda #>displ0
002EF5  3  85 67        	sta z80_h
002EF7  3  4C A2 29     	jmp dmsg3				; display the string.
002EFA  3               
002EFA  3  00 00 00 8D  displ0:	.byte 0,0,0,13+128
002EFE  3               
002EFE  3               ;----------------------------------------------------------------
002EFE  3               ; Initialise screen.
002EFE  3               ;
002EFE  3               ; global:	roomtb,scno
002EFE  3               ; local:	-
002EFE  3               ; calls:	tstcs
002EFE  3               ;----------------------------------------------------------------
002EFE  3               
002EFE  3               initsc:
002EFE  3  AD 16 33     	lda roomtb 			; whereabouts in the map are we?
002F01  3  20 0B 2F     	jsr tstsc 			; find displacement.
002F04  3  C9 FF        	cmp #255 			; is it valid?
002F06  3  F0 02        	beq init_end 			; no, it's rubbish.
002F08  3  85 rr        	sta scno			; store new room number.
002F0A  3               init_end:
002F0A  3  60           	rts
002F0B  3               
002F0B  3               ;----------------------------------------------------------------
002F0B  3               ; Test screen.
002F0B  3               ;
002F0B  3               ; global:	-
002F0B  3               ; local:	x
002F0B  3               ; calls:	-
002F0B  3               ;----------------------------------------------------------------
002F0B  3               
002F0B  3               tstsc:
002F0B  3  85 rr        	sta tmproom
002F0D  3  18           	clc
002F0E  3  69 03        	adc #MAPWID 			; add width in case we"re negative.
002F10  3  AA           	tax 				; add displacement to map data.
002F11  3  BD 19 33     	lda mapdat-MAPWID,x 		; find room number there.
002F14  3  60           	rts
002F15  3               
002F15  3               ;tmproom:	.byte 0
002F15  3               
002F15  3               ;--------------------------
002F15  3               ; Screen left.
002F15  3               ;--------------------------
002F15  3               
002F15  3               scrl:
002F15  3  AD 16 33     	lda roomtb 			; present room table pointer.
002F18  3  38           	sec
002F19  3  E9 01        	sbc #1				; room left.
002F1B  3               scrl0:
002F1B  3  20 0B 2F     	jsr tstsc			; test screen.
002F1E  3  C9 FF        	cmp #255			; is there a screen this way?
002F20  3  D0 01        	bne :+
002F22  3  60           	rts				; no, return to loop.
002F23  3               :
002F23  3  A5 rr        	lda tmproom			; restore room displacement.
002F25  3  8D 16 33     	sta roomtb			; new room table position.
002F28  3               scrl1:
002F28  3  20 FE 2E     	jsr initsc 			; set new screen.
002F2B  3  A9 02        	lda #2
002F2D  3  85 rr        	sta restfl 			; set it.
002F2F  3  60           	rts
002F30  3               scrr:
002F30  3  AD 16 33     	lda roomtb 			; room table pointer.
002F33  3  18           	clc
002F34  3  69 01        	adc #1				; room right.
002F36  3  4C 1B 2F     	jmp scrl0
002F39  3               scru:
002F39  3  AD 16 33     	lda roomtb 			; room table pointer.
002F3C  3  38           	sec
002F3D  3  E9 03        	sbc #MAPWID 			; room up.
002F3F  3  4C 1B 2F     	jmp scrl0
002F42  3               scrd:
002F42  3  AD 16 33     	lda roomtb 			; room table pointer.
002F45  3  18           	clc
002F46  3  69 03        	adc #MAPWID 			; room down.
002F48  3  4C 1B 2F     	jmp scrl0
002F4B  3               
002F4B  3               ;-----------------------------------------
002F4B  3               ; Jump to new screen.
002F4B  3               ;-----------------------------------------
002F4B  3               
002F4B  3               nwscr:
002F4B  3  A2 00        	ldx #0				; start of map data.
002F4D  3               nwscr0:
002F4D  3  DD 1C 33     	cmp mapdat,x
002F50  3  F0 06        	beq nwscr1			; have we found a match for screen?
002F52  3  E8           	inx 				; next room.
002F53  3  E0 50        	cpx #80				; zero room count, 80 to search.
002F55  3  D0 F6        	bne nwscr0			; keep looking.
002F57  3  60           	rts
002F58  3               nwscr1:
002F58  3  8E 16 33     	stx roomtb			; set the map position.
002F5B  3  4C 28 2F     	jmp scrl1			; draw new room.
002F5E  3               
002F5E  3               
002F5E  3               ;----------------------------------------------------------
002F5E  3               ; Gravity processing.
002F5E  3               ;----------------------------------------------------------
002F5E  3               
002F5E  3               grav:
002F5E  3  A0 0D        	ldy #13
002F60  3  B1 68        	lda (z80_ix),y			; jump pointer low.
002F62  3  85 66        	sta z80_l
002F64  3  A0 0E        	ldy #14
002F66  3  B1 68        	lda (z80_ix),y			; jump pointer high.
002F68  3  85 67        	sta z80_h
002F6A  3  05 66        	ora z80_l			; merge in low byte.
002F6C  3  D0 01        	bne :+
002F6E  3  60           	rts				; if neither is set, we're not in the air.
002F6F  3               :
002F6F  3  A0 00        	ldy #0
002F71  3  B1 66        	lda (z80_hl),y			; pixels to move.
002F73  3  85 61        	sta z80_a
002F75  3  C9 63        	cmp #99				; reached the end?
002F77  3  D0 0C        	bne grav0			; no, continue.
002F79  3               grav2:
002F79  3  C6 66        	dec z80_l			; go back to previous value.
002F7B  3  C9 FF        	cmp #$ff
002F7D  3  D0 02        	bne :+
002F7F  3  C6 67        	dec z80_h
002F81  3               :
002F81  3  B1 66        	lda (z80_hl),y			; fetch that from table.
002F83  3  85 61        	sta z80_a
002F85  3               grav0:
002F85  3  E6 66        	inc z80_l			; point to next table entry.
002F87  3  D0 02        	bne :+
002F89  3  E6 67        	inc z80_h
002F8B  3               :
002F8B  3  A5 66        	lda z80_l
002F8D  3  A0 0D        	ldy #13
002F8F  3  91 68        	sta (z80_ix),y			; store new pointer low.
002F91  3  A5 67        	lda z80_h
002F93  3  A0 0E        	ldy #14
002F95  3  91 68        	sta (z80_ix),y			; store new pointer high.
002F97  3               grav1:
002F97  3  A5 61        	lda z80_a
002F99  3  D0 01        	bne :+				; any movement required?
002F9B  3  60           	rts				; no, not this time.
002F9C  3               :
002F9C  3  A5 61        	lda z80_a
002F9E  3  C9 80        	cmp #128			; is it up or down?
002FA0  3  B0 15        	bcs gravu			; it's up.
002FA2  3               gravd:
002FA2  3  85 63        	sta z80_b			; set pixels to move.
002FA4  3               gravd0:
002FA4  3  20 81 26     	jsr cangd			; can we go down?
002FA7  3  D0 28        	bne gravst			; can't move down, so stop.
002FA9  3  A0 08        	ldy #8
002FAB  3  B1 68        	lda (z80_ix),y			; adjust new x coord.
002FAD  3  18           	clc
002FAE  3  69 01        	adc #1
002FB0  3  91 68        	sta (z80_ix),y
002FB2  3  C6 63        	dec z80_b
002FB4  3  D0 EE        	bne gravd0
002FB6  3  60           	rts
002FB7  3               gravu:
002FB7  3  49 FF        	eor #$ff			; flip the sign so it's positive.
002FB9  3  18           	clc
002FBA  3  69 01        	adc #1
002FBC  3  85 63        	sta z80_b			; set pixels to move.
002FBE  3               gravu0:
002FBE  3  20 4C 26     	jsr cangu			; can we go up?
002FC1  3  D0 6E        	bne ifalls			; can't move up, go down next.
002FC3  3  A0 08        	ldy #8
002FC5  3  B1 68        	lda (z80_ix),y
002FC7  3  38           	sec
002FC8  3  E9 01        	sbc #1
002FCA  3  91 68        	sta (z80_ix),y			; adjust new x coord.
002FCC  3  C6 63        	dec z80_b
002FCE  3  D0 EE        	bne gravu0
002FD0  3  60           	rts
002FD1  3               gravst:
002FD1  3  A0 0D        	ldy #13
002FD3  3  B1 68        	lda (z80_ix),y			; jump pointer low.
002FD5  3  85 66        	sta z80_l
002FD7  3  A0 0E        	ldy #14
002FD9  3  B1 68        	lda (z80_ix),y			; jump pointer high.
002FDB  3  85 67        	sta z80_h
002FDD  3               
002FDD  3  A9 00        	lda #0				; null value in pointer.
002FDF  3  A0 0D        	ldy #13
002FE1  3  91 68        	sta (z80_ix),y			; store new pointer low.
002FE3  3  C8           	iny
002FE4  3  91 68        	sta (z80_ix),y			; store new pointer high.
002FE6  3               
002FE6  3  A0 00        	ldy #0
002FE8  3  B1 66        	lda (z80_hl),y			; fetch byte from table.
002FEA  3  C9 63        	cmp #99				; is it the end marker?
002FEC  3               evftf:
002FEC  3  F0 01        	beq :+				; yes, fallen too far.
002FEE  3  60           	rts
002FEF  3               :
002FEF  3  4C 06 34     	jmp evnt15			; EVENT FELLTOOFAR
002FF2  3               
002FF2  3               ;------------------------------------------------
002FF2  3               ; Initiate fall check.
002FF2  3               ;------------------------------------------------
002FF2  3               
002FF2  3               ifall:
002FF2  3  A0 0D        	ldy #13
002FF4  3  B1 68        	lda (z80_ix),y 			; jump pointer low.
002FF6  3  85 66        	sta z80_l
002FF8  3  A0 0E        	ldy #14
002FFA  3  B1 68        	lda (z80_ix),y 			; jump pointer high.
002FFC  3  85 67        	sta z80_h			; high byte in accumulator.
002FFE  3  05 66        	ora z80_l			; merge in low byte.
003000  3  F0 01        	beq :+
003002  3  60           	rts				; if either is set, we're already in the air.
003003  3               :
003003  3  A0 09        	ldy #9
003005  3  B1 68        	lda (z80_ix),y			; y coordinate.
003007  3  85 rr        	sta dispx
003009  3  A0 08        	ldy #8
00300B  3  B1 68        	lda (z80_ix),y			; look x coordinate.
00300D  3  18           	clc
00300E  3               numsp7:
00300E  3  69 10        	adc #SPR_HGT			; add 16 pixels.
003010  3  85 rr        	sta dispy			; set up test coordinates.
003012  3  20 F6 28     	jsr tstbl			; get map address.
003015  3  20 23 28     	jsr plchk			; block, platform check.
003018  3  F0 01        	beq :+
00301A  3  60           	rts				; it's solid, don't fall.
00301B  3               :
00301B  3  E6 rr        	inc bufaddr			; look right one cell.
00301D  3  20 23 28     	jsr plchk			; block, platform check.
003020  3  F0 01        	beq :+
003022  3  60           	rts				; it's solid, don't fall.
003023  3               :
003023  3  A5 rr        	lda dispx			; y coordinate.
003025  3  29 07        	and #7				; position straddling block cells.
003027  3  F0 08        	beq ifalls			; no more checks needed.
003029  3  E6 rr        	inc bufaddr			; look to third cell.
00302B  3  20 23 28     	jsr plchk			; block, platform check.
00302E  3  F0 01        	beq :+
003030  3  60           	rts				; it's solid, don't fall.
003031  3               :
003031  3               ifalls:
003031  3  A9 1F        	lda #<jtab			; jump table start.
003033  3  85 66        	sta z80_l
003035  3  A9 38        	lda #>jtab
003037  3  85 67        	sta z80_h
003039  3               ifal0:
003039  3  E6 66        	inc z80_l			; point to next value.
00303B  3  D0 02        	bne :+
00303D  3  E6 67        	inc z80_h
00303F  3               :
00303F  3  A0 00        	ldy #0
003041  3  B1 66        	lda (z80_hl),y			; fetch value.
003043  3  F0 F4        	beq ifal0			; no, get next value.
003045  3  C9 63        	cmp #99				; reached end of table?
003047  3  D0 01        	bne :+
003049  3  60           	rts				; yes, don't fall.
00304A  3               :
00304A  3  C9 80        	cmp #128			; is it going up?
00304C  3  B0 EB        	bcs ifal0			; yes, looking for first movement down.
00304E  3               
00304E  3  A0 0D        	ldy #13
003050  3  A5 66        	lda z80_l
003052  3  91 68        	sta (z80_ix),y 			; set jump low.
003054  3  A0 0E        	ldy #14
003056  3  A5 67        	lda z80_h
003058  3  91 68        	sta (z80_ix),y 			; set jump high.
00305A  3  60           	rts
00305B  3               
00305B  3               
00305B  3               ;----------------------------------------------------
00305B  3               ; Get frame data for a particular sprite.
00305B  3               ; Input:
00305B  3               ;  a		= framenumer
00305B  3               ; Output:
00305B  3               ;  hl		= frame address
00305B  3               ;
00305B  3               ; global:	hl,frmptr
00305B  3               ; local:	-
00305B  3               ; calls:	-
00305B  3               ;----------------------------------------------------
00305B  3               
00305B  3               gfrm:
00305B  3  0A           	asl a	 		 	; multiple of 2.
00305C  3  18           	clc
00305D  3  6D 1A 20     	adc frmptr 			; frames used by game.
003060  3  85 66        	sta z80_l
003062  3  AD 1B 20     	lda frmptr+1
003065  3  69 00        	adc #0
003067  3  85 67        	sta z80_h 			; point to frame start.
003069  3  60           	rts
00306A  3               
00306A  3               ;----------------------------------------------------
00306A  3               ; Find sprite list for current room.
00306A  3               ;
00306A  3               ; global:	hl
00306A  3               ; local:	x,y
00306A  3               ; calls:	-
00306A  3               ;----------------------------------------------------
00306A  3               
00306A  3               sprlst:
00306A  3  A9 F4        	lda #<nmedat 			; list of enemy sprites.
00306C  3  85 66        	sta z80_l
00306E  3  A9 34        	lda #>nmedat
003070  3  85 67        	sta z80_h
003072  3  A6 rr        	ldx scno 			; screen number.
003074  3  D0 01        	bne sprls2 			; is it the first screen?
003076  3  60           	rts 				; yes, don't need to search data.
003077  3               sprls2:
003077  3  A0 00        	ldy #0
003079  3               sprls1:
003079  3  B1 66        	lda (z80_hl),y 			; fetch type of sprite.
00307B  3  C9 FF        	cmp #255			; is it an end marker?
00307D  3  F0 0E        	beq sprls0 			; yes, end of this room.
00307F  3               
00307F  3  18           	clc 				; point to next sprite in list.
003080  3  A5 66        	lda z80_l
003082  3  69 04        	adc #NMESIZ
003084  3  85 66        	sta z80_l
003086  3  90 02        	bcc :+
003088  3  E6 67        	inc z80_h
00308A  3               :
00308A  3  4C 79 30     	jmp sprls1 			; continue until end of room.
00308D  3               sprls0:
00308D  3  E6 66        	inc z80_l 			; point to start of next screen.s
00308F  3  D0 02        	bne :+
003091  3  E6 67        	inc z80_h
003093  3               :
003093  3  CA           	dex
003094  3  D0 E3        	bne sprls1 			; continue until room found.
003096  3  60           	rts
003097  3               
003097  3               
003097  3               ;----------------------------------------------------
003097  3               ; Clear all but a single player sprite.
003097  3               ;
003097  3               ; global:	-
003097  3               ; local:	x,y,ix
003097  3               ; calls:	-
003097  3               ;----------------------------------------------------
003097  3               
003097  3               nspr:
003097  3  A9 0C        	lda #NUMSPR			; sprite slots in table.
003099  3  85 rr        	sta sprcnt
00309B  3  A9 39        	lda #<sprtab 			; sprite table.
00309D  3  85 68        	sta z80_x
00309F  3  A9 32        	lda #>sprtab
0030A1  3  85 69        	sta z80_i
0030A3  3               nspr0:
0030A3  3  A0 00        	ldy #0 				; fetch sprite type.
0030A5  3  B1 68        	lda (z80_ix),y 			; is it a player?
0030A7  3  F0 1A        	beq nspr1 			; yes, keep this one.
0030A9  3               
0030A9  3  A9 FF        	lda #255
0030AB  3  A0 00        	ldy #0 				; fetch sprite type.
0030AD  3  91 68        	sta (z80_ix),y 			; delete sprite.
0030AF  3  A0 05        	ldy #5
0030B1  3  91 68        	sta (z80_ix),y 			; remove next type.
0030B3  3               
0030B3  3  18           	clc	 			; next sprite.
0030B4  3  A5 68        	lda z80_x
0030B6  3  69 11        	adc #TABSIZ 			; distance to next odd/even entry.
0030B8  3  85 68        	sta z80_x
0030BA  3  90 02        	bcc :+
0030BC  3  E6 69        	inc z80_i
0030BE  3               :
0030BE  3  C6 rr        	dec sprcnt	 			; one less space in the table.
0030C0  3  D0 E1        	bne nspr0
0030C2  3  60           	rts
0030C3  3               nspr1:
0030C3  3  A9 FF        	lda #255
0030C5  3  A0 00        	ldy #0
0030C7  3  91 68        	sta (z80_ix),y 			; delete sprite.
0030C9  3               
0030C9  3  18           	clc	 			; point to next sprite.
0030CA  3  A5 68        	lda z80_x
0030CC  3  69 11        	adc #TABSIZ 			; distance to next odd/even entry.
0030CE  3  85 68        	sta z80_x
0030D0  3  90 02        	bcc :+
0030D2  3  E6 69        	inc z80_i
0030D4  3               :
0030D4  3  C6 rr        	dec sprcnt	 			; one less to do.
0030D6  3  D0 01        	bne nspr2
0030D8  3  60           	rts
0030D9  3               nspr2:
0030D9  3  A9 FF        	lda #255
0030DB  3  A0 00        	ldy #0
0030DD  3  91 68        	sta (z80_ix),y 			; delete sprite.
0030DF  3  A0 05        	ldy #5
0030E1  3  91 68        	sta (z80_ix),y 			; remove next type.
0030E3  3               
0030E3  3  18           	clc	 			; next sprite.
0030E4  3  A5 68        	lda z80_x
0030E6  3  69 11        	adc #TABSIZ 			; distance to next odd/even entry.
0030E8  3  85 68        	sta z80_x
0030EA  3  90 02        	bcc :+
0030EC  3  E6 69        	inc z80_i
0030EE  3               :
0030EE  3  C6 rr        	dec sprcnt	 			; one less space in table.
0030F0  3  D0 E7        	bne nspr2
0030F2  3  60           	rts
0030F3  3               
0030F3  3               ;----------------------------------------------------------
0030F3  3               ; Two initialisation routines.
0030F3  3               ; Initialise sprites - copy everything from list to table.
0030F3  3               ;
0030F3  3               ; global:	-
0030F3  3               ; local:	x,y,ix
0030F3  3               ; calls:	cpsp
0030F3  3               ;----------------------------------------------------------
0030F3  3               
0030F3  3               ispr:
0030F3  3  A9 0C        	lda #NUMSPR			; sprite slots in table.
0030F5  3  85 rr        	sta sprcnt
0030F7  3  A9 39        	lda #<sprtab			; sprite table.
0030F9  3  85 68        	sta z80_x
0030FB  3  A9 32        	lda #>sprtab
0030FD  3  85 69        	sta z80_i
0030FF  3               ispr2:
0030FF  3  A0 00        	ldy #0
003101  3  B1 66        	lda (z80_hl),y 			; fetch byte.
003103  3  C9 FF        	cmp #255 			; is it an end marker?
003105  3  D0 01        	bne :+
003107  3  60           	rts 				; yes, no more to do.
003108  3               :
003108  3               ispr1:
003108  3  A0 00        	ldy #0
00310A  3  B1 68        	lda (z80_ix),y 			; fetch sprite type.
00310C  3  C9 FF        	cmp #255 			; is it enabled yet?
00310E  3  D0 08        	bne ispr4			; yes, try another slot.
003110  3               
003110  3  A0 05        	ldy #5
003112  3  B1 68        	lda (z80_ix),y		 	; next type.
003114  3  C9 FF        	cmp #255 			; is it enabled yet?
003116  3  F0 10        	beq ispr3 			; no, process this one.
003118  3               ispr4:
003118  3  18           	clc 				; next sprite.
003119  3  A5 68        	lda z80_x
00311B  3  69 11        	adc #TABSIZ		 	; distance to next odd/even entry.
00311D  3  85 68        	sta z80_x
00311F  3  90 02        	bcc :+
003121  3  E6 69        	inc z80_i
003123  3               :
003123  3  C6 rr        	dec sprcnt
003125  3  D0 E1        	bne ispr1 			; repeat for remaining sprites.
003127  3  60           	rts  				; no more room in table.
003128  3               ispr3:
003128  3  20 7B 31     	jsr cpsp			; initialise a sprite.
00312B  3  C6 rr        	dec sprcnt			; one less space in the table.
00312D  3  D0 D0        	bne ispr2
00312F  3  60           	rts
003130  3               
003130  3               
003130  3               ;-----------------------------------------------------------------------
003130  3               ; Initialise sprites - but not player, we're keeping the old one.
003130  3               ;
003130  3               ; global:	-
003130  3               ; local:	x,y,ix
003130  3               ; calls:	cpsp
003130  3               ;-----------------------------------------------------------------------
003130  3               
003130  3               kspr:
003130  3  A2 0C        	ldx #NUMSPR			; sprite slots in table.
003132  3  A9 39        	lda #<sprtab 			; sprite table.
003134  3  85 68        	sta z80_x
003136  3  A9 32        	lda #>sprtab
003138  3  85 69        	sta z80_i
00313A  3               kspr2:
00313A  3  A0 00        	ldy #0
00313C  3  B1 66        	lda (z80_hl),y 			; fetch byte.
00313E  3  C9 FF        	cmp #255 			; is it an end marker?
003140  3  D0 01        	bne :+
003142  3  60           	rts 				; yes, no more to do.
003143  3               :
003143  3  C9 00        	cmp #0
003145  3  D0 0E        	bne kspr1 			; no, add to table as normal.
003147  3               
003147  3  18           	clc 				; next sprite.
003148  3  A5 66        	lda z80_l
00314A  3  69 04        	adc #NMESIZ		 	; distance to next odd/even entry.
00314C  3  85 66        	sta z80_l
00314E  3  90 02        	bcc :+
003150  3  E6 67        	inc z80_h
003152  3               :
003152  3  4C 3A 31     	jmp kspr2
003155  3               kspr1:
003155  3  A0 00        	ldy #0 				; fetch sprite type.
003157  3  B1 68        	lda (z80_ix),y
003159  3  C9 FF        	cmp #255 			; is it enabled yet?
00315B  3  D0 08        	bne kspr4 			; yes, try another slot.
00315D  3               
00315D  3  A0 05        	ldy #5 				; next type.
00315F  3  B1 68        	lda (z80_ix),y
003161  3  C9 FF        	cmp #255 			; is it enabled yet?
003163  3  F0 0F        	beq kspr3 			; no, process this one.
003165  3               kspr4:
003165  3  18           	clc 				; next sprite.
003166  3  A5 68        	lda z80_x
003168  3  69 11        	adc #TABSIZ		 	; distance to next odd/even entry.
00316A  3  85 68        	sta z80_x
00316C  3  90 02        	bcc :+
00316E  3  E6 69        	inc z80_i
003170  3               :
003170  3  CA           	dex	 			; repeat for remaining sprites.
003171  3  D0 E2        	bne kspr1
003173  3  60           	rts  				; no more room in table.
003174  3               kspr3:
003174  3  20 7B 31     	jsr cpsp 			; copy sprite to table.
003177  3  CA           	dex	 			; one less space in the table.
003178  3  D0 C0        	bne kspr2
00317A  3  60           	rts
00317B  3               
00317B  3               ;----------------------------------------------
00317B  3               ; Copy sprite from list to table.
00317B  3               ;
00317B  3               ; global:	hl,ix
00317B  3               ; local:	y
00317B  3               ; calls:	evnt09
00317B  3               ;----------------------------------------------
00317B  3               
00317B  3               cpsp:
00317B  3  A0 00        	ldy #0				; fetch byte from table.
00317D  3  B1 66        	lda (z80_hl),y
00317F  3  91 68        	sta (z80_ix),y			; set up type.
003181  3  A0 05        	ldy #PAM1ST
003183  3  91 68        	sta (z80_ix),y 			; set up type.
003185  3               
003185  3  E6 66        	inc z80_l 			; move to next byte.
003187  3  D0 02        	bne :+
003189  3  E6 67        	inc z80_h
00318B  3               :
00318B  3  A0 00        	ldy #0 				; fetch byte from table.
00318D  3  B1 66        	lda (z80_hl),y
00318F  3  A0 06        	ldy #6
003191  3  91 68        	sta (z80_ix),y			; set up image.
003193  3               
003193  3  E6 66        	inc z80_l 			; move to next byte.
003195  3  D0 02        	bne :+
003197  3  E6 67        	inc z80_h
003199  3               :
003199  3  A0 00        	ldy #0
00319B  3  B1 66        	lda (z80_hl),y 			; fetch byte from table.
00319D  3  A0 08        	ldy #8
00319F  3  91 68        	sta (z80_ix),y 			; set up coordinate.
0031A1  3               
0031A1  3  A9 C8        	lda #200 			; set initial coordinate off screen.
0031A3  3  A0 03        	ldy #3
0031A5  3  91 68        	sta (z80_ix),y
0031A7  3               
0031A7  3  E6 66        	inc z80_l 			; move to next byte.
0031A9  3  D0 02        	bne :+
0031AB  3  E6 67        	inc z80_h
0031AD  3               :
0031AD  3  A0 00        	ldy #0 				; fetch byte from table.
0031AF  3  B1 66        	lda (z80_hl),y
0031B1  3  A0 09        	ldy #9
0031B3  3  91 68        	sta (z80_ix),y 			; set up coordinate.
0031B5  3               
0031B5  3  E6 66        	inc z80_l 			; move to next byte.
0031B7  3  D0 02        	bne :+
0031B9  3  E6 67        	inc z80_h
0031BB  3               :
0031BB  3  A9 00        	lda #0				; zeroes in accumulator.
0031BD  3  A0 07        	ldy #7 				; reset frame number.
0031BF  3  91 68        	sta (z80_ix),y
0031C1  3  A0 0A        	ldy #10 			; reset direction.
0031C3  3  91 68        	sta (z80_ix),y
0031C5  3  A0 0D        	ldy #13				; reset jump pointer low.
0031C7  3  91 68        	sta (z80_ix),y
0031C9  3  A0 0E        	ldy #14	 			; reset jump pointer high.
0031CB  3  91 68        	sta (z80_ix),y
0031CD  3               
0031CD  3  A9 FF        	lda #255 			; reset data pointer to auto-restore.
0031CF  3  A0 10        	ldy #16
0031D1  3  91 68        	sta (z80_ix),y
0031D3  3               evis0:
0031D3  3  A5 69        	lda z80_i
0031D5  3  48           	pha
0031D6  3  A5 68        	lda z80_x
0031D8  3  48           	pha
0031D9  3  A5 67        	lda z80_h
0031DB  3  48           	pha
0031DC  3  A5 66        	lda z80_l
0031DE  3  48           	pha
0031DF  3               
0031DF  3  20 2C 33     	jsr evnt09 			; perform event.
0031E2  3               
0031E2  3  68           	pla
0031E3  3  85 66        	sta z80_l
0031E5  3  68           	pla
0031E6  3  85 67        	sta z80_h
0031E8  3  68           	pla
0031E9  3  85 68        	sta z80_x
0031EB  3  68           	pla
0031EC  3  85 69        	sta z80_i
0031EE  3               
0031EE  3  18           	clc
0031EF  3  A5 68        	lda z80_x 			; distance to next odd/even entry.
0031F1  3  69 11        	adc #TABSIZ		 	; next sprite.
0031F3  3  85 68        	sta z80_x
0031F5  3  90 02        	bcc :+
0031F7  3  E6 69        	inc z80_i
0031F9  3               :
0031F9  3  60           	rts
0031FA  3               
0031FA  3               
0031FA  3               ;-------------------------------------
0031FA  3               ; Clear the play area window.
0031FA  3               ;-------------------------------------
0031FA  3               
0031FA  3               clw:
0031FA  3  AD 26 20     	lda wintop			; get coordinates of window.
0031FD  3  85 rr        	sta dispy			; put into dispx for calculation.
0031FF  3  AD 27 20     	lda winlft
003202  3  85 rr        	sta dispx
003204  3               
003204  3  AD 28 20     	lda winhgt			; height of window.
003207  3  85 rr        	sta rrow			; copy to b register.
003209  3               clw3:
003209  3  AD 29 20     	lda winwid 			; width of window.
00320C  3  85 rr        	sta rcol
00320E  3               clw2:
00320E  3  20 C2 24     	jsr gprad 			; get print address.
003211  3  A9 00        	lda #0				; zero byte to write.
003213  3  A2 07        	ldx #7				; pixel height of each cell.
003215  3               clw1:
003215  3  BC 4E 25     	ldy scrtab,x
003218  3  91 rr        	sta (scraddr),y 			; copy to screen.
00321A  3  CA           	dex				; next screen row down.
00321B  3  10 F8        	bpl clw1
00321D  3               
00321D  3  E6 rr        	inc dispx			; next column.
00321F  3  C6 rr        	dec rcol			; one less to do.
003221  3  D0 EB        	bne clw2			; repeat for remaining columns.
003223  3               
003223  3  AD 27 20     	lda winlft			; get left edge.
003226  3  85 rr        	sta dispx 			; reset x.
003228  3  E6 rr        	inc dispy 			; next line down.
00322A  3               
00322A  3  C6 rr        	dec rrow
00322C  3  D0 DB        	bne clw3			; repeat down the screen.
00322E  3               
00322E  3  AD 26 20     	lda wintop			; get coordinates of window.
003231  3  85 rr        	sta chary			; put into display position.
003233  3  AD 27 20     	lda winlft
003236  3  85 rr        	sta charx
003238  3  60           	rts
003239  3               
003239  3               
003239  3               ;----------------------------------------------------------
003239  3               ; Effects code.
003239  3               ; Ticker routine is called 25 times per second.
003239  3               ;
003239  3               ; HL = txtscr = left text screen address
003239  3               ; DE = txtscr+txtwid-1 = right text screen address
003239  3               ; BC = txtpos = text scroller position
003239  3               ;
003239  3               ;----------------------------------------------------------
003239  3               
003239  3               .if sflag
003239  3               scrly:
003239  3               	rts
003239  3               	.word txtscr         	; get left screen address.
003239  3               	sta scr_l
003239  3               	lda txtscr+1
003239  3               	sta scr_l+1
003239  3               	sta scr_r+1
003239  3               
003239  3               	stx xtmp
003239  3               
003239  3               	clc         		; get right screen address.
003239  3               	lda scr_l
003239  3               	adc txtwid
003239  3               	sta scr_r
003239  3               	dec scr_r
003239  3               scrly1:
003239  3               	ldy txtwid		; set txtwide
003239  3               	dey
003239  3               	clc
003239  3               scrly0:
003239  3               	lda (scr_l),y		; scroll 1 line
003239  3               	rol a
003239  3               	sta (scr_l),y
003239  3               	dey
003239  3               	bpl scrly0
003239  3               
003239  3               	clc			; point to next line
003239  3               	lda scr_l
003239  3               	adc #32
003239  3               	sta scr_l
003239  3               	bcc scrly1		; repeat 8 times
003239  3               
003239  3               	lda txtpos 		; get text pointer.
003239  3               	sta scr_txt
003239  3               	lda txtpos+1
003239  3               	sta scr_txt+1
003239  3               
003239  3               	ldy #0
003239  3               	lda (scr_txt),y 		; find character we're displaying.
003239  3               	and #127 		; remove end marker bit if applicable.
003239  3               	cmp #13			; is it newline?
003239  3               	bne scrly5 		; no, it's okay.
003239  3               	lda #32			; convert to a space instead.
003239  3               scrly5:
003239  3               	sta fntaddr		; calculate char address
003239  3               	lda #0
003239  3               	sta fntaddr+1
003239  3               	asl fntaddr  		; multiply char by 8.
003239  3               	rol fntaddr+1
003239  3               	asl fntaddr
003239  3               	rol fntaddr+1
003239  3               	asl fntaddr
003239  3               	rol fntaddr+1
003239  3               	lda fntaddr
003239  3               	clc
003239  3               	adc #<(FONT-256)
003239  3               	sta scrly3+1		; that's the low byte.
003239  3               	lda fntaddr+1
003239  3               	adc #>(FONT-256)
003239  3               	sta scrly3+2		; add displacement.
003239  3               
003239  3               	ldx #0
003239  3               scrly3:
003239  3               	lda $3333,x		; get image of char line.
003239  3               	and txtbit
003239  3               	beq scrly2		; don't plot pixel
003239  3               	ldy scrline,x
003239  3               	lda (scr_r),y
003239  3               	clc
003239  3               	ora #1
003239  3               	sta (scr_r),y		; plot pixel
003239  3               scrly2:
003239  3               	inx			; next line of char.
003239  3               	cpx #8
003239  3               	bne scrly3
003239  3               
003239  3               	lsr txtbit		; bit of text to display.
003239  3               	bcs :+
003239  3               	rts
003239  3               :
003239  3               	ldy #0
003239  3               	lda (scr_txt),y 	; what was the character?
003239  3               	asl a	  		; end of message?
003239  3               	bcs scrly4
003239  3               	inc txtpos
003239  3               	bne :+
003239  3               	inc txtpos+1
003239  3               :
003239  3               	jmp scrly6 		; not yet - continue.
003239  3               scrly4:
003239  3               	lda txtini 		; start of scrolling message.
003239  3               	sta txtpos
003239  3               	lda txtini+1
003239  3               	sta txtpos+1
003239  3               scrly6:
003239  3               	lda #128
003239  3               	sta txtbit
003239  3               	ldx xtmp
003239  3               	rts
003239  3               
003239  3               scrline:	.byte $00,$20,$40,$60,$80,$a0,$c0,$e0
003239  3               
003239  3               ;-------------------------------------------------------
003239  3               ; Entry TICKER command
003239  3               ;
003239  3               ; Entry:
003239  3               ;  z80_b = message nr
003239  3               ;  z80_c = width
003239  3               ;-------------------------------------------------------
003239  3               
003239  3               iscrly:
003239  3               	jsr prescr 		; set up display position.
003239  3               
003239  3               	lda #<msgdat 		; text messages.
003239  3               	sta z80_l
003239  3               	lda #>msgdat
003239  3               	sta z80_h
003239  3               
003239  3               	lda z80_c 		; width.
003239  3               	sec
003239  3               	sbc #1			; subtract one.
003239  3               	cmp #32 		; is it between 1 and 32?
003239  3               	bcc :+
003239  3               	lda #$60
003239  3               	jmp iscrl0		; no, disable messages.
003239  3               :
003239  3               	ldx z80_b		; message number.
003239  3               	jsr getwrd 		; find message start.
003239  3               
003239  3               	lda z80_l		; set initial text position.
003239  3               	sta txtini
003239  3               	lda z80_h
003239  3               	sta txtini+1
003239  3               
003239  3               	lda #$ad		; code for lda adrr
003239  3               iscrl0:
003239  3               	sta scrly		; enable/disable scrolling routine.
003239  3               
003239  3               	jsr prescr 		; set up display position.
003239  3               	jsr gprad 		; get print address.
003239  3               
003239  3               	lda scraddr 		; set text screen address.
003239  3               	sta txtscr
003239  3               	lda scraddr+1
003239  3               	sta txtscr+1
003239  3               
003239  3               	lda z80_c		; width.
003239  3               	sta txtwid		; set width in working storage.
003239  3               
003239  3               	lda #128 		; start with leftmost bit.
003239  3               	sta txtbit
003239  3               
003239  3               	jmp scrly4
003239  3               .endif
003239  3               
003239  3               ;------------------------------------------------------------------
003239  3               ; Dig routine, conditional assembly depending on dflag
003239  3               ;------------------------------------------------------------------
003239  3               .if dflag
003239  3               dig:
003239  3               	and #3
003239  3               	beq digr		; dig right
003239  3               	cmp #1
003239  3               	beq digl		; dig left
003239  3               	cmp #2
003239  3               	beq digd		; dig down
003239  3               
003239  3               ; Dig up.
003239  3               
003239  3               digu:				; dig up
003239  3               	ldy #8
003239  3               	lda (z80_ix),y
003239  3               	sec
003239  3               	sbc #2
003239  3               	sta dispy		; set y
003239  3               
003239  3               	iny
003239  3               	lda (z80_ix),y
003239  3               	sta dispx		; set x
003239  3               	jmp digv
003239  3               
003239  3               ; Dig down.
003239  3               
003239  3               digd:
003239  3               	ldy #9
003239  3               	lda (z80_ix),y
003239  3               	sta dispx		; set y
003239  3               
003239  3               	dey
003239  3               	clc
003239  3               	lda (z80_ix),y
003239  3               	adc #16
003239  3               	sta dispy		; set y
003239  3               	jmp digv
003239  3               
003239  3               ; Dig left.
003239  3               
003239  3               digl:
003239  3               	ldy #8
003239  3               	lda (z80_ix),y
003239  3               	sta dispy		; set y
003239  3               
003239  3               	iny
003239  3               	lda (z80_ix),y
003239  3               	sec
003239  3               	sbc #2			; x=x-2
003239  3               	sta dispx		; set x
003239  3               	jmp digh
003239  3               
003239  3               ; Dig right.
003239  3               
003239  3               digr:
003239  3               	ldy #8
003239  3               	lda (z80_ix),y
003239  3               	sta dispy		; set y
003239  3               
003239  3               	iny
003239  3               	lda (z80_ix),y
003239  3               	clc
003239  3               	adc #16
003239  3               	sta dispx		; set x+16
003239  3               	jmp digh
003239  3               
003239  3               ; Vertical digging
003239  3               
003239  3               digv:
003239  3               	jsr tstbl		; check blocktype in MAP
003239  3               	jsr fdchk		; test if FODDER
003239  3               
003239  3               	clc
003239  3               	lda dispx		; look 1 cell down
003239  3               	adc #8
003239  3               	sta dispx
003239  3               	jsr tstbl		; check blocktype in MAP
003239  3               	jsr fdchk
003239  3               	lda dispx
003239  3               	and #7
003239  3               	bne :+
003239  3               	rts
003239  3               :
003239  3               	clc
003239  3               	lda dispx		; look 1 cell down
003239  3               	adc #8
003239  3               	sta dispx
003239  3               	jsr tstbl		; check blocktype in MAP
003239  3               	jmp fdchk
003239  3               
003239  3               ; Horizontal digging
003239  3               
003239  3               digh:
003239  3               	jsr tstbl		; check blocktype in MAP
003239  3               	jsr fdchk		; test if FODDER
003239  3               
003239  3               	clc
003239  3               	lda dispy		; look 1 cell down
003239  3               	adc #8
003239  3               	sta dispy
003239  3               	jsr tstbl		; check blocktype in MAP
003239  3               	jsr fdchk
003239  3               	lda dispy
003239  3               	and #7
003239  3               	bne :+
003239  3               	rts
003239  3               :
003239  3               	clc
003239  3               	lda dispy		; look 1 cell down
003239  3               	adc #8
003239  3               	sta dispy
003239  3               	jsr tstbl		; check blocktype in MAP
003239  3               	jmp fdchk
003239  3               
003239  3               digcnt:	.byte 0
003239  3               
003239  3               .endif
003239  3               
003239  3               ;------------------------------------------------------------------
003239  3               ; Sprite table
003239  3               ;------------------------------------------------------------------
003239  3               
003239  3               
003239  3               ; ix+0  = type.
003239  3               ; ix+1  = sprite image number.
003239  3               ; ix+2  = frame.
003239  3               ; ix+3  = y coord.
003239  3               ; ix+4  = x coord.
003239  3               
003239  3               ; ix+5  = new type.
003239  3               ; ix+6  = new image number.
003239  3               ; ix+7  = new frame.
003239  3               ; ix+8  = new y coord.
003239  3               ; ix+9  = new x coord.
003239  3               
003239  3               ; ix+10 = direction.
003239  3               ; ix+11 = parameter 1.
003239  3               ; ix+12 = parameter 2.
003239  3               ; ix+13 = jump pointer low.
003239  3               ; ix+14 = jump pointer high.
003239  3               ; ix+15 = data pointer low.
003239  3               ; ix+16 = data pointer high.
003239  3               
003239  3               ; block NUMSPR * TABSIZ,255
003239  3               
003239  3  FF FF FF FF  sprtab:	.res NUMSPR*TABSIZ,255
00323D  3  FF FF FF FF  
003241  3  FF FF FF FF  
003305  3  FF FF FF FF  ssprit:	.byte 255,255,255,255,255,255,255,0,192,120,0,0,0,255,255,255,255
003309  3  FF FF FF 00  
00330D  3  C0 78 00 00  
003316  3  07           roomtb:	.byte 7                      ; start room map offset.
003317  3               
003317  3               ; User routine.  Put your own code in here to be called with USER instruction.
003317  3               ; if USER has an argument it will be passed in the accumulator.
003317  3               
003317  3               user:
003317  3               	.include "user.inc"
003317  4  60           	rts
003318  4               
003318  3               
003318  3               ; Everything below here will be generated by the editors.
003318  3               
003318  3  60                   rts
003319  3               WINDOWTOP = 0
003319  3               WINDOWLFT = 0
003319  3               WINDOWHGT = 8
003319  3               WINDOWWID = 32 ;a
003319  3               MAPWID = 3
003319  3  FF FF FF             .byte 255,255,255
00331C  3               mapdat:
00331C  3  FF 00 FF             .byte 255,0,255
00331F  3  FF FF FF             .byte 255,255,255
003322  3  01           stmap:  .byte 1
003323  3               
003323  3               evnt00:
003323  3  60                   rts
003324  3               evnt01:
003324  3  60                   rts
003325  3               evnt02:
003325  3  60                   rts
003326  3               evnt03:
003326  3  60                   rts
003327  3               evnt04:
003327  3  60                   rts
003328  3               evnt05:
003328  3  60                   rts
003329  3               evnt06:
003329  3  60                   rts
00332A  3               evnt07:
00332A  3  60                   rts
00332B  3               evnt08:
00332B  3  60                   rts
00332C  3               evnt09:
00332C  3  60                   rts
00332D  3               evnt10:
00332D  3  A9 00                lda #0 	; PAPER
00332F  3  20 51 39             jsr setbgcol
003332  3  A9 03                lda #3 	; INK
003334  3  20 48 39             jsr setfgcol
003337  3  A9 00                lda #0		; AT
003339  3  85 rr                sta chary
00333B  3  A9 0A                lda #10
00333D  3  85 rr                sta charx
00333F  3  A9 01                lda #1		; PRINTMODE
003341  3  85 rr                sta prtmod
003343  3  A9 00                lda #0		; PRINT
003345  3  20 96 29             jsr dmsg
003348  3  A9 00                lda #0		; PRINTMODE
00334A  3  85 rr                sta prtmod
00334C  3  A9 02                lda #2		; AT
00334E  3  85 rr                sta chary
003350  3  A9 0B                lda #11
003352  3  85 rr                sta charx
003354  3  A9 01                lda #1		; PRINT
003356  3  20 96 29             jsr dmsg
003359  3  A9 04                lda #4
00335B  3  85 rr                sta varc
00335D  3  A9 00                lda #0
00335F  3  85 rr                sta varp
003361  3  A9 04                lda #4 	; REPEAT
003363  3  85 rr                sta loopa
003365  3  A9 04        k00131: lda #4 	; REPEAT
003367  3  85 rr                sta loopb
003369  3  A5 rr        k00142: lda varp 	; PAPER
00336B  3  20 51 39             jsr setbgcol
00336E  3  A5 rr                lda varc 	; INK
003370  3  20 48 39             jsr setfgcol
003373  3  A5 rr                lda varc
003375  3  38                   sec
003376  3  E9 01                sbc #1
003378  3  85 rr                sta varc
00337A  3  A5 rr                lda varc
00337C  3  85 rr                sta chary
00337E  3  A5 rr                lda varp
003380  3  85 rr                sta vard
003382  3  A5 rr                lda vard
003384  3  0A                   asl a
003385  3  0A                   asl a
003386  3  0A                   asl a
003387  3  85 rr                sta vard
003389  3  A5 rr                lda vard
00338B  3  85 rr                sta charx
00338D  3  A9 02                lda #2		; PRINT
00338F  3  20 96 29             jsr dmsg
003392  3  A9 02                lda #2
003394  3  85 62                sta z80_c
003396  3  A5 rr                lda varc
003398  3  18                   clc
003399  3  65 62                adc z80_c
00339B  3  85 rr                sta varc
00339D  3  C6 rr                dec loopb	; ENDREPEAT
00339F  3  F0 03                beq :+
0033A1  3  4C 69 33             jmp k00142
0033A4  3               :
0033A4  3  A9 04                lda #4
0033A6  3  85 rr                sta varc
0033A8  3  A5 rr                lda varp
0033AA  3  18                   clc
0033AB  3  69 01                adc #1
0033AD  3  85 rr                sta varp
0033AF  3  C6 rr                dec loopa	; ENDREPEAT
0033B1  3  F0 03                beq :+
0033B3  3  4C 65 33             jmp k00131
0033B6  3               :
0033B6  3  A9 07                lda #7		; AT
0033B8  3  85 rr                sta chary
0033BA  3  A9 00                lda #0
0033BC  3  85 rr                sta charx
0033BE  3  A9 03                lda #3 	; INK
0033C0  3  20 48 39             jsr setfgcol
0033C3  3  A9 02                lda #2 	; PAPER
0033C5  3  20 51 39             jsr setbgcol
0033C8  3  A9 03                lda #3		; PRINT
0033CA  3  20 96 29             jsr dmsg
0033CD  3  20 9C 38             jsr prskey	; WAITKEY
0033D0  3  60                   rts
0033D1  3               evnt11:
0033D1  3  60                   rts
0033D2  3               evnt12:
0033D2  3  A9 00                lda #0 	; COLBK
0033D4  3  8D 1A D0             sta COLBK
0033D7  3  A9 DE                lda #222 	; COLPF0
0033D9  3  8D 16 D0             sta COLPF0
0033DC  3  A9 34                lda #52 	; COLPF1
0033DE  3  8D 17 D0             sta COLPF1
0033E1  3  A9 72                lda #114 	; COLPF2
0033E3  3  8D 18 D0             sta COLPF2
0033E6  3  A9 00                lda #0 	; PAPER
0033E8  3  20 51 39             jsr setbgcol
0033EB  3  A9 01                lda #1 	; INK
0033ED  3  20 48 39             jsr setfgcol
0033F0  3  20 B6 20             jsr cls		; CLS
0033F3  3  A9 04                lda #4		; AT
0033F5  3  85 rr                sta chary
0033F7  3  A9 05                lda #5
0033F9  3  85 rr                sta charx
0033FB  3  A9 04                lda #4		; PRINT
0033FD  3  20 96 29             jsr dmsg
003400  3  20 9C 38             jsr prskey	; WAITKEY
003403  3  60                   rts
003404  3               evnt13:
003404  3  60                   rts
003405  3               evnt14:
003405  3  60                   rts
003406  3               evnt15:
003406  3  60                   rts
003407  3               evnt16:
003407  3  60                   rts
003408  3               evnt17:
003408  3  60                   rts
003409  3               evnt18:
003409  3  60                   rts
00340A  3               evnt19:
00340A  3  60                   rts
00340B  3               evnt20:
00340B  3  60                   rts
00340C  3  60           ptcusr: rts
00340D  3               msgdat:
00340D  3  43 4F 4C 4F          .byte "COLOUR TES",212
003411  3  55 52 20 54  
003415  3  45 53 D4     
003418  3  3C 2D 50 41          .byte "<-PAPER-",190
00341C  3  50 45 52 2D  
003420  3  BE           
003421  3  20 43 6F 6C          .byte " Colour",160
003425  3  6F 75 72 A0  
003429  3  43 6F 6C 6F          .byte "Colour demo for AGD Atari engin",229
00342D  3  75 72 20 64  
003431  3  65 6D 6F 20  
003449  3  50 72 65 73          .byte "Press a key to continu",229
00344D  3  73 20 61 20  
003451  3  6B 65 79 20  
003460  3               nummsg:
003460  3  05                   .byte 5
003461  3               chgfx:
003461  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0
003465  3  00 00 00 00  
003469  3               bprop:
003469  3  00                   .byte 0
00346A  3               sprgfx:
00346A  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
00346E  3  00 00 00 00  
003472  3  00 00 00 00  
00348A  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
00348E  3  00 00 00 00  
003492  3  00 00 00 00  
0034AA  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0034AE  3  00 00 00 00  
0034B2  3  00 00 00 00  
0034CA  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0034CE  3  00 00 00 00  
0034D2  3  00 00 00 00  
0034EA  3               frmlst:
0034EA  3  00 01 01 00          .byte 0,1,1,0
0034EE  3               scdat:
0034EE  3  03 00                .word 3
0034F0  3  FF 00 00             .byte 255,0,0
0034F3  3               numsc:
0034F3  3  01                   .byte 1
0034F4  3               nmedat:
0034F4  3  42 00 58 80          .byte 66,0,88,128,255
0034F8  3  FF           
0034F9  3               NUMOBJ = 1
0034F9  3               objdta:
0034F9  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,254,160,104,254,160,104
0034FD  3  00 00 00 00  
003501  3  00 00 00 00  
00351F  3               font:
00351F  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0
003523  3  00 00 00 00  
003527  3  0C 0C 0C 0C          .byte 12,12,12,12,0,0,12,0
00352B  3  00 00 0C 00  
00352F  3  CC CC 00 00          .byte 204,204,0,0,0,0,0,0
003533  3  00 00 00 00  
003537  3  00 CC FC CC          .byte 0,204,252,204,204,252,204,0
00353B  3  CC FC CC 00  
00353F  3  30 30 3C C0          .byte 48,48,60,192,48,12,240,48
003543  3  30 0C F0 30  
003547  3  CC CC 0C 30          .byte 204,204,12,48,48,192,204,204
00354B  3  30 C0 CC CC  
00354F  3  30 CC CC 30          .byte 48,204,204,48,207,204,51,0
003553  3  CF CC 33 00  
003557  3  30 C0 00 00          .byte 48,192,0,0,0,0,0,0
00355B  3  00 00 00 00  
00355F  3  0C 30 30 30          .byte 12,48,48,48,48,48,12,0
003563  3  30 30 0C 00  
003567  3  30 0C 0C 0C          .byte 48,12,12,12,12,12,48,0
00356B  3  0C 0C 30 00  
00356F  3  00 CC 30 FC          .byte 0,204,48,252,48,204,0,0
003573  3  30 CC 00 00  
003577  3  00 30 30 FC          .byte 0,48,48,252,48,48,0,0
00357B  3  30 30 00 00  
00357F  3  00 00 00 00          .byte 0,0,0,0,0,48,48,192
003583  3  00 30 30 C0  
003587  3  00 00 00 FC          .byte 0,0,0,252,0,0,0,0
00358B  3  00 00 00 00  
00358F  3  00 00 00 00          .byte 0,0,0,0,0,0,48,0
003593  3  00 00 30 00  
003597  3  0C 0C 0C 30          .byte 12,12,12,48,48,192,192,192
00359B  3  30 C0 C0 C0  
00359F  3  30 CC CC CC          .byte 48,204,204,204,204,204,48,0
0035A3  3  CC CC 30 00  
0035A7  3  30 F0 30 30          .byte 48,240,48,48,48,48,48,0
0035AB  3  30 30 30 00  
0035AF  3  30 CC 0C 0C          .byte 48,204,12,12,48,192,252,0
0035B3  3  30 C0 FC 00  
0035B7  3  30 CC 0C 30          .byte 48,204,12,48,12,204,48,0
0035BB  3  0C CC 30 00  
0035BF  3  0C 3C CC CC          .byte 12,60,204,204,204,252,12,0
0035C3  3  CC FC 0C 00  
0035C7  3  FC C0 C0 F0          .byte 252,192,192,240,12,204,48,0
0035CB  3  0C CC 30 00  
0035CF  3  0C 30 C0 F0          .byte 12,48,192,240,204,204,48,0
0035D3  3  CC CC 30 00  
0035D7  3  FC 0C 0C 30          .byte 252,12,12,48,192,192,192,0
0035DB  3  C0 C0 C0 00  
0035DF  3  30 CC CC 30          .byte 48,204,204,48,204,204,48,0
0035E3  3  CC CC 30 00  
0035E7  3  30 CC CC 3C          .byte 48,204,204,60,12,48,192,0
0035EB  3  0C 30 C0 00  
0035EF  3  00 30 30 00          .byte 0,48,48,0,48,48,0,0
0035F3  3  30 30 00 00  
0035F7  3  00 30 30 00          .byte 0,48,48,0,48,48,192,0
0035FB  3  30 30 C0 00  
0035FF  3  00 0C 30 C0          .byte 0,12,48,192,48,12,0,0
003603  3  30 0C 00 00  
003607  3  00 00 FC 00          .byte 0,0,252,0,0,252,0,0
00360B  3  00 FC 00 00  
00360F  3  00 C0 30 0C          .byte 0,192,48,12,48,192,0,0
003613  3  30 C0 00 00  
003617  3  30 CC 0C 30          .byte 48,204,12,48,48,0,48,0
00361B  3  30 00 30 00  
00361F  3  00 00 3C CC          .byte 0,0,60,204,204,192,60,0
003623  3  CC C0 3C 00  
003627  3  30 CC CC FC          .byte 48,204,204,252,204,204,204,0
00362B  3  CC CC CC 00  
00362F  3  F0 CC CC F0          .byte 240,204,204,240,204,204,240,0
003633  3  CC CC F0 00  
003637  3  30 CC C0 C0          .byte 48,204,192,192,192,204,48,0
00363B  3  C0 CC 30 00  
00363F  3  F0 CC CC CC          .byte 240,204,204,204,204,204,240,0
003643  3  CC CC F0 00  
003647  3  FC C0 C0 FC          .byte 252,192,192,252,192,192,252,0
00364B  3  C0 C0 FC 00  
00364F  3  FC C0 C0 F0          .byte 252,192,192,240,192,192,192,0
003653  3  C0 C0 C0 00  
003657  3  30 CC C0 C0          .byte 48,204,192,192,204,204,60,0
00365B  3  CC CC 3C 00  
00365F  3  CC CC CC FC          .byte 204,204,204,252,204,204,204,0
003663  3  CC CC CC 00  
003667  3  30 30 30 30          .byte 48,48,48,48,48,48,48,0
00366B  3  30 30 30 00  
00366F  3  0C 0C 0C 0C          .byte 12,12,12,12,12,204,48,0
003673  3  0C CC 30 00  
003677  3  CC CC CC F0          .byte 204,204,204,240,204,204,204,0
00367B  3  CC CC CC 00  
00367F  3  C0 C0 C0 C0          .byte 192,192,192,192,192,192,252,0
003683  3  C0 C0 FC 00  
003687  3  CC CC FC CC          .byte 204,204,252,204,204,204,204,0
00368B  3  CC CC CC 00  
00368F  3  F0 CC CC CC          .byte 240,204,204,204,204,204,204,0
003693  3  CC CC CC 00  
003697  3  30 CC CC CC          .byte 48,204,204,204,204,204,48,0
00369B  3  CC CC 30 00  
00369F  3  F0 CC CC F0          .byte 240,204,204,240,192,192,192,0
0036A3  3  C0 C0 C0 00  
0036A7  3  30 CC CC CC          .byte 48,204,204,204,252,204,60,0
0036AB  3  FC CC 3C 00  
0036AF  3  F0 CC CC F0          .byte 240,204,204,240,204,204,204,0
0036B3  3  CC CC CC 00  
0036B7  3  30 CC C0 30          .byte 48,204,192,48,12,204,48,0
0036BB  3  0C CC 30 00  
0036BF  3  FC 30 30 30          .byte 252,48,48,48,48,48,48,0
0036C3  3  30 30 30 00  
0036C7  3  CC CC CC CC          .byte 204,204,204,204,204,204,60,0
0036CB  3  CC CC 3C 00  
0036CF  3  CC CC CC CC          .byte 204,204,204,204,204,204,48,0
0036D3  3  CC CC 30 00  
0036D7  3  CC CC CC CC          .byte 204,204,204,204,252,204,204,0
0036DB  3  FC CC CC 00  
0036DF  3  CC CC CC 30          .byte 204,204,204,48,204,204,204,0
0036E3  3  CC CC CC 00  
0036E7  3  CC CC CC FC          .byte 204,204,204,252,48,48,48,0
0036EB  3  30 30 30 00  
0036EF  3  FC 0C 0C 30          .byte 252,12,12,48,192,192,252,0
0036F3  3  C0 C0 FC 00  
0036F7  3  F0 C0 C0 C0          .byte 240,192,192,192,192,192,240,0
0036FB  3  C0 C0 F0 00  
0036FF  3  C0 C0 C0 30          .byte 192,192,192,48,48,12,12,12
003703  3  30 0C 0C 0C  
003707  3  3C 0C 0C 0C          .byte 60,12,12,12,12,12,60,0
00370B  3  0C 0C 3C 00  
00370F  3  30 CC 00 00          .byte 48,204,0,0,0,0,0,0
003713  3  00 00 00 00  
003717  3  00 00 00 00          .byte 0,0,0,0,0,0,0,252
00371B  3  00 00 00 FC  
00371F  3  30 C0 00 00          .byte 48,192,0,0,0,0,0,0
003723  3  00 00 00 00  
003727  3  00 00 3C CC          .byte 0,0,60,204,204,204,60,0
00372B  3  CC CC 3C 00  
00372F  3  C0 C0 F0 CC          .byte 192,192,240,204,204,204,240,0
003733  3  CC CC F0 00  
003737  3  00 00 3C C0          .byte 0,0,60,192,192,192,60,0
00373B  3  C0 C0 3C 00  
00373F  3  0C 0C 3C CC          .byte 12,12,60,204,204,204,60,0
003743  3  CC CC 3C 00  
003747  3  00 00 30 CC          .byte 0,0,48,204,252,192,60,0
00374B  3  FC C0 3C 00  
00374F  3  3C 30 FC 30          .byte 60,48,252,48,48,48,48,0
003753  3  30 30 30 00  
003757  3  00 00 3C CC          .byte 0,0,60,204,204,60,204,48
00375B  3  CC 3C CC 30  
00375F  3  C0 C0 FC CC          .byte 192,192,252,204,204,204,204,0
003763  3  CC CC CC 00  
003767  3  30 00 F0 30          .byte 48,0,240,48,48,48,252,0
00376B  3  30 30 FC 00  
00376F  3  30 00 F0 30          .byte 48,0,240,48,48,48,48,192
003773  3  30 30 30 C0  
003777  3  C0 C0 CC F0          .byte 192,192,204,240,240,204,204,0
00377B  3  F0 CC CC 00  
00377F  3  F0 30 30 30          .byte 240,48,48,48,48,48,252,0
003783  3  30 30 FC 00  
003787  3  00 00 CC FC          .byte 0,0,204,252,204,204,204,0
00378B  3  CC CC CC 00  
00378F  3  00 00 FC CC          .byte 0,0,252,204,204,204,204,0
003793  3  CC CC CC 00  
003797  3  00 00 30 CC          .byte 0,0,48,204,204,204,48,0
00379B  3  CC CC 30 00  
00379F  3  00 00 F0 CC          .byte 0,0,240,204,204,204,240,192
0037A3  3  CC CC F0 C0  
0037A7  3  00 00 3C CC          .byte 0,0,60,204,204,204,60,12
0037AB  3  CC CC 3C 0C  
0037AF  3  00 00 FC CC          .byte 0,0,252,204,192,192,192,0
0037B3  3  C0 C0 C0 00  
0037B7  3  00 00 3C C0          .byte 0,0,60,192,48,12,240,0
0037BB  3  30 0C F0 00  
0037BF  3  30 30 FC 30          .byte 48,48,252,48,48,48,60,0
0037C3  3  30 30 3C 00  
0037C7  3  00 00 CC CC          .byte 0,0,204,204,204,204,252,0
0037CB  3  CC CC FC 00  
0037CF  3  00 00 CC CC          .byte 0,0,204,204,204,204,48,0
0037D3  3  CC CC 30 00  
0037D7  3  00 00 CC CC          .byte 0,0,204,204,204,252,204,0
0037DB  3  CC FC CC 00  
0037DF  3  00 00 CC CC          .byte 0,0,204,204,48,204,204,0
0037E3  3  30 CC CC 00  
0037E7  3  00 00 CC CC          .byte 0,0,204,204,252,48,48,0
0037EB  3  FC 30 30 00  
0037EF  3  00 00 FC 0C          .byte 0,0,252,12,48,192,252,0
0037F3  3  30 C0 FC 00  
0037F7  3  0C 30 30 C0          .byte 12,48,48,192,48,48,12,0
0037FB  3  30 30 0C 00  
0037FF  3  0C 0C 0C 0C          .byte 12,12,12,12,12,12,12,12
003803  3  0C 0C 0C 0C  
003807  3  C0 30 30 0C          .byte 192,48,48,12,48,48,192,0
00380B  3  30 30 C0 00  
00380F  3  00 F0 00 00          .byte 0,240,0,0,0,0,0,0
003813  3  00 00 00 00  
003817  3  FF FF FF FF          .byte 255,255,255,255,255,255,255,0
00381B  3  FF FF FF 00  
00381F  3               jtab:
00381F  3  63                   .byte 99
003820  3  0A 08 3F 2F  keys:   .byte 10,8,63,47,33,37,35,31,30,26,24
003824  3  21 25 23 1F  
003828  3  1E 1A 18     
00382B  3               
00382B  2               
00382B  1               	.include "lib.inc"
00382B  2               ;----------------------------------------------------------------------
00382B  2               ; Atari 800 Platform Specific functions
00382B  2               ;----------------------------------------------------------------------
00382B  2               
00382B  2               ;============================================================
00382B  2               ; PLATFORM VARIABLES
00382B  2               ;============================================================
00382B  2               ;
00382B  2               ; Memory map:
00382B  2               ;
00382B  2               ;	$0000-$01ff	 0.50kB	CPU WS
00382B  2               ;	$0200-$05ff	 1,00kB	IOCB/Printer/Cassette RAM
00382B  2               ;	$0600-$06ff	 0,25kB	User RAM
00382B  2               ;	$0700-$1fff	 6,25kB
00382B  2               ;	$2000-$ffff	56,00kB	User RAM
00382B  2               ;
00382B  2               ; Keyboard matrix:
00382B  2               ;
00382B  2               ;		0	1	2	3	4	5	6	7
00382B  2               ;       ----------------------------------------------------------------------
00382B  2               ;	$00:	L	J	;:	F1	F2	K	+\	*^
00382B  2               ;	$08:	O		P	U	Ret	I	-_	=|
00382B  2               ;	$10:	V	Help	C	F3	F4	B	X	Z
00382B  2               ;	$18:	4$		3#	6&	Esc	5%	2"	1!
00382B  2               ;	$20:	,[	Space	.]	N		M	/?	Invert
00382B  2               ;	$28:	R		E	Y	Tab	T	W	Q
00382B  2               ;	$30:	9(		0)	7'	Bksp	8@	<	>
00382B  2               ;	$38:	F	H	D		Caps	G	S	A
00382B  2               ;
00382B  2               ; Atari 800 constants:
00382B  2               
00382B  2               	LMS		= 64
00382B  2               	HS		= 16
00382B  2               	VS		= 32
00382B  2               	MODE2		= 2
00382B  2               	MODE3		= 3
00382B  2               	MODE4		= 4
00382B  2               	MODE5		= 5
00382B  2               	MODEB		= $0B
00382B  2               	MODED		= $0D
00382B  2               	MODEE		= $0E
00382B  2               	MODEF		= $0F
00382B  2               
00382B  2               	BLANK1		= $00
00382B  2               	BLANK2		= $10
00382B  2               	BLANK3		= $20
00382B  2               	BLANK4		= $30
00382B  2               	BLANK5		= $40
00382B  2               	BLANK6		= $50
00382B  2               	BLANK7		= $60
00382B  2               	BLANK8		= $70
00382B  2               
00382B  2               	DLISTENDJUMP	= $41
00382B  2               
00382B  2               ; Atari 800 Addresses
00382B  2               
00382B  2               	HPOSP0	= $D000		; HORIZONTAL POSITION P0
00382B  2               	HPOSP1	= $D001		; HORIZONTAL POSITION P1
00382B  2               	HPOSP2	= $D002		; HORIZONTAL POSITION P2
00382B  2               	HPOSP3	= $D003		; HORIZONTAL POSITION P3
00382B  2               	HPOSM0	= $D004		; HORIZONTAL POSITION M0
00382B  2               	HPOSM1	= $D005		; HORIZONTAL POSITION M1
00382B  2               	HPOSM2	= $D006		; HORIZONTAL POSITION M2
00382B  2               	HPOSM3	= $D007		; HORIZONTAL POSITION M3
00382B  2               
00382B  2               	SIZEP0	= $D008		; SIZE P0
00382B  2               	SIZEP1	= $D009		; SIZE P0
00382B  2               	SIZEP2	= $D00A		; SIZE P0
00382B  2               	SIZEP3	= $D00B		; SIZE P0
00382B  2               	SIZEM	= $D00C		; SIZE M
00382B  2               
00382B  2               	GRAFP0	= $D00D
00382B  2               	GRAFP1	= $D00E
00382B  2               	GRAFP2	= $D00F
00382B  2               	GRAFP3	= $D010
00382B  2               	GRAFM	= $D011
00382B  2               
00382B  2               	TRIG0	= $D010
00382B  2               	TRIG1	= $D011
00382B  2               
00382B  2               	COLPM0	= $D012		; COLOR P0/M0
00382B  2               	COLPM1	= $D013		; COLOR P1/M1
00382B  2               	COLPM2	= $D014		; COLOR P2/M2
00382B  2               	COLPM3	= $D015		; COLOR P3/M3
00382B  2               
00382B  2               	COLPF0	= $D016
00382B  2               	COLPF1	= $D017
00382B  2               	COLPF2	= $D018
00382B  2               	COLPF3	= $D019
00382B  2               	COLBK	= $D01A
00382B  2               
00382B  2               	KBCODE	= $D209
00382B  2               	RANDOM	= $D20A
00382B  2               	IRQEN	= $D20E
00382B  2               	IRQST	= $D20E
00382B  2               	SKSTAT	= $D20F
00382B  2               
00382B  2               	STICK	= $D300
00382B  2               	PORTB	= $D301
00382B  2               	PBCTL	= $D303
00382B  2               
00382B  2               	DMACTL	= $D400
00382B  2               	DLISTL	= $D402
00382B  2               	DLISTH	= $D403
00382B  2               	WSYNC	= $D40A
00382B  2               	VCOUNT	= $D40B
00382B  2               	NMIEN	= $D40E
00382B  2               	NMIST	= $D40F
00382B  2               	NMIRES	= $D40F
00382B  2               
00382B  2               	NMI	= $FFFA
00382B  2               	RESET	= $FFFC
00382B  2               	IRQ	= $FFFE
00382B  2               
00382B  2               ;----------------------------------------------------------------------
00382B  2               ; Atari 800 hardware fns
00382B  2               ;----------------------------------------------------------------------
00382B  2               
00382B  2               init:
00382B  2               
00382B  2               ; Disable interrupts
00382B  2               
00382B  2  78           	sei
00382C  2  A9 00        	lda #0
00382E  2  8D 0E D2     	sta IRQEN		; Disable IRQ
003831  2  8D 0E D4     	sta NMIEN		; Disable NMI
003834  2               
003834  2               ; Switch BASIC + OS ROMS off
003834  2               
003834  2  AD 03 D3     	lda PBCTL
003837  2  09 02        	ora #%00000010
003839  2  8D 03 D3     	sta PBCTL
00383C  2  AD 01 D3     	lda PORTB
00383F  2  29 7C        	and #%01111100
003841  2  09 82        	ora #%10000010
003843  2  8D 01 D3     	sta PORTB
003846  2               
003846  2               ; Setup new NMI handler
003846  2               
003846  2  A9 6C        	lda #<nmi_handler
003848  2  8D FA FF     	sta NMI
00384B  2  A9 38        	lda #>nmi_handler
00384D  2  8D FB FF     	sta NMI+1
003850  2  A9 C0        	lda #%11000000
003852  2  8D 0E D4     	sta NMIEN
003855  2               
003855  2               ; Init video registers
003855  2               
003855  2  A9 00        	lda #<BITMAP_DLIST
003857  2  8D 02 D4     	sta DLISTL
00385A  2  A9 3A        	lda #>BITMAP_DLIST
00385C  2  8D 03 D4     	sta DLISTH
00385F  2               
00385F  2               ; Screenwidth 32 bytes
00385F  2               
00385F  2  A9 31        	lda #%00110001
003861  2  8D 00 D4     	sta DMACTL
003864  2               
003864  2  20 B6 20     	jsr cls
003867  2               
003867  2  60           	rts
003868  2               
003868  2               ; NMI interrupt handler
003868  2               
003868  2  00 00        frame_counter:	.byte 0,0
00386A  2  00           frames_passed:	.byte 0
00386B  2  00           frames_delay:	.byte 0
00386C  2               
00386C  2               nmi_handler:
00386C  2  2C 0F D4     	bit NMIST
00386F  2  30 2A        	bmi dli_handler
003871  2  10 0D        	bpl nmi_not_dli
003873  2               nmi_not_vbi:
003873  2  A9 20        	lda #%00100000
003875  2  2C 0F D4     	bit NMIST
003878  2  D0 04        	bne nmi_not_reset
00387A  2  8D 0F D4     	sta NMIRES
00387D  2  40           	rti
00387E  2               nmi_not_reset:
00387E  2  68           	pla
00387F  2  40           	rti
003880  2               nmi_not_dli:
003880  2  48           	pha
003881  2  50 F0        	bvc nmi_not_vbi
003883  2  8A           	txa
003884  2  48           	pha
003885  2  98           	tya
003886  2  48           	pha
003887  2               
003887  2               ; Used for syncing to 25 Hz
003887  2               
003887  2  EE 6A 38     	inc frames_passed
00388A  2               
00388A  2  EE 68 38     	inc frame_counter
00388D  2  D0 03        	bne skip_inc_frame_counter
00388F  2  EE 69 38     	inc frame_counter+1
003892  2               skip_inc_frame_counter:
003892  2               
003892  2               ; Adjust delay counter
003892  2               
003892  2  CE 6B 38     	dec frames_delay
003895  2               
003895  2               ; Restore registers
003895  2               
003895  2  68           	pla
003896  2  A8           	tay
003897  2  68           	pla
003898  2  AA           	tax
003899  2  68           	pla
00389A  2  40           	rti
00389B  2               
00389B  2               dli_handler:
00389B  2  40           	rti
00389C  2               
00389C  2               ;========================================================
00389C  2               ; KEY AND JOYSTICK ROUTINES
00389C  2               ;--------------------------------------------------------
00389C  2               ; Keys
00389C  2               ;
00389C  2               ; Out: joyval=x65FUDLR (bit cleared if key pressed)
00389C  2               ;             ||||||||
00389C  2               ;             |||||||+> Right    KEY 0  - X
00389C  2               ;             ||||||+-> Left     KEY 1  - Z
00389C  2               ;             |||||+--> Down     KEY 2  - .
00389C  2               ;             ||||+---> Up       KEY 3  - ;
00389C  2               ;             |||+----> Fire1    KEY 4  - SPC
00389C  2               ;             ||+-----> Fire2    KEY 5  - Q
00389C  2               ;             |+------> Fire3    KEY 6  - P
00389C  2               ;             +-------> Not used
00389C  2               ;
00389C  2               ;                       Option1  KEY 7  - 1
00389C  2               ;                       Option2  KEY 8  - 2
00389C  2               ;                       Option3  KEY 9  - 3
00389C  2               ;                       Option4  KEY 10 - 4
00389C  2               ;--------------------------------------------------------
00389C  2               ;----------------------------------------------------
00389C  2               ; PRSKEY
00389C  2               ; Wait for keypress.
00389C  2               ;----------------------------------------------------
00389C  2               
00389C  2               prskey:
00389C  2  AD 0F D2     	lda SKSTAT		; Check keypress
00389F  2  29 7F        	and #127
0038A1  2  C9 7F        	cmp #127
0038A3  2  F0 03        	beq :+
0038A5  2  4C B1 38     	jmp prsend
0038A8  2               :
0038A8  2  20 70 29     	jsr joykey		; Check joystick move
0038AB  2  29 7F        	and #127
0038AD  2  C9 7F        	cmp #127
0038AF  2  F0 EB        	beq prskey
0038B1  2               prsend:
0038B1  2  AD 0F D2     	lda SKSTAT		; Check release
0038B4  2  29 7F        	and #127
0038B6  2  C9 7F        	cmp #127
0038B8  2  D0 F7        	bne prsend
0038BA  2  60           	rts
0038BB  2               
0038BB  2               ;--------------------------------------------------------
0038BB  2               ; KTEST
0038BB  2               ; Check if key in A is pressed,
0038BB  2               ;  carry clr = key pressed
0038BB  2               ;  carry set = key not pressed
0038BB  2               ;--------------------------------------------------------
0038BB  2               
0038BB  2               ktest:
0038BB  2  85 rr        	sta tmp
0038BD  2  AD 0F D2     	lda SKSTAT		; Check keypress
0038C0  2  29 04        	and #4
0038C2  2  D0 07        	bne notpressed
0038C4  2  A5 rr        	lda tmp
0038C6  2  CD 09 D2     	cmp KBCODE
0038C9  2  F0 02        	beq pressed
0038CB  2               notpressed:
0038CB  2  38           	sec
0038CC  2  60           	rts
0038CD  2               pressed:
0038CD  2  18           	clc			; key pressed
0038CE  2  60           	rts
0038CF  2               
0038CF  2               ;---------------------------------------------------------------
0038CF  2               ; KGET
0038CF  2               ; Return keycode when a key is pressed and released
0038CF  2               ;---------------------------------------------------------------
0038CF  2               
0038CF  2               kget:
0038CF  2  AD 0F D2     	lda SKSTAT		; Check keypress
0038D2  2  29 04        	and #4
0038D4  2  D0 F9        	bne kget
0038D6  2  AD 09 D2     	lda KBCODE		; If pressed, get keycode
0038D9  2  48           	pha			; Save keycode pressed
0038DA  2               kget2:
0038DA  2  AD 0F D2     	lda SKSTAT		; Check keypress
0038DD  2  29 04        	and #4
0038DF  2  F0 F9        	beq kget2
0038E1  2  68           	pla
0038E2  2  60           	rts
0038E3  2               
0038E3  2               ;-------------------------------------------------------
0038E3  2               ; Joystick routines.
0038E3  2               ;
0038E3  2               ; contrl = 1, Joystick1
0038E3  2               ;          2, Joystick2
0038E3  2               ;-------------------------------------------------------
0038E3  2               
0038E3  2               ; Iitialize joysticks
0038E3  2               
0038E3  2               joyinit:
0038E3  2  60           	rts
0038E4  2               
0038E4  2               ; Joystick1 controls.
0038E4  2               
0038E4  2               joy1:
0038E4  2  A9 00        	lda #0		 	; zero reading.
0038E6  2  85 rr        	sta joyval
0038E8  2               
0038E8  2  AD 26 38     	lda keys+6		; Check Fire3
0038EB  2  20 BB 38     	jsr ktest
0038EE  2  26 rr        	rol joyval
0038F0  2  AD 25 38     	lda keys+5		; Check Fire2
0038F3  2  20 BB 38     	jsr ktest
0038F6  2  26 rr        	rol joyval
0038F8  2  AD 10 D0     	lda TRIG0		; Check Fire
0038FB  2  4A           	lsr
0038FC  2  26 rr        	rol joyval
0038FE  2               
0038FE  2  AD 00 D3     	lda STICK
003901  2  85 rr        	sta tmp
003903  2  46 rr        	lsr tmp			; Check up
003905  2  26 rr        	rol joyval
003907  2  46 rr        	lsr tmp			; Check dwon
003909  2  26 rr        	rol joyval
00390B  2  46 rr        	lsr tmp			; Check left
00390D  2  26 rr        	rol joyval
00390F  2  46 rr        	lsr tmp			; Check right
003911  2  26 rr        	rol joyval
003913  2               
003913  2  60           	rts
003914  2               
003914  2               ; Joystick2 controls.
003914  2               
003914  2               joy2:
003914  2  A9 00        	lda #0		 	; zero reading.
003916  2  85 rr        	sta joyval
003918  2               
003918  2  AD 26 38     	lda keys+6		; Check Fire3
00391B  2  20 BB 38     	jsr ktest
00391E  2  26 rr        	rol joyval
003920  2  AD 25 38     	lda keys+5		; Check Fire2
003923  2  20 BB 38     	jsr ktest
003926  2  26 rr        	rol joyval
003928  2  AD 11 D0     	lda TRIG1		; Check Fire
00392B  2  4A           	lsr
00392C  2  26 rr        	rol joyval
00392E  2               
00392E  2  AD 00 D3     	lda STICK
003931  2  4A           	lsr a
003932  2  4A           	lsr a
003933  2  4A           	lsr a
003934  2  4A           	lsr a
003935  2  85 rr        	sta tmp
003937  2  46 rr        	lsr tmp			; Check up
003939  2  26 rr        	rol joyval
00393B  2  46 rr        	lsr tmp			; Check dwon
00393D  2  26 rr        	rol joyval
00393F  2  46 rr        	lsr tmp			; Check left
003941  2  26 rr        	rol joyval
003943  2  46 rr        	lsr tmp			; Check right
003945  2  26 rr        	rol joyval
003947  2               
003947  2  60           	rts
003948  2               
003948  2               ;-------------------------------------------------------
003948  2               ; Colours
003948  2               ;-------------------------------------------------------
003948  2               
003948  2               ; INK sets foreground colour
003948  2               
003948  2               setfgcol:
003948  2  29 03        	and #3
00394A  2  A8           	tay
00394B  2  B9 6D 39     	lda codcol,y
00394E  2  4C 64 39     	jmp calfgc
003951  2               
003951  2               ; PAPER sets background colour
003951  2               
003951  2               setbgcol:
003951  2  29 03        	and #3
003953  2               calbgc:
003953  2  A8           	tay
003954  2  B9 6D 39     	lda codcol,y
003957  2  48           	pha
003958  2  AD 6B 39     	lda andeor
00395B  2  4D 6C 39     	eor andeor+1
00395E  2  AA           	tax
00395F  2  68           	pla
003960  2  8D 6C 39     	sta andeor+1
003963  2  8A           	txa
003964  2               calfgc:
003964  2  4D 6C 39     	eor andeor+1
003967  2  8D 6B 39     	sta andeor
00396A  2               calex1:
00396A  2  60           	rts
00396B  2               
00396B  2  00 00        andeor:	.byte 0,0
00396D  2  00 55 AA FF  codcol:	.byte $00,$55,$aa,$ff
003971  2               
003971  2               ;---------------------------------------------------------------
003971  2               ; Bitmap display list must be aligned at $100
003971  2               ;---------------------------------------------------------------
003971  2               bitmaplist:
003971  2               
003971  2               ; Align $100
003971  2               
003971  2  00 00 00 00  .repeat ((bitmaplist/256)+1)*256-bitmaplist
003975  2  00 00 00 00  
003979  2  00 00 00 00  
003A00  2               	.byte 0
003A00  2               .endrepeat
003A00  2               
003A00  2               ; Set graphic mode
003A00  2               
003A00  2               .if gflag
003A00  2               	GFXMODE = MODEE
003A00  2               .else
003A00  2               	GFXMODE = MODEF
003A00  2               .endif
003A00  2               
003A00  2               BITMAP_DLIST:
003A00  2  70           	.byte BLANK8
003A01  2  70           	.byte BLANK8
003A02  2  70           	.byte BLANK8
003A03  2               
003A03  2  4E           	.byte LMS+GFXMODE
003A04  2  00 E4        	.word ScreenAddr
003A06  2  0E 0E 0E 0E  	.res 95,GFXMODE
003A0A  2  0E 0E 0E 0E  
003A0E  2  0E 0E 0E 0E  
003A65  2               
003A65  2  4E            	.byte LMS+GFXMODE
003A66  2  00 F0        	.word ScreenAddr+96*32
003A68  2  0E 0E 0E 0E  	.res 95,GFXMODE
003A6C  2  0E 0E 0E 0E  
003A70  2  0E 0E 0E 0E  
003AC7  2               
003AC7  2  41           	.byte DLISTENDJUMP
003AC8  2  00 3A        	.word BITMAP_DLIST
003ACA  2               
003ACA  2               
003ACA  1               	.include "z80.asm"
003ACA  2               ;------------------------------------------------------
003ACA  2               ; z80.asm
003ACA  2               ; spectrum stuff
003ACA  2               ; adresses
003ACA  2               
003ACA  2               
003ACA  2               ; Contains seperatly 1 bit set
003ACA  2               
003ACA  2               _bitmem0	= $f8
003ACA  2               _bitmem1	= $f9
003ACA  2               _bitmem2	= $fa
003ACA  2               _bitmem3	= $fb
003ACA  2               _bitmem4	= $fc
003ACA  2               _bitmem5	= $fd
003ACA  2               _bitmem6	= $fe
003ACA  2               _bitmem7	= $ff
003ACA  2               
003ACA  2               ; constants
003ACA  2               _bitvalue0	= $01
003ACA  2               _bitvalue1	= $02
003ACA  2               _bitvalue2	= $04
003ACA  2               _bitvalue3	= $08
003ACA  2               _bitvalue4	= $10
003ACA  2               _bitvalue5	= $20
003ACA  2               _bitvalue6	= $40
003ACA  2               _bitvalue7	= $80
003ACA  2               
003ACA  2               _notbitvalue0	= $fe
003ACA  2               _notbitvalue1	= $fd
003ACA  2               _notbitvalue2	= $fb
003ACA  2               _notbitvalue3	= $f7
003ACA  2               _notbitvalue4	= $ef
003ACA  2               _notbitvalue5	= $df
003ACA  2               _notbitvalue6	= $bf
003ACA  2               _notbitvalue7	= $7f
003ACA  2               
003ACA  2               
003ACA  2               exx:
003ACA  2  A5 62        		lda z80_c
003ACC  2  A4 6E        		ldy z80_cp
003ACE  2  84 62        		sty z80_c
003AD0  2  85 6E        		sta z80_cp
003AD2  2  A5 63        		lda z80_b
003AD4  2  A4 6F        		ldy z80_bp
003AD6  2  84 63        		sty z80_b
003AD8  2  85 6F        		sta z80_bp
003ADA  2  A5 64        		lda z80_e
003ADC  2  A4 70        		ldy z80_ep
003ADE  2  84 64        		sty z80_e
003AE0  2  85 70        		sta z80_ep
003AE2  2  A5 65        		lda z80_d
003AE4  2  A4 71        		ldy z80_dp
003AE6  2  84 65        		sty z80_d
003AE8  2  85 71        		sta z80_dp
003AEA  2  A5 rr        		lda scraddr
003AEC  2  A4 72        		ldy z80_lp
003AEE  2  84 rr        		sty scraddr
003AF0  2  85 72        		sta z80_lp
003AF2  2  A5 rr        		lda scraddr+1
003AF4  2  A4 73        		ldy z80_hp
003AF6  2  84 rr        		sty scraddr+1
003AF8  2  85 73        		sta z80_hp
003AFA  2  60           		rts
003AFB  2               
003AFB  2               
003AFB  1               eind_asm:
003AFB  1               eop:					; End Of Program
003AFB  1               
003AFB  1               .out .sprintf("Gamecode size = %d bytes, free space = %d bytes", (eind_asm - start_asm),(48384-eind_asm + start_asm))
003AFB  1               
