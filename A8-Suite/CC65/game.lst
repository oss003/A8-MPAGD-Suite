ca65 V2.17 - Git d13d068
Main file   : game.asm
Current file: game.asm

000000r 1               ;----------------------------------------------
000000r 1               ; Common AGD engine
000000r 1               ; Z80 conversion by Kees van Oss 2017
000000r 1               ;----------------------------------------------
000000r 1               	.DEFINE asm_code $0600
000000r 1               	.include "game.cfg"
000000r 2               ; Flags saved by AGD Compiler
000000r 2               
000000r 2               mflag   = 0 ;
000000r 2               pflag   = 0 ;
000000r 2               sflag   = 0 ;
000000r 2               dflag   = 0 ;
000000r 2               cflag   = 0 ;
000000r 2               oflag   = 0 ;
000000r 2               lflag   = 0 ;
000000r 2               crflag  = 0 ;
000000r 2               clwflag = 0 ;
000000r 2               bigflag = 1 ;
000000r 2               
000000r 1               
000000r 1               .segment "ZEROPAGE"
000000r 1               	.include "z80-zp.inc"
000000r 2               ;.segment "ZEROPAGE"
000000r 2               
000000r 2               ws	 = $60
000000r 2               
000000r 2               z80_f	 = ws+$00
000000r 2               z80_a	 = ws+$01
000000r 2               z80_af	 = z80_f
000000r 2               
000000r 2               z80_c	 = ws+$02
000000r 2               z80_b	 = ws+$03
000000r 2               z80_bc	 = z80_c
000000r 2               
000000r 2               z80_e	 = ws+$04
000000r 2               z80_d	 = ws+$05
000000r 2               z80_de	 = z80_e
000000r 2               
000000r 2               z80_l	 = ws+$06
000000r 2               z80_h	 = ws+$07
000000r 2               z80_hl	 = z80_l
000000r 2               
000000r 2               z80_x    = ws+$08
000000r 2               z80_i    = ws+$09
000000r 2               z80_ix	 = z80_x
000000r 2               
000000r 2               z80_iy	 = ws+$0a
000000r 2               
000000r 2               z80_fp	 = ws+$0c
000000r 2               z80_ap	 = ws+$0d
000000r 2               
000000r 2               z80_cp	 = ws+$0e
000000r 2               z80_bp	 = ws+$0f
000000r 2               z80_bcp	 = z80_cp
000000r 2               
000000r 2               z80_ep	 = ws+$10
000000r 2               z80_dp	 = ws+$11
000000r 2               z80_dep	 = z80_ep
000000r 2               
000000r 2               z80_lp	 = ws+$12
000000r 2               z80_hp	 = ws+$13
000000r 2               z80_hlp	 = z80_lp
000000r 2               
000000r 2               z80_sp   = ws+$14
000000r 2               
000000r 2               z80_reg0 = ws+$16
000000r 2               z80_reg1 = ws+$17
000000r 2               z80_reg2 = ws+$18
000000r 2               z80_reg3 = ws+$19
000000r 2               
000000r 2               z80_r	 = ws+$1a
000000r 2               
000000r 2               
000000r 1               	.include "engine-zp.inc"
000000r 2               ;----------------------------------------------------------------------
000000r 2               ; AGD 6502 Engine Zero Page Variables
000000r 2               ;----------------------------------------------------------------------
000000r 2               
000000r 2               ; Variables start here.
000000r 2               
000000r 2  xx           scno:	.res 1			; present screen number.
000001r 2  xx           numlif:	.res 1			; number of lives.
000002r 2               
000002r 2  xx           vara:	.res 1			; general-purpose variable.
000003r 2  xx           varb:	.res 1			; general-purpose variable.
000004r 2  xx           varc:	.res 1			; general-purpose variable.
000005r 2  xx           vard:	.res 1			; general-purpose variable.
000006r 2  xx           vare:	.res 1			; general-purpose variable.
000007r 2  xx           varf:	.res 1			; general-purpose variable.
000008r 2  xx           varg:	.res 1			; general-purpose variable.
000009r 2  xx           varh:	.res 1			; general-purpose variable.
00000Ar 2  xx           vari:	.res 1			; general-purpose variable.
00000Br 2  xx           varj:	.res 1			; general-purpose variable.
00000Cr 2  xx           vark:	.res 1			; general-purpose variable.
00000Dr 2  xx           varl:	.res 1			; general-purpose variable.
00000Er 2  xx           varm:	.res 1			; general-purpose variable.
00000Fr 2  xx           varn:	.res 1			; general-purpose variable.
000010r 2  xx           varo:	.res 1			; general-purpose variable.
000011r 2  xx           varp:	.res 1			; general-purpose variable.
000012r 2  xx           varq:	.res 1			; general-purpose variable.
000013r 2  xx           varr:	.res 1			; general-purpose variable.
000014r 2  xx           vars:	.res 1			; general-purpose variable.
000015r 2  xx           vart:	.res 1			; general-purpose variable.
000016r 2  xx           varu:	.res 1			; general-purpose variable.
000017r 2  xx           varv:	.res 1			; general-purpose variable.
000018r 2  xx           varw:	.res 1			; general-purpose variable.
000019r 2  xx           varz:	.res 1			; general-purpose variable.
00001Ar 2               
00001Ar 2  xx           charx:	.res 1			; cursor x position.
00001Br 2  xx           chary:	.res 1			; cursor y position.
00001Cr 2               
00001Cr 2  xx           clock:	.res 1			; last clock reading.
00001Dr 2  xx           varrnd:	.res 1	        	; last random number.
00001Er 2  xx           varobj:	.res 1  	   	; last object number.
00001Fr 2  xx           varopt:	.res 1     		; last option chosen from menu.
000020r 2  xx           varblk:	.res 1  		; block type.
000021r 2  xx           nexlev:	.res 1			; next level flag.
000022r 2  xx           restfl:	.res 1			; restart screen flag.
000023r 2  xx           deadf:	.res 1			; dead flag.
000024r 2  xx           gamwon:	.res 1			; game won flag.
000025r 2  xx           dispx:	.res 1			; cursor x position.
000026r 2  xx           dispy:	.res 1			; cursor y position.
000027r 2               
000027r 2  xx           contrl:	.res 1			; control = keyboard, 1 = Kempston, 2 = Sinclair, 3 = Mouse.
000028r 2  xx           joyval:	.res 1			; joystick reading.
000029r 2  xx           frmno:	.res 1			; selected frame.
00002Ar 2               
00002Ar 2               ;----------------------------------------------------
00002Ar 2               ; Missing vars
00002Ar 2               ;----------------------------------------------------
00002Ar 2               
00002Ar 2  xx           loopa:	    .res 1
00002Br 2  xx           loopb:	    .res 1
00002Cr 2  xx           loopc:	    .res 1
00002Dr 2  xx xx        FontPtr:    .res 2
00002Fr 2               
00002Fr 2               ; Local vars
00002Fr 2               
00002Fr 2  xx xx        scraddr:    .res 2
000031r 2  xx xx        fntaddr:    .res 2
000033r 2  xx xx        tileaddr:   .res 2
000035r 2  xx xx        bufaddr:    .res 2
000037r 2  xx xx        advbuff:    .res 2
000039r 2               
000039r 2  xx xx        tmp:        .res 2
00003Br 2  xx xx        scr_l:      .res 2
00003Dr 2  xx xx        scr_r:      .res 2
00003Fr 2  xx xx        scr_txt:    .res 2
000041r 2               
000041r 2  xx           xtmp:	    .res 1
000042r 2  xx           ytmp:	    .res 1
000043r 2  xx           spcnt:	    .res 1
000044r 2  xx xx        spptr:	    .res 2		; spawned sprite pointer.
000046r 2  xx           seed:	    .res 1		; seed for random numbers.
000047r 2               
000047r 2  xx           ccnt:       .res 1
000048r 2  xx           flag:	    .res 1
000049r 2  xx           rcol:	    .res 1
00004Ar 2  xx           rrow:	    .res 1
00004Br 2               
00004Br 2  xx           combyt:	    .res 1		; byte type compressed.
00004Cr 2  xx           comcnt:	    .res 1		; compression counter.
00004Dr 2  xx           prtmod:	    .res 1      	; print mode, 0 = standard, 1 = double-height.
00004Er 2  xx           qscnt:	    .res 1
00004Fr 2               
00004Fr 2  xx           sprptr:	    .res 1      	; not a ptr
000050r 2  xx           sprcnt:	    .res 1
000051r 2               
000051r 2  xx xx        skptr:	    .res 2		; search pointer.
000053r 2  xx           sktptr:	    .res 1      	; not a ptr
000054r 2  xx           tmproom:    .res 1
000055r 2  xx xx        ogptr:	    .res 2		; original sprite pointer.
000057r 2               
000057r 2               .if mflag
000057r 2               TmpAddr:    .res 2
000057r 2               bwid:	    .res 1     		; box/menu width.
000057r 2               blen:	    .res 1     		; box/menu height.
000057r 2               btop:	    .res 1    	 	; box coordinates.
000057r 2               blft:	    .res 1
000057r 2               .endif
000057r 2               
000057r 2               .if sflag .or pflag
000057r 2               shrctr:	    .res 1
000057r 2               .endif
000057r 2               .if pflag
000057r 2               explcnt:    .res 1
000057r 2               seed3:	    .res 1
000057r 2               .endif
000057r 2               
000057r 2               .if aflag
000057r 2               pbptr:       .res 2
000057r 2               pbbuf:	     .res 2
000057r 2               .endif
000057r 2               
000057r 2               ;sndtyp:     .res 1
000057r 2               
000057r 2               .if rflag
000057r 2               sprshft:     .res 1
000057r 2               .endif
000057r 2               
000057r 1               
000057r 1               
000057r 1               .org asm_code -6
0005FA  1  FF FF        	.word $ffff
0005FC  1  00 06        	.word start_asm
0005FE  1  EC 1E        	.word eind_asm - 1
000600  1               
000600  1               .segment "CODE"
000600  1               
000600  1               exec:
000600  1               start_asm:
000600  1               	.include "game.inc"
000600  2               .include "testclock.inc"
000600  3               ;--------------------------------------------------------------
000600  3               ; Arcade Game Designer.
000600  3               ; (C) 2008 Jonathan Cauldwell.
000600  3               ; ZX Spectrum Next Engine v0.7.
000600  3               ; Acorn Atom port by K.v.Oss 2018
000600  3               ;--------------------------------------------------------------
000600  3               
000600  3               ; Conditional compilation flags
000600  3               ; Code is installed if flag is set
000600  3               ; Flags are set in commandline assembly or by the compiler
000600  3               
000600  3               ; Flags set by AGD compiler
000600  3               ;	mflag  			; MENU + INV
000600  3               ;	pflag 			; particle engine
000600  3               ;	sflag 			; scrollytext
000600  3               ;	dflag 			; digging mode
000600  3               ;	cflag			; collectable blocks
000600  3               ;	oflag			; objects
000600  3               ;	lflag			; ladders
000600  3               ;
000600  3               ; Flags set manually
000600  3               ;	aflag			; adventure mode
000600  3               ;	bflag			; big sprites (16x24)
000600  3               ;	iflag			; invert mode
000600  3               
000600  3               .if mflag
000600  3               	.out "- MEN/INV enabled"
000600  3               .endif
000600  3               .if pflag
000600  3               	.out "- Particles enabled"
000600  3               .endif
000600  3               .if sflag
000600  3               	.out "- Scrolling enabled"
000600  3               .endif
000600  3               .if dflag
000600  3               	.out "- Digging enabled"
000600  3               .endif
000600  3               .if cflag
000600  3               	.out "- Collectable blocks enabled"
000600  3               .endif
000600  3               .if oflag
000600  3               	.out "- Objects enabled"
000600  3               .endif
000600  3               .if lflag
000600  3               	.out "- Ladders enabled"
000600  3               .endif
000600  3               .if aflag
000600  3               	.out "- Adventure mode enabled"
000600  3               .endif
000600  3               .if bflag
000600  3               	.out "- Big Sprites (16x24) enabled"
000600  3               .endif
000600  3               .if iflag
000600  3               	.out "- Invert mode enabled"
000600  3               .endif
000600  3               
000600  3               ; Global definitions ------------------------------------------------------------
000600  3               
000600  3               	FONT = font		; Font address
000600  3               
000600  3               	green	= $00		; Colour definition filters
000600  3               	yellow	= $55
000600  3               	blue	= $aa
000600  3               	red	= $ff
000600  3               
000600  3               ; Block characteristics.
000600  3               
000600  3               	PLATFM	= 1		; platform.
000600  3               	WALL	= PLATFM + 1	; solid wall.
000600  3               	LADDER	= WALL + 1	; ladder.
000600  3               	FODDER	= LADDER + 1	; fodder block.
000600  3               	DEADLY	= FODDER + 1	; deadly block.
000600  3               	CUSTOM	= DEADLY + 1	; custom block.
000600  3               	WATER	= CUSTOM + 1	; water block.
000600  3                       COLECT	= WATER + 1	; collectable block.
000600  3                       NUMTYP	= COLECT + 1	; number of types.
000600  3               
000600  3               ; Sprites.
000600  3               
000600  3               .if bflag
000600  3               	SPR_HGT	= 24		; Sprite height
000600  3               	SPR_WID = 16		; Sprite width
000600  3               	NUMSPR	= 8		; number of sprites.
000600  3               .else				; 16x16 sprites
000600  3               	SPR_HGT = 16		; Sprite height
000600  3               	SPR_WID = 16		; Sprite width
000600  3               	NUMSPR	= 12		; number of sprites.
000600  3               .endif
000600  3               
000600  3               	TABSIZ = 17		; size of each entry.
000600  3               	SPRBUF = NUMSPR * TABSIZ; size of entire table.
000600  3               	NMESIZ = 4		; bytes stored in nmetab for each sprite.
000600  3               	var_X  = 8		; new x coordinate of sprite.
000600  3               	var_Y  = var_X + 1	; new y coordinate of sprite.
000600  3               	PAM1ST = 5		; first sprite parameter, old x (ix+5).
000600  3               
000600  3               ; Particle engine.
000600  3               
000600  3               	NUMSHR = 55		; pieces of shrapnel.
000600  3               	SHRSIZ = 6		; bytes per particle.
000600  3               
000600  3               ; System constants
000600  3               
000600  3               	ScreenAddr  = $8000	; Startaddress video RAM
000600  3               	ScrSelAddr  = $b000	; Screen selection address
000600  3               	KeyRowAddr  = $b000	; PIA key matrix row
000600  3               	KeyColAddr  = $b001	; PIA key matrix column
000600  3               	SpeakerBit  = $b002	; Speaker bit
000600  3               	CmdReg      = $b400	; Command register AtoMMC
000600  3               	DatReg      = $b401	; Data register AtoMMC
000600  3               	Timer2_Low  = $b808	; Timer 2 low byte
000600  3               	Timer2_High = $b809	; Timer 2 high byte
000600  3               
000600  3               ; System calls
000600  3               
000600  3               	SCRSYNC	 = $fe66	; wait for next CRT field flyback 60 Hz
000600  3               	SCRSYNC1 = $fe6b	; wait for CRT field flyback 60 Hz
000600  3               	OSRDCH   = $fe94	; get key subroutine
000600  3                       READKEY  = $fe71	; scan key matrix subroutine
000600  3               	OSWRCH	 = $fff4	; write character
000600  3               
000600  3               
000600  3               .if iflag
000600  3               	TxtInvert   = $ff	; Invert byte for character printing
000600  3               	ScrFillByte = $ff	; Screen fill byte for CLS
000600  3               .else
000600  3               	TxtInvert   = $00	; Invert byte for character printing
000600  3               	ScrFillByte = $00	; Screen fill byte for CLS
000600  3               .endif
000600  3               
000600  3               	ScrMode     = $f0	;  $f0 = CLEAR4  mono
000600  3               
000600  3               ;===============================================================
000600  3               ; Game starts here
000600  3               ;===============================================================
000600  3               
000600  3               .segment "CODE"
000600  3               
000600  3  78           	sei
000601  3  A2 00        	ldx #0
000603  3               testloop:
000603  3  BD 15 06     	lda teststring,x
000606  3  F0 0A        	beq endtest
000608  3  38           	sec
000609  3  E9 20        	sbc #32
00060B  3  9D 40 9C     	sta $9c40,x
00060E  3  E8           	inx
00060F  3  4C 03 06     	jmp testloop
000612  3               endtest:
000612  3  4C 12 06     	jmp endtest
000615  3               
000615  3  48 45 4C 4C  teststring:	.byte "HELLO WORLD",0
000619  3  4F 20 57 4F  
00061D  3  52 4C 44 00  
000621  3               
000621  3               
000621  3               ; Clear variables
000621  3               
000621  3  A9 00        	lda #0
000623  3  A2 00        	ldx #0
000625  3               clrloop:
000625  3  95 00        	sta 0,x
000627  3  E8           	inx
000628  3  D0 FB        	bne clrloop
00062A  3               
00062A  3  20 22 07     	jsr game	 	; start the game.
00062D  3  A9 0C        	lda #12			; Clear screen + exit to Basic
00062F  3  20 F4 FF     	jsr OSWRCH
000632  3  4C B2 C2     	jmp $C2B2		; Back to Basic
000635  3               
000635  3               ; Definition of variables
000635  3               ; Make sure pointers are arranged in the same order as the data itself.
000635  3               
000635  3  BE 1A        msgptr:		.word msgdat	; messages
000637  3  EC 1A        blkptr:		.word chgfx	; block graphics.
000639  3  F4 1A        proptr:		.word bprop	; address of char properties.
00063B  3  F5 1A        sptptr:		.word sprgfx	; sprite graphics
00063D  3  75 1B        frmptr:		.word frmlst	; sprite frames.
00063F  3  79 1B        scrptr:		.word scdat	; address of screens.
000641  3  85 1B        nmeptr:		.word nmedat	; enemy start positions.
000643  3  8A 1B        objptr:		.word objdta	; object graphics
000645  3               
000645  3               ;TxtFilter:	.byte $ff
000645  3  00 55 AA FF  txtcol:		.byte green,yellow,blue,red
000649  3               
000649  3               ; Don't change the order of these four.
000649  3               ; Menu routine relies on winlft following wintop.
000649  3               
000649  3  01           wintop:		.byte WINDOWTOP	; top of window.
00064A  3  01           winlft:		.byte WINDOWLFT	; left edge.
00064B  3  16           winhgt:		.byte WINDOWHGT	; window height.
00064C  3  1E           winwid:		.byte WINDOWWID	; window width.
00064D  3  01           numob:		.byte NUMOBJ	; number of objects in game.
00064E  3               
00064E  3               ; Variables start here.
00064E  3               ; Pixel versions of wintop, winlft, winhgt, winwid.
00064E  3               
00064E  3  08           wntopx:		.byte (8 * WINDOWTOP)
00064F  3  08           wnlftx:		.byte (8 * WINDOWLFT)
000650  3  A8           wnbotx:		.byte ((WINDOWTOP * 8) + (WINDOWHGT * 8) - 16)
000651  3  E6           wnrgtx:		.byte ((WINDOWLFT * 8) + (WINDOWWID * 8) - 16)-2
000652  3               
000652  3               ; Assorted game routines which can go in contended memory.
000652  3               
000652  3               ;--------------------------------------------------------------
000652  3               ; Entry for inventory called by the INV command
000652  3               ;
000652  3               ; Input:
000652  3               ;  X   = message nr with objects seperated with ,
000652  3               ;
000652  3               ; Output:
000652  3               ;  OPT = selected objectnr of INV menu
000652  3               ;--------------------------------------------------------------
000652  3               
000652  3               .if mflag
000652  3               minve:
000652  3               	lda #<(invdis)		; routine address.
000652  3               	sta mod0+1		; set up menu routine.
000652  3               	sta mod2+1		; set up count routine.
000652  3               	lda #>(invdis)
000652  3               	sta mod0+2
000652  3               	sta mod2+2
000652  3               	lda #<(fopt)		; find option from available objects.
000652  3               	sta mod1+1		; set up routine.
000652  3               	lda #>(fopt)
000652  3               	sta mod1+1+1
000652  3               	jmp dbox		; do menu routine.
000652  3               
000652  3               ;--------------------------------------------------------------
000652  3               ; Entry for menu called by the MENU command
000652  3               ;
000652  3               ; Input:
000652  3               ;  X   = message nr with menu items seperated with ,
000652  3               ;
000652  3               ; Output:
000652  3               ;  OPT = selected line nr of MENU menu
000652  3               ;--------------------------------------------------------------
000652  3               
000652  3               mmenu:
000652  3               	lda #<(always)		; routine address.
000652  3               	sta mod0+1		; set up routine.
000652  3               	sta mod2+1		; set up count routine.
000652  3               	lda #>(always)
000652  3               	sta mod0+2
000652  3               	sta mod2+2
000652  3               
000652  3               	lda #<(fstd)		; standard option selection.
000652  3               	sta mod1+1		; set up routine.
000652  3               	lda #>(fstd)
000652  3               	sta mod1+2
000652  3               
000652  3               ; Drop through into box routine.
000652  3               
000652  3               ;--------------------------------------------------------------
000652  3               ; Work out size of box for message or menu.
000652  3               ;--------------------------------------------------------------
000652  3               
000652  3               dbox:
000652  3               	lda #<(msgdat)		; pointer to messages.
000652  3               	sta z80_l
000652  3               	lda #>(msgdat)
000652  3               	sta z80_h
000652  3               
000652  3               	jsr getwrd		; get message number.
000652  3               
000652  3               	lda z80_h		; store pointer to message.
000652  3               	sta TmpAddr
000652  3               	lda z80_l
000652  3               	sta TmpAddr+1
000652  3               
000652  3               	lda #1			; height.
000652  3               	sta z80_d
000652  3               	lda #0			; start at object zero.
000652  3               	sta combyt		; store number of object in combyt.
000652  3               	sta z80_e		; maximum width.
000652  3               dbox5:
000652  3               	lda #0			; this line"s width.
000652  3               	sta z80_b
000652  3               mod2:
000652  3               	jsr always		; item in player"s possession?
000652  3               	cmp #255
000652  3               	bne dbox6		; not in inventory, skip this line.
000652  3               	inc z80_d		; add to tally.
000652  3               dbox6:
000652  3               	ldy #0			; get character.
000652  3               	lda (z80_hl),y
000652  3               	sta z80_a
000652  3               	inc z80_l		; next character.
000652  3               	bne :+
000652  3               	inc z80_h
000652  3               :
000652  3               	lda z80_a		; reached end of line?
000652  3               	cmp #','
000652  3               	beq dbox3		; yes.
000652  3               	cmp #13
000652  3               	beq dbox3		; yes.
000652  3               	inc z80_b		; add to this line"s width.
000652  3               	lda z80_a
000652  3               	bmi dbox4		; end of message? yes, end count.
000652  3               	jmp dbox6		; repeat until we find the end.
000652  3               dbox3:
000652  3               	lda z80_e		; maximum line width.
000652  3               	cmp z80_b		; have we exceeded longest so far?
000652  3               	bpl dbox5		; no, carry on looking.
000652  3               	lda z80_b		; make this the widest so far.
000652  3               	sta z80_e
000652  3               	jmp dbox5		; keep looking.
000652  3               dbox4:
000652  3               	lda z80_e		; maximum line width.
000652  3               	cmp z80_b		; have we exceeded longest so far?
000652  3               	bpl dbox8		; no, carry on looking.
000652  3               	lda z80_b		; final line is the longest so far.
000652  3               	sta z80_e
000652  3               dbox8:
000652  3               	dec z80_d		; decrement items found.
000652  3               	bne :+			; total was zero.
000652  3               	lda #255
000652  3               	sta varopt
000652  3               	jmp dbox15
000652  3               :
000652  3               	lda z80_e		; longest line.
000652  3               	bne :+			; was it zero?
000652  3               	jmp dbox15		; total was zero.
000652  3               :
000652  3               	sta bwid		; set up size.
000652  3               	lda z80_d
000652  3               	sta blen
000652  3               
000652  3               ;--------------------------------------------------------------
000652  3               ; That's set up our box size.
000652  3               ;--------------------------------------------------------------
000652  3               
000652  3               	lda winhgt		; window height in characters.
000652  3               	sec
000652  3               	sbc z80_d		; subtract height of box.
000652  3               	lsr a			; divide by 2.
000652  3               	clc
000652  3               	adc wintop		; add top edge of window.
000652  3               	sta btop		; set up box top.
000652  3               
000652  3               	lda winwid		; window width in characters.
000652  3               	sec
000652  3               	sbc z80_e		; subtract box width.
000652  3               	lsr a			; divide by 2.
000652  3               	clc
000652  3               	adc winlft		; add left edge of window.
000652  3               	sta blft		; box left.
000652  3               
000652  3               	lda #<(FONT-256)		; font.
000652  3               	sta grbase		; set up for text display.
000652  3               	lda #>(FONT-256)
000652  3               	sta grbase+1
000652  3               
000652  3               	lda TmpAddr+1		; restore message pointer.
000652  3               	sta z80_l
000652  3               	lda TmpAddr
000652  3               	sta z80_h
000652  3               
000652  3               	lda btop		; box top.
000652  3               	sta dispy		; set display coordinate.
000652  3               	lda #0			; start at object zero.
000652  3               	sta combyt		; store number of object in combyt.
000652  3               dbox2:
000652  3               	lda combyt		; get object number.
000652  3               	sta z80_a
000652  3               mod0:
000652  3               	jsr always		; check inventory for display.
000652  3               	cmp #255
000652  3               	beq :+
000652  3               	jmp dbox13		; not in inventory, skip this line.
000652  3               :
000652  3               	lda blft		; box left.
000652  3               	sta dispx		; set left display position.
000652  3               	lda bwid		; box width.
000652  3               	sta z80_b		; store width.
000652  3               dbox0:
000652  3               	ldy #0
000652  3               	lda (z80_hl),y		; get character.
000652  3               	cmp #','		; end of line?
000652  3               	beq dbox1		; yes, next one.
000652  3               	cmp #13			; end of line?
000652  3               	beq dbox1		; yes, next one.
000652  3               
000652  3               	cmp #141			; end of line?
000652  3               	bne :+
000652  3               	dec bwid
000652  3               	jmp dbox7		; yes, next one.
000652  3               :
000652  3               	dec z80_b		; one less to display.
000652  3               	and #127		; remove terminator.
000652  3               
000652  3               	jsr pchr		; display on screen.
000652  3               
000652  3               	ldy #0
000652  3               	lda (z80_hl),y		; get character.
000652  3               	sta z80_a
000652  3               	inc z80_l		; next character.
000652  3               	bne :+
000652  3               	inc z80_h
000652  3               :
000652  3               	lda z80_a
000652  3               	cmp #128		; end of message?
000652  3               	bmi :+
000652  3               	jmp dbox7		; yes, job done.
000652  3               :
000652  3               	lda z80_b		; chars remaining.
000652  3               	beq :+			; are any left?
000652  3               	jmp dbox0		; yes, continue.
000652  3               :
000652  3               ;---------------------------------------------------
000652  3               ; Reached limit of characters per line.
000652  3               ;---------------------------------------------------
000652  3               
000652  3               dbox9:
000652  3               	ldy #0
000652  3               	lda (z80_hl),y		; get character.
000652  3               	inc z80_l		; next one.
000652  3               	bne :+
000652  3               	inc z80_h
000652  3               :
000652  3               	cmp #','		; another line?
000652  3               	beq dbox10		; yes, do next line.
000652  3               	cmp #13			; another line?
000652  3               	beq dbox10		; yes, do next line.
000652  3               	cmp #128		; end of message?
000652  3               	bcs :+
000652  3               	jmp dbox11		; yes, finish message.
000652  3               :
000652  3               	jmp dbox9
000652  3               
000652  3               ;---------------------------------------------------
000652  3               ; Fill box to end of line.
000652  3               ;---------------------------------------------------
000652  3               
000652  3               dboxf:
000652  3               	lda #32			; space character.
000652  3               	jsr pchr		; display character.
000652  3               	dec z80_b
000652  3               	beq :+
000652  3               	jmp dboxf		; repeat for remaining chars on line.
000652  3               :
000652  3               	rts
000652  3               dbox1:
000652  3               	inc z80_l		; skip character.
000652  3               	bne :+
000652  3               	inc z80_h
000652  3               :
000652  3               	jsr dboxf		; fill box out to right side.
000652  3               dbox10:
000652  3               	inc dispy		; y coordinate down a line next position.
000652  3               	jmp dbox2		; next line.
000652  3               dbox7:
000652  3               	lda z80_b		; chars remaining.
000652  3               	bne :+			; are any left?
000652  3               	jmp dbox11		; no, nothing to draw.
000652  3               :
000652  3               	jsr dboxf		; fill message to line.
000652  3               
000652  3               ;------------------------------------------------------
000652  3               ; Drawn the box menu, now select option.
000652  3               ;------------------------------------------------------
000652  3               
000652  3               dbox11:
000652  3               	lda btop		; box top.
000652  3               	sta dispy		; set bar position.
000652  3               dbox14:
000652  3               	jsr joykey		; get controls.
000652  3               	cmp #$7f		; anything pressed?
000652  3               	bne dbox14		; yes, debounce it.
000652  3               	jsr dbar		; draw bar.
000652  3               dbox12:
000652  3               	jsr joykey		; get controls.
000652  3               	cmp #$7f		; anything pressed?
000652  3               	beq dbox12		; no, nothing.
000652  3               	and #16			; fire button pressed?
000652  3               	bne :+
000652  3               mod1:
000652  3               	jmp fstd		; yes, job done.
000652  3               :
000652  3               	jsr dbar		; delete bar.
000652  3               
000652  3               	lda joyval		; joystick reading.
000652  3               	and #8			; going up?
000652  3               	beq dboxu		; yes, go up.
000652  3               
000652  3               	ldx dispy		; vertical position of bar.
000652  3               	inx			; look down.
000652  3               	txa
000652  3               	sec
000652  3               	sbc btop		; find distance from top.
000652  3               	cmp blen		; top of box.
000652  3               	bne :+
000652  3               	jmp dbox14		; yes, go no further.
000652  3               :
000652  3               	inc dispy		; move bar.
000652  3               	jmp dbox14		; continue.
000652  3               dboxu:
000652  3               	lda dispy		; vertical position of bar.
000652  3               	cmp btop		; are we at the top?
000652  3               	bne :+
000652  3               	jmp dbox14		; yes, go no further.
000652  3               :
000652  3               	dec dispy		; move bar.
000652  3               	jmp dbox14		; continue.
000652  3               fstd:
000652  3               	lda dispy		; bar position.
000652  3               	sec
000652  3               	sbc btop		; find selected option.
000652  3               	sta varopt		; store the option.
000652  3               	jmp redraw		; redraw the screen.
000652  3               
000652  3               ;------------------------------------------------------
000652  3               ; Option not available.  Skip this line.
000652  3               ;------------------------------------------------------
000652  3               
000652  3               dbox13:
000652  3               	ldy #0
000652  3               	lda (z80_hl),y		; get character.
000652  3               	inc z80_l		; next one.
000652  3               	bne :+
000652  3               	inc z80_h
000652  3               :
000652  3               	cmp #','		; another line?
000652  3               	bne :+
000652  3               	jmp dbox2		; yes, do next line.
000652  3               :
000652  3               	cmp #13			; another line?
000652  3               	bne :+
000652  3               	jmp dbox2		; yes, do next line.
000652  3               :
000652  3               
000652  3               	bpl :+			; end of message?
000652  3               	jmp dbox11		; yes, finish message.
000652  3               :
000652  3               	jmp dbox13
000652  3               dbox15:
000652  3               	lda TmpAddr		; pop message pointer from the stack.
000652  3               	sta z80_h
000652  3               	lda TmpAddr+1
000652  3               	sta z80_l
000652  3               	rts
000652  3               
000652  3               ;------------------------------------------------------
000652  3               ; Invert bar
000652  3               ;------------------------------------------------------
000652  3               
000652  3               dbar:
000652  3               	lda blft		; box left.
000652  3               	sta dispx		; set display coordinate.
000652  3               	jsr gprad		; get printing address.
000652  3               
000652  3               	lda bwid		; box width.
000652  3               	sta z80_c		; loop counter in c.
000652  3               	lda z80_h
000652  3               	sta z80_d		; store screen address high byte.
000652  3               dbar1:
000652  3               	ldx #7			; pixel height in b.
000652  3               dbar0:
000652  3               	ldy scrtab,x
000652  3               	lda (scraddr),y		; get screen byte.
000652  3               	eor #255		; reverse all bits.
000652  3               	sta (scraddr),y		; write back to screen.
000652  3               	dex			; next line down.
000652  3               	bpl dbar0		; draw rest of character.
000652  3               
000652  3               	inc scraddr		; one char right.
000652  3               	dec z80_c		; decrement character counter.
000652  3               	bne dbar1		; repeat for whole line.
000652  3               	rts
000652  3               
000652  3               ;------------------------------------------------------
000652  3               ; Point to object
000652  3               ;
000652  3               ; Input:
000652  3               ;  combyt
000652  3               ;
000652  3               ; Output:
000652  3               ;  A = object number, A=255 if already in possession
000652  3               ;------------------------------------------------------
000652  3               
000652  3               invdis:
000652  3               	lda z80_l		; store message text pointer.
000652  3               	pha
000652  3               	lda z80_h
000652  3               	pha
000652  3               	lda combyt		; object number.
000652  3               	inc combyt		; ready for next one.
000652  3               	jsr gotob		; check if we have object.
000652  3               	tay
000652  3               	pla
000652  3               	sta z80_h
000652  3               	pla
000652  3               	sta z80_l
000652  3               	tya
000652  3               	rts
000652  3               
000652  3               ;------------------------------------------------------
000652  3               ; Find option selected.
000652  3               ;
000652  3               ; Input:
000652  3               ;  -
000652  3               ;
000652  3               ; Output:
000652  3               ;  OPT = selected object
000652  3               ;------------------------------------------------------
000652  3               
000652  3               fopt:
000652  3               	lda dispy
000652  3               	sec
000652  3               	sbc btop		; find selected option.
000652  3               	sta tmp+2		; option selected in b register.
000652  3               	inc tmp+2
000652  3               
000652  3               	lda #0			; set to first item.
000652  3               	sta combyt		; object number.
000652  3               fopt0:
000652  3               	jsr fobj		; find next object in inventory.
000652  3               	dec tmp+2
000652  3               	bne fopt0		; repeat for relevant steps down the list.
000652  3               
000652  3               	lda combyt		; get option.
000652  3               	sta varopt		; store the option.
000652  3               	dec varopt		; one less, due to where we increment combyt.
000652  3               	jmp redraw		; redraw the screen.
000652  3               fobj:
000652  3               	ldy combyt		; object number.
000652  3               	inc combyt		; ready for next item.
000652  3               	tya
000652  3               	jsr gotob		; do we have this item?
000652  3               	cmp #255
000652  3               	bne :+
000652  3               	rts
000652  3               :
000652  3               	jmp fobj		; yes, it's on the list.
000652  3               
000652  3               ;bwid:	.byte 0              ; box/menu width.
000652  3               ;blen:	.byte 0              ; box/menu height.
000652  3               ;btop:	.byte 0              ; box coordinates.
000652  3               ;blft:	.byte 0
000652  3               .endif
000652  3               
000652  3               ;----------------------------------------------------
000652  3               ; Wait for keypress.
000652  3               ;----------------------------------------------------
000652  3               
000652  3               prskey:
000652  3  98           	tya
000653  3  48           	pha
000654  3               prsloop:
000654  3  20 86 06     	jsr vsync
000657  3  20 71 FE     	jsr READKEY
00065A  3  C0 FF        	cpy #255
00065C  3  F0 F6        	beq prsloop		; wait until key pressed
00065E  3  20 DB 0F     	jsr joykey
000661  3  68           	pla
000662  3  A8           	tay
000663  3  60           	rts
000664  3               
000664  3               ;----------------------------------------------------
000664  3               ; Delay routine 1/50 sec
000664  3               ;
000664  3               ; Wait 1/60 sec = 16666 usec
000664  3               ; Wait 208 x 16 =  3328 usec
000664  3               ;                 19994 usec
000664  3               ; rts           =     6 usec
000664  3               ; Total         = 20000 usec
000664  3               ;----------------------------------------------------
000664  3               
000664  3               delay:
000664  3  85 rr        	sta xtmp
000666  3               del_loop:
000666  3  20 66 FE     	jsr SCRSYNC		; wait for flyback
000669  3               
000669  3  A0 D0        	ldy #208		; wait 208 x 16 = 3328 usec
00066B  3               delay1:
00066B  3  61 80        	adc ($80,x)		;	 6 usec
00066D  3  61 80        	adc ($80,x)		;	 6 usec
00066F  3  88           	dey			;	 2 usec
000670  3  D0 F9        	bne delay1		;	 2 usec
000672  3  EA           	nop			; 2 usec
000673  3  EA           	nop			; 2 usec
000674  3               				; tot: 20000 usec
000674  3  C6 rr        	dec xtmp
000676  3  D0 EE        	bne del_loop
000678  3  60           	rts
000679  3               
000679  3               ;----------------------------------------------------
000679  3               ; Clear sprite table.
000679  3               ;
000679  3               ; sprtab[0] - sprtab[SPRBUF-1] = 255
000679  3               ;----------------------------------------------------
000679  3               
000679  3               xspr:
000679  3  A9 FF        	lda #255		; clear byte.
00067B  3  A2 00        	ldx #0			; length of table.
00067D  3               xspr0:
00067D  3  9D 33 19     	sta sprtab,x		; sprite table.
000680  3  E8           	inx			; move to next byte.
000681  3  E0 CC        	cpx #SPRBUF
000683  3  D0 F8        	bne xspr0		; repeat for rest of table.
000685  3  60           	rts
000686  3               
000686  3               ;-------------------------------------------------------------
000686  3               ; Initialise all objects.
000686  3               ;
000686  3               ; Reset current room,y,x to start room,y,x for all objects
000686  3               ;-------------------------------------------------------------
000686  3               
000686  3               .if oflag
000686  3               iniob:
000686  3               	lda #<objdta 		; objects table.
000686  3               	sta z80_x
000686  3               	lda #>objdta
000686  3               	sta z80_i
000686  3               
000686  3               	ldx numob 		; number of objects in the game.
000686  3               iniob0:
000686  3               	ldy #35
000686  3               	lda (z80_ix),y 		; start screen.
000686  3               	ldy #32
000686  3               	sta (z80_ix),y 		; set start screen.
000686  3               
000686  3               	ldy #36
000686  3               	lda (z80_ix),y 		; find start y.
000686  3               	ldy #33
000686  3               	sta (z80_ix),y 		; set start y.
000686  3               
000686  3               	ldy #37
000686  3               	lda (z80_ix),y 		; get initial x.
000686  3               	ldy #34
000686  3               	sta (z80_ix),y 		; set x coord.
000686  3               
000686  3               	clc 			; point to next object.
000686  3               	lda z80_x
000686  3               	adc #38			; distance between objects.
000686  3               	sta z80_x
000686  3               	bcc :+
000686  3               	inc z80_i
000686  3               :
000686  3               	dex 			; repeat.
000686  3               	bne iniob0
000686  3               
000686  3               	rts
000686  3               .endif
000686  3               
000686  3               ;-------------------------------------------------------------
000686  3               ; Screen synchronisation.
000686  3               ;
000686  3               ;  - read joystick/keyboard
000686  3               ;  - handle sound
000686  3               ;  - sync framerate with clock
000686  3               ;  - handle shrapnel every even frame
000686  3               ;-------------------------------------------------------------
000686  3               
000686  3               vsync:
000686  3  48           	pha
000687  3  98           	tya
000688  3  48           	pha
000689  3  8A           	txa
00068A  3  48           	pha
00068B  3  20 DB 0F     	jsr joykey		; read joystick/keyboard.
00068E  3               vsync1:
00068E  3  AD 09 B8     	lda Timer2_High		; sync framerate with clock
000691  3  C9 FF        	cmp #$ff
000693  3  D0 F9        	bne vsync1
000695  3  A9 C3        	lda #>50000
000697  3  8D 09 B8     	sta Timer2_High
00069A  3  A9 50        	lda #<50000
00069C  3  8D 08 B8     	sta Timer2_Low
00069F  3               
00069F  3  A5 rr        	lda clock
0006A1  3  29 01        	and #1
0006A3  3  D0 03        	bne:+
0006A5  3  20 21 07     	jsr proshr		; handle shrapnel every even frame
0006A8  3               :
0006A8  3  AD C6 06     	lda sndtyp
0006AB  3  F0 13        	beq sndskip
0006AD  3               sndloop:
0006AD  3  AD 02 B0     	lda SpeakerBit		; handle sound
0006B0  3  AC C6 06     	ldy sndtyp
0006B3  3               sndwait:
0006B3  3  88           	dey
0006B4  3  D0 FD        	bne sndwait
0006B6  3  49 04        	eor #4
0006B8  3  8D 02 B0     	sta SpeakerBit
0006BB  3  CE C6 06     	dec sndtyp
0006BE  3  D0 ED        	bne sndloop
0006C0  3               sndskip:
0006C0  3  68           	pla
0006C1  3  AA           	tax
0006C2  3  68           	pla
0006C3  3  A8           	tay
0006C4  3  68           	pla
0006C5  3  60           	rts
0006C6  3               
0006C6  3  00           sndtyp:	.byte 0
0006C7  3               
0006C7  3               ;-----------------------------------------------
0006C7  3               ; Redraw the screen.
0006C7  3               ;
0006C7  3               ; Remove old copy of all sprites for redraw.
0006C7  3               ;-----------------------------------------------
0006C7  3               
0006C7  3               redraw:
0006C7  3  A5 69        	lda z80_i 		; place sprite pointer on stack.
0006C9  3  48           	pha
0006CA  3  A5 68        	lda z80_x
0006CC  3  48           	pha
0006CD  3               
0006CD  3  20 3D 0C     	jsr droom		; show screen layout.
0006D0  3               .if oflag
0006D0  3               	jsr shwob		; draw objects.
0006D0  3               .endif
0006D0  3               numsp0:
0006D0  3  A9 0C        	lda #NUMSPR		; sprites to draw.
0006D2  3  85 rr        	sta tmp
0006D4  3               
0006D4  3  A9 33        	lda #<sprtab		; sprite table.
0006D6  3  85 68        	sta z80_x
0006D8  3  A9 19        	lda #>sprtab
0006DA  3  85 69        	sta z80_i
0006DC  3               redrw0:
0006DC  3  A0 00        	ldy #0
0006DE  3  B1 68        	lda (z80_ix),y		; old sprite type.
0006E0  3  C9 FF        	cmp #255		; is it enabled?
0006E2  3  F0 0B        	beq redrw1 		; no, find next one.
0006E4  3               
0006E4  3  A0 03        	ldy #3
0006E6  3  B1 68        	lda (z80_ix),y 		; sprite y.
0006E8  3  C9 B1        	cmp #177		; beyond maximum?
0006EA  3  B0 03        	bcs redrw1		; yes, nothing to draw.
0006EC  3               
0006EC  3  20 FC 13     	jsr sspria		; show single sprite.
0006EF  3               redrw1:
0006EF  3  18           	clc			; next sprite.
0006F0  3  A5 68        	lda z80_x
0006F2  3  69 11        	adc #TABSIZ		; distance to next odd/even entry.
0006F4  3  85 68        	sta z80_x
0006F6  3  90 02        	bcc :+
0006F8  3  E6 69        	inc z80_i
0006FA  3               :
0006FA  3  C6 rr        	dec tmp			; repeat for remaining sprites.
0006FC  3  D0 DE        	bne redrw0
0006FE  3               rpblc1:
0006FE  3               ;	jsr dshrp		; redraw shrapnel.
0006FE  3               
0006FE  3               .if aflag
0006FE  3               	jsr rbloc		; draw blocks for this screen
0006FE  3               .endif
0006FE  3  68           	pla			; retrieve sprite pointer.
0006FF  3  85 68        	sta z80_x
000701  3  68           	pla
000702  3  85 69        	sta z80_i
000704  3               
000704  3  60           	rts
000705  3               
000705  3               ;----------------------------------------------------------------------
000705  3               ; Clear screen routine.
000705  3               ;
000705  3               ; Fill screenmem $8000-$97ff with ScrFillByte
000705  3               ;----------------------------------------------------------------------
000705  3               
000705  3               cls:
000705  3  A9 80        	lda #>ScreenAddr		; screen address.
000707  3  8D 11 07     	sta clsloop+2
00070A  3  AD 36 1A     	lda andeor+1
00070D  3               .if iflag
00070D  3               	eor #$ff
00070D  3               .endif
00070D  3  A0 00        	ldy #0
00070F  3               clsloop:
00070F  3  99 00 80     	sta ScreenAddr,y
000712  3  C8           	iny
000713  3  D0 FA        	bne clsloop
000715  3  EE 11 07     	inc clsloop+2
000718  3  AE 11 07     	ldx clsloop+2
00071B  3  E0 98        	cpx #>(ScreenAddr+$1800)
00071D  3  D0 F0        	bne clsloop
00071F  3  60           	rts
000720  3               
000720  3               ;----------------------------------------------------------------------
000720  3               ; Atomic palette is static
000720  3               ;----------------------------------------------------------------------
000720  3               
000720  3               setpal:
000720  3  60           	rts
000721  3               
000721  3               ;----------------------------------------------------------------------
000721  3               ; FODDER check
000721  3               ;----------------------------------------------------------------------
000721  3               
000721  3               .if pflag .or dflag
000721  3               fdchk:
000721  3               	cmp #FODDER 		; is it fodder?
000721  3               	beq :+
000721  3               	rts 			; no.
000721  3               :
000721  3               	lda #0			; wipe fodder in MAP
000721  3               	ldy #0
000721  3               	sta (bufaddr),y 	; rewrite block type.
000721  3               
000721  3               	lda dispx		; x=x/8
000721  3               	pha
000721  3               	lsr a
000721  3               	lsr a
000721  3               	lsr a
000721  3               	sta dispx
000721  3               
000721  3               	lda dispy		; y=y/8
000721  3               	pha
000721  3               	lsr a
000721  3               	lsr a
000721  3               	lsr a
000721  3               	sta dispy
000721  3               
000721  3               	lda #0 			; block to write.
000721  3               	jsr pattr 		; write block.
000721  3               
000721  3               	pla
000721  3               	sta dispy
000721  3               	pla
000721  3               	sta dispx
000721  3               	rts
000721  3               .endif
000721  3               
000721  3               ;----------------------------------------------------
000721  3               ; Scrolly text and puzzle variables.
000721  3               ;----------------------------------------------------
000721  3               
000721  3               .if sflag
000721  3               txtbit:	.byte 128		; bit to write.
000721  3               txtwid:	.byte 16		; width of ticker message.
000721  3               txtpos:	.word msgdat
000721  3               txtini:	.word msgdat
000721  3               txtscr:	.word ScreenAddr
000721  3               .endif
000721  3               
000721  3               ;----------------------------------------------------
000721  3               ; Specialist routines.
000721  3               ; Process shrapnel.
000721  3               ;----------------------------------------------------
000721  3               proshr:
000721  3               .if pflag
000721  3               	lda #<SHRAPN		; table.
000721  3               	sta z80_x
000721  3               	lda #>SHRAPN
000721  3               	sta z80_i
000721  3               
000721  3               	lda #NUMSHR		; shrapnel pieces to process.
000721  3               	sta shrctr
000721  3               prosh0:
000721  3               	ldy #0
000721  3               	lda (z80_ix),y		; on/off marker.
000721  3               	asl a
000721  3               proshx:
000721  3               	bcs :+
000721  3               	jsr prosh1 		; on, so process it.
000721  3               :
000721  3               	clc
000721  3               	lda z80_x
000721  3               	adc #SHRSIZ
000721  3               	sta z80_x
000721  3               	bcc :+
000721  3               	inc z80_i
000721  3               :
000721  3               	dec shrctr		; round again.
000721  3               	bne prosh0
000721  3               .endif
000721  3               .if sflag
000721  3               	jsr scrly
000721  3               .endif
000721  3  60           	rts
000722  3               
000722  3               .if pflag
000722  3               ;shrctr:	.byte 0
000722  3               
000722  3               ;----------------------------------------------------
000722  3               ; Proces shrapnel piece
000722  3               ;----------------------------------------------------
000722  3               
000722  3               prosh1:
000722  3               	jsr plot 		; delete the pixel.
000722  3               
000722  3               	lda #<shrptr		; shrapnel routine pointers.
000722  3               	sta z80_l
000722  3               	lda #>shrptr
000722  3               	sta z80_h
000722  3               
000722  3               	ldy #0
000722  3               	lda (z80_ix),y		; restore shrapnel type.
000722  3               	jsr prosh2 		; run the routine.
000722  3               	jsr chkxy		; check x and y are good before we redisplay.
000722  3               
000722  3               	lda #<SHRSIZ 		; distance to next.
000722  3               	sta z80_e
000722  3               	lda #>SHRSIZ
000722  3               	sta z80_d
000722  3               	rts
000722  3               
000722  3               ;----------------------------------------------------
000722  3               ; Run the routine
000722  3               ;----------------------------------------------------
000722  3               
000722  3               prosh2:
000722  3               	asl a 			; 2 bytes per address.
000722  3               	tay
000722  3               	lda shrptr,y
000722  3               	sta z80_l
000722  3               	lda shrptr+1,y 		; fetch high byte from table.
000722  3               	sta z80_h
000722  3               	jmp (z80_hl) 		; jump to routine.
000722  3               
000722  3               ;----------------------------------------------------
000722  3               ; Paricle routine table
000722  3               ;----------------------------------------------------
000722  3               
000722  3               shrptr:	.word laser		; laser.
000722  3               	.word trail		; vapour trail.
000722  3               	.word shrap		; shrapnel from explosion.
000722  3               	.word dotl		; horizontal starfield left.
000722  3               	.word dotr		; horizontal starfield right.
000722  3               	.word dotu		; vertical starfield up.
000722  3               	.word dotd		; vertical starfield down.
000722  3               	.word ptcusr		; user particle.
000722  3               
000722  3               ;----------------------------------------------------
000722  3               ; Explosion shrapnel.
000722  3               ;----------------------------------------------------
000722  3               
000722  3               shrap:
000722  3               	ldy #1
000722  3               	lda (z80_ix),y 		; get the angle.
000722  3               	clc
000722  3               	adc #<shrsin		; shrapnel sine table.
000722  3               	sta z80_l
000722  3               	lda #>shrsin
000722  3               	adc #0
000722  3               	sta z80_h
000722  3               
000722  3               	ldy #0
000722  3               	lda (z80_hl),y 		; fetch value from table.
000722  3               	sta z80_e
000722  3               	inc z80_l 		; next byte of table.
000722  3               	bne :+
000722  3               	inc z80_h
000722  3               :
000722  3               	ldy #0
000722  3               	lda (z80_hl),y		; fetch value from table.
000722  3               	sta z80_d
000722  3               	inc z80_l		; next byte of table.
000722  3               	bne :+
000722  3               	inc z80_h
000722  3               :
000722  3               	ldy #0
000722  3               	lda (z80_hl),y 		; fetch value from table.
000722  3               	sta z80_c
000722  3               	inc z80_l 		; next byte of table.
000722  3               	bne :+
000722  3               	inc z80_h
000722  3               :
000722  3               	ldy #0
000722  3               	lda (z80_hl),y 		; fetch value from table.
000722  3               	sta z80_b
000722  3               
000722  3               	ldy #2
000722  3               	lda (z80_ix),y 		; x coordinate in hl.
000722  3               	clc
000722  3               	adc z80_e		; add sine lb
000722  3               	sta (z80_ix),y		; store new coordinate lb.
000722  3               	ldy #3
000722  3               	lda (z80_ix),y
000722  3               	adc z80_d		; add sine hb
000722  3               	sta (z80_ix),y		; store new coordinate hb.
000722  3               
000722  3               	ldy #4
000722  3               	lda (z80_ix),y	 	; y coordinate in hl.
000722  3               	clc
000722  3               	adc z80_c		; add cosine lb
000722  3               	sta (z80_ix),y		; store new coordinate lb.
000722  3               	ldy #5
000722  3               	lda (z80_ix),y
000722  3               	adc z80_b		; add cosine lb
000722  3               	sta (z80_ix),y		; store new coordinate hb.
000722  3               
000722  3               	rts
000722  3               
000722  3               ;----------------------------------------------------
000722  3               ; Move dots
000722  3               ;----------------------------------------------------
000722  3               
000722  3               dotl:
000722  3               	ldy #5
000722  3               	lda (z80_ix),y
000722  3               	sec
000722  3               	sbc #1		 	; move left.
000722  3               	sta (z80_ix),y
000722  3               	rts
000722  3               dotr:
000722  3               	ldy #5
000722  3               	lda (z80_ix),y
000722  3               	clc
000722  3               	adc #1		 	; move left.
000722  3               	sta (z80_ix),y
000722  3               	rts
000722  3               dotu:
000722  3               	ldy #3
000722  3               	lda (z80_ix),y
000722  3               	sec
000722  3               	sbc #1		 	; move up.
000722  3               	sta (z80_ix),y
000722  3               	rts
000722  3               dotd:
000722  3               	ldy #3
000722  3               	lda (z80_ix),y
000722  3               	clc
000722  3               	adc #1			; move down.
000722  3               	sta (z80_ix),y
000722  3               	rts
000722  3               
000722  3               ;----------------------------------------------------
000722  3               ; Check if coordinates are ok before redrawing at new position.
000722  3               ;
000722  3               ; left:   X>L		X=L	Ok
000722  3               ; right:  R+15>X	X=R	Ok
000722  3               ; top:    Y>T		Y=T	Ok
000722  3               ; bottom: B+15>Y	Y=B	Ok
000722  3               ;----------------------------------------------------
000722  3               
000722  3               chkxy:
000722  3               
000722  3               ; top:    Y>T		Y=T	Ok
000722  3               
000722  3               	ldy #3
000722  3               	lda (z80_ix),y	 	; fetch shrapnel coordinate.
000722  3               	cmp wntopx		; window top.
000722  3               	bcs :+			; compare with top window limit.
000722  3               	jmp kilshr		; out of window, kill shrapnel.
000722  3               :
000722  3               ; left:   X>L		X=L	Ok
000722  3               
000722  3               	ldy #5
000722  3               	lda (z80_ix),y	 	; fetch shrapnel coordinate.
000722  3               	cmp wnlftx		; left edge.
000722  3               	bcs :+			; compare with left window limit.
000722  3               	jmp kilshr		; out of window, kill shrapnel.
000722  3               :
000722  3               ; bottom: B+15>Y	Y=B	Ok
000722  3               
000722  3               	lda wnbotx		; point to bottom.
000722  3               	clc
000722  3               	adc #15
000722  3               	ldy #3
000722  3               	cmp (z80_ix),y	 	; fetch shrapnel coordinate.
000722  3               	bcs :+			; compare with shrapnel x coordinate.
000722  3               	jmp kilshr		; off screen, kill shrapnel..
000722  3               :
000722  3               ; right:  R+15>X	X=R	Ok
000722  3               
000722  3               	lda wnrgtx		; point to right edge.
000722  3               	clc
000722  3               	adc #15
000722  3               	ldy #5
000722  3               	cmp (z80_ix),y	 	; fetch shrapnel coordinate.
000722  3               	bcs :+			; compare with window limit.
000722  3               	jmp kilshr		; off screen, kill shrapnel.
000722  3               :
000722  3               
000722  3               ;----------------------------------------------------
000722  3               ; Drop through.
000722  3               ; Display shrapnel.
000722  3               ;----------------------------------------------------
000722  3               
000722  3               plot:
000722  3               	ldy #3
000722  3               	lda (z80_ix),y		; y integer.
000722  3               	sta dispy	 	; workspace coordinates.
000722  3               	ldy #5
000722  3               	lda (z80_ix),y	 	; x integer.
000722  3               	sta dispx 		; workspace coordinates.
000722  3               
000722  3               	ldy #0
000722  3               	lda (z80_ix),y 		; type.
000722  3               	bne :+			; is it a laser?
000722  3               	jmp plot1 		; yes, draw laser instead.
000722  3               :
000722  3               plot0:
000722  3               	lda dispx		; which pixel within byte do we
000722  3               	and #7			; want to set first?
000722  3               	tay
000722  3               	lda dots,y 		; table of small pixel positions.
000722  3               	sta z80_e 		; get value.
000722  3               
000722  3               	jsr scadd 		; screen address.
000722  3               	ldy #0
000722  3               	lda (scraddr),y		; see what's already there.
000722  3               	eor z80_e
000722  3               	sta (scraddr),y 	; put back on screen.
000722  3               	rts
000722  3               
000722  3               plot1:
000722  3               	jsr scadd 		; screen address.
000722  3               	ldy #0
000722  3               	lda (scraddr),y 	; fetch byte there.
000722  3               	eor #255 		; toggle all bits.
000722  3               	sta (scraddr),y 	; new byte.
000722  3               	rts
000722  3               
000722  3               ;----------------------------------------------------
000722  3               ; Switch off shrapnel
000722  3               ;----------------------------------------------------
000722  3               
000722  3               kilshr:
000722  3               	lda #128
000722  3               	ldy #0
000722  3               	sta (z80_ix),y	; switch off shrapnel.
000722  3               	rts
000722  3               
000722  3               ;----------------------------------------------------
000722  3               ; Sine/cosine table
000722  3               ;----------------------------------------------------
000722  3               
000722  3               shrsin:	.word 0,1024,391,946,724,724,946,391
000722  3               	.word 1024,0,946,65144,724,64811,391,64589
000722  3               	.word 0,64512,65144,64589,64811,64811,64589,65144
000722  3               	.word 64512,0,64589,391,64811,724,65144,946
000722  3               
000722  3               ;----------------------------------------------------
000722  3               ; Create trail
000722  3               ;----------------------------------------------------
000722  3               
000722  3               trail:
000722  3               	ldy #1
000722  3               	lda (z80_ix),y 	; time remaining.
000722  3               	sec
000722  3               	sbc #1
000722  3               	sta (z80_ix),y
000722  3               	bne :+
000722  3               	jmp trailk		; time to switch it off.
000722  3               :
000722  3               	jsr qrand		; get a random number.
000722  3               	lsr a 			; x or y axis?
000722  3               	bcc :+
000722  3               	jmp trailv		; use y.
000722  3               :
000722  3               ; Trail horizontal
000722  3               
000722  3               	lsr a 			; which direction?
000722  3               	bcc :+
000722  3               	jmp traill		; go left.
000722  3               :
000722  3               ; Trail right
000722  3               
000722  3               	ldy #5
000722  3               	lda (z80_ix),y
000722  3               	clc
000722  3               	adc #1	 		; go right.
000722  3               	sta (z80_ix),y
000722  3               	rts
000722  3               
000722  3               ; Trail left
000722  3               
000722  3               traill:
000722  3               	ldy #5
000722  3               	lda (z80_ix),y
000722  3               	sec
000722  3               	sbc #1 			; go left.
000722  3               	sta (z80_ix),y
000722  3               	rts
000722  3               
000722  3               ; Trail vertical
000722  3               
000722  3               trailv:
000722  3               	lsr a		 	; which direction?
000722  3               	bcc :+
000722  3               	jmp trailu		; go up.
000722  3               :
000722  3               ; Trail down
000722  3               
000722  3               	ldy #3
000722  3               	lda (z80_ix),y
000722  3               	clc
000722  3               	adc #1 			; go down.
000722  3               	sta (z80_ix),y
000722  3               	rts
000722  3               
000722  3               ; Trail up
000722  3               
000722  3               trailu:
000722  3               	ldy #3
000722  3               	lda (z80_ix),y
000722  3               	sec
000722  3               	sbc #1 			; go up.
000722  3               	sta (z80_ix),y
000722  3               	rts
000722  3               
000722  3               ; Kill trail
000722  3               
000722  3               trailk:
000722  3               	lda #200		; set off-screen to kill vapour trail.
000722  3               	ldy #3
000722  3               	sta (z80_ix),y
000722  3               	rts
000722  3               
000722  3               ;----------------------------------------------------
000722  3               ; Create laser beam
000722  3               ;----------------------------------------------------
000722  3               
000722  3               laser:
000722  3               	ldy #1
000722  3               	lda (z80_ix),y 		; direction.
000722  3               	ror a 			; left or right?
000722  3               	bcs :+
000722  3               	jmp laserl		; move left.
000722  3               :
000722  3               ; Laser right
000722  3               
000722  3               	lda #8			; distance to travel.
000722  3               	sta z80_b
000722  3               	jmp laserm		; move laser.
000722  3               
000722  3               ; Laser left
000722  3               
000722  3               laserl:
000722  3               	lda #248		; distance to travel.
000722  3               	sta z80_b
000722  3               laserm:
000722  3               	ldy #5
000722  3               	lda (z80_ix),y		; x position.
000722  3               	clc
000722  3               	adc z80_b		; add distance.
000722  3               	sta (z80_ix),y		; set new x coordinate.
000722  3               
000722  3               ; Test new block.
000722  3               
000722  3               	sta dispx 		; set x for block collision detection purposes.
000722  3               	ldy #3
000722  3               	lda (z80_ix),y 		; get y.
000722  3               	sta dispy		; set coordinate for collision test.
000722  3               	jsr tstbl 		; get block type there.
000722  3               	cmp #WALL		; is it solid?
000722  3               	bne :+
000722  3               	jmp trailk		; yes, it cannot pass.
000722  3               :
000722  3               .if pflag .or dflag
000722  3                       cmp #FODDER             ; is it fodder?
000722  3                       bne :+
000722  3                       jsr fdchk               ; remove fodder block.
000722  3                       jmp trailk              ; destroy laser.
000722  3               :
000722  3               .endif
000722  3                       rts                     ; no, ignore it.
000722  3               
000722  3               ;----------------------------------------------------
000722  3               ; Dots mask
000722  3               ;----------------------------------------------------
000722  3               
000722  3               dots:	.byte 128,64,32,16,8,4,2,1
000722  3               
000722  3               
000722  3               ;----------------------------------------------------
000722  3               ; Plot, preserving de.
000722  3               ;----------------------------------------------------
000722  3               
000722  3               plotde:
000722  3               	lda z80_d 		; put de on stack.
000722  3               	pha
000722  3               	lda z80_e
000722  3               	pha
000722  3               
000722  3               	jsr plot 		; plot pixel.
000722  3               
000722  3               	pla			; restore de from stack.
000722  3               	sta z80_e
000722  3               	pla
000722  3               	sta z80_d
000722  3               
000722  3               	rts
000722  3               
000722  3               ;----------------------------------------------------
000722  3               ; Shoot a laser.
000722  3               ;----------------------------------------------------
000722  3               
000722  3               shoot:
000722  3               	sta z80_c		; store direction in c register.
000722  3               	ldy #8
000722  3               	lda (z80_ix),y 		; y coordinate.
000722  3               	clc
000722  3               shoot1:
000722  3               	adc #(SPR_HGT/2-1)	; down 7 pixels.
000722  3               	sta z80_l 		; puty y coordinate in l.
000722  3               
000722  3               	ldy #9
000722  3               	lda (z80_ix),y 		; x coordinate in h.
000722  3               	sta z80_h
000722  3               
000722  3               	lda z80_i		; store pointer to sprite.
000722  3               	pha
000722  3               	lda z80_x
000722  3               	pha
000722  3               
000722  3               	jsr fpslot 		; find particle slot.
000722  3               	bcs :+
000722  3               	jmp vapou2		; failed, restore ix.
000722  3               :
000722  3               	lda #0
000722  3               	ldy #0
000722  3               	sta (z80_ix),y 		; set up a laser.
000722  3               
000722  3               	lda z80_c
000722  3               	ldy #1
000722  3               	sta (z80_ix),y 		; set the direction.
000722  3               
000722  3               	lda z80_l
000722  3               	ldy #3
000722  3               	sta (z80_ix),y		; set y coordinate.
000722  3               
000722  3               	ror z80_c		; check direction we want.
000722  3               	bcc :+
000722  3               	jmp shootr		; shoot right.
000722  3               :
000722  3               	lda z80_h		; X position.
000722  3               shoot0:
000722  3               	and #248		; align on character boundary.
000722  3               	ldy #5
000722  3               	sta (z80_ix),y		; set x coordinate.
000722  3               	jmp vapou0 		; draw first image.
000722  3               shootr:
000722  3               	lda z80_h		; x position.
000722  3               	clc
000722  3               	adc #15			; look right.
000722  3               	jmp shoot0		; align and continue.
000722  3               
000722  3               ;----------------------------------------------------
000722  3               ; Create a bit of vapour trail.
000722  3               ;----------------------------------------------------
000722  3               
000722  3               vapour:
000722  3               	lda z80_i		; store pointer to sprite.
000722  3               	pha
000722  3               	lda z80_x
000722  3               	pha
000722  3               
000722  3               	ldy #8
000722  3               	lda (z80_ix),y 		; y coordinate.
000722  3               	clc
000722  3               vapou3:
000722  3               	adc #(SPR_HGT/2-1)	; mid-point of sprite.
000722  3               	sta z80_l
000722  3               
000722  3               	ldy #9
000722  3               	lda (z80_ix),y 		; x coordinate.
000722  3               	adc #7
000722  3               	sta z80_h
000722  3               
000722  3               	jsr fpslot 		; find particle slot.
000722  3               	bcc :+
000722  3               	jmp vapou1		; no, we can use it.
000722  3               :
000722  3               vapou2:
000722  3               	pla
000722  3               	sta z80_x
000722  3               	pla
000722  3               	sta z80_i
000722  3               	rts
000722  3               vapou1:
000722  3               	lda z80_l
000722  3               	ldy #3
000722  3               	sta (z80_ix),y		; set up y.
000722  3               
000722  3               	lda z80_h
000722  3               	ldy #5
000722  3               	sta (z80_ix),y 		; set up x coordinate.
000722  3               
000722  3               	jsr qrand		; get quick random number.
000722  3               	and #15			; random time.
000722  3               	clc
000722  3               	adc #15			; minimum time on screen.
000722  3               	ldy #1
000722  3               	sta (z80_ix),y		; set time on screen.
000722  3               
000722  3               	lda #1
000722  3               	ldy #0
000722  3               	sta (z80_ix),y		; define particle as vapour trail.
000722  3               vapou0:
000722  3               	jsr chkxy		; plot first position.
000722  3               	jmp vapou2
000722  3               
000722  3               ;----------------------------------------------------
000722  3               ; Create a user particle.
000722  3               ;----------------------------------------------------
000722  3               
000722  3               ptusr:
000722  3               	sta z80_f		; store timer.
000722  3               
000722  3               	ldy #8
000722  3               	lda (z80_ix),y 		; y coordinate.
000722  3               	clc
000722  3               	adc #7			; mid-point of sprite.
000722  3               	sta z80_l
000722  3               
000722  3               	ldy #9
000722  3               	lda (z80_ix),y 		; x coordinate.
000722  3               	clc
000722  3               	adc #7			; mid-point of sprite.
000722  3               	sta z80_h
000722  3               
000722  3               	jsr fpslot 		; find particle slot.
000722  3               	bcs ptusr1
000722  3               	rts 			; out of slots, can't generate anything.
000722  3               ptusr1:
000722  3               	lda z80_l
000722  3               	ldy #3
000722  3               	sta (z80_ix),y 		; set up y.
000722  3               
000722  3               	lda z80_h
000722  3               	ldy #5
000722  3               	sta (z80_ix),y		; set up x coordinate.
000722  3               
000722  3               	lda z80_f 		; restore timer.
000722  3               	ldy #1
000722  3               	sta (z80_ix),y		; set time on screen.
000722  3               
000722  3               	lda #7
000722  3               	ldy #0
000722  3               	sta (z80_ix),y		; define particle as user particle.
000722  3               
000722  3               	jmp chkxy		; plot first position.
000722  3               
000722  3               ;----------------------------------------------------
000722  3               ; Create a vertical or horizontal star.
000722  3               ;----------------------------------------------------
000722  3               
000722  3               star:
000722  3               	lda z80_i		; store pointer to sprite.
000722  3               	pha
000722  3               	lda z80_x
000722  3               	pha
000722  3               
000722  3               	jsr fpslot 		; find particle slot.
000722  3               	bcs star7		; found one we can use.
000722  3               star0:
000722  3               	pla 			; restore sprite pointer.
000722  3               	sta z80_x
000722  3               	pla
000722  3               	sta z80_i
000722  3               	rts 			; out of slots, can't generate anything.
000722  3               star7:
000722  3               	lda z80_c		; direction.
000722  3               	and #3 			; is it left?
000722  3               	bne :+
000722  3               	jmp star1 		; yes, it's left.
000722  3               :
000722  3               	cmp #1 			; is it right?
000722  3               	bne :+
000722  3               	jmp star2 		; yes, it's right.
000722  3               :
000722  3               	cmp #2 			; is it up?
000722  3               	bne :+
000722  3               	jmp star3 		; yes, it's up.
000722  3               :
000722  3               	ldy wntopx 		; get edge of screen.
000722  3               	iny			; down one pixel.
000722  3               	tya
000722  3               star8:
000722  3               	ldy #3
000722  3               	sta (z80_ix),y 		; set y coord.
000722  3               	jsr qrand 		; get quick random number.
000722  3               star9:
000722  3               	ldy #5
000722  3               	sta (z80_ix),y		; set x position.
000722  3               
000722  3               	lda z80_c		; direction.
000722  3               	and #3			; zero to three.
000722  3               	clc
000722  3               	adc #3			; 3 to 6 for starfield.
000722  3               	ldy #0
000722  3               	sta (z80_ix),y		; define particle as star.
000722  3               	jsr chkxy		; plot first position.
000722  3               	jmp star0
000722  3               star1:
000722  3               	jsr qrand		; get quick random number.
000722  3               	ldy #3
000722  3               	sta (z80_ix),y 		; set y coord.
000722  3               
000722  3               	lda wnrgtx 		; get edge of screen.
000722  3               	clc
000722  3               	adc #15			; add width of sprite minus 1.
000722  3               	jmp star9
000722  3               star2:
000722  3               	jsr qrand 		; get quick random number.
000722  3               	ldy #3
000722  3               	sta (z80_ix),y		; set y coord.
000722  3               
000722  3               	lda wnlftx		; get edge of screen.
000722  3               	jmp star9
000722  3               star3:
000722  3               	lda wnbotx 		; get edge of screen.
000722  3               	clc
000722  3               	adc #15 		; height of sprite minus one pixel.
000722  3               	jmp star8
000722  3               
000722  3               ;----------------------------------------------------
000722  3               ; Find particle slot for lasers or vapour trail.
000722  3               ; can't use alternate accumulator.
000722  3               ;----------------------------------------------------
000722  3               
000722  3               fpslot:
000722  3               	lda #<SHRAPN 		; shrapnel table.
000722  3               	sta z80_x
000722  3               	lda #>SHRAPN
000722  3               	sta z80_i
000722  3               
000722  3               	lda #NUMSHR		; number of pieces in table.
000722  3               	sta z80_b
000722  3               fpslt0:
000722  3               	ldy #0
000722  3               	lda (z80_ix),y		; get type.
000722  3               	asl a  			; is this slot in use?
000722  3               	bcc :+
000722  3               	rts			; no, we can use it.
000722  3               :
000722  3               	clc			; point to more shrapnel.
000722  3               	lda z80_x
000722  3               	adc #SHRSIZ
000722  3               	sta z80_x
000722  3               	bcc :+
000722  3               	inc z80_i
000722  3               :
000722  3               	dec z80_b		; repeat for all shrapnel.
000722  3               	bne fpslt0
000722  3               
000722  3               	clc
000722  3               	rts 			; out of slots, can't generate anything.
000722  3               
000722  3               ;----------------------------------------------------
000722  3               ; Create an explosion at sprite position.
000722  3               ;----------------------------------------------------
000722  3               
000722  3               explod:
000722  3               	sta z80_c 		; particles to create.
000722  3               
000722  3               	lda z80_i 		; store pointer to sprite.
000722  3               	pha
000722  3               	lda z80_x
000722  3               	pha
000722  3               
000722  3               	ldy #8
000722  3               	lda (z80_ix),y 		; y coordinate.
000722  3               	sta z80_l
000722  3               	ldy #9
000722  3               	lda (z80_ix),y		; x coordinate.
000722  3               	sta z80_h
000722  3               
000722  3               	lda #<SHRAPN		; shrapnel table.
000722  3               	sta z80_x
000722  3               	lda #>SHRAPN
000722  3               	sta z80_i
000722  3               
000722  3               	lda #NUMSHR		; number of pieces in table.
000722  3               	sta explcnt
000722  3               expld0:
000722  3               	ldy #0
000722  3               	lda (z80_ix),y		; get type.
000722  3               	asl a 			; is this slot in use?
000722  3               	bcs expld1		; no, we can use it.
000722  3               expld2:
000722  3               	clc
000722  3               	lda z80_x
000722  3               	adc #SHRSIZ
000722  3               	sta z80_x
000722  3               	bcc :+
000722  3               	inc z80_i
000722  3               :
000722  3               	dec explcnt		; repeat for all shrapnel.
000722  3               	bne expld0
000722  3               expld3:
000722  3               	pla			; restore sprite pointer.
000722  3               	sta z80_x
000722  3               	pla
000722  3               	sta z80_i
000722  3               	rts 			; out of slots, can't generate any more.
000722  3               
000722  3               expld1:
000722  3               	lda z80_c		; shrapnel counter.
000722  3               	and #15			; 0 to 15.
000722  3               	clc			; add to x.
000722  3               	adc z80_l
000722  3               	ldy #3
000722  3               	sta (z80_ix),y		; y coord.
000722  3               
000722  3               	lda seed3 		; crap random number.
000722  3               	and #15			; 0 to 15.
000722  3               	clc 			; add to y.
000722  3               	adc z80_h
000722  3               	ldy #5
000722  3               	sta (z80_ix),y		; x coord.
000722  3               
000722  3               	lda #2
000722  3               	ldy #0
000722  3               	sta (z80_ix),y		; switch it on.
000722  3               
000722  3               	jsr chkxy		; plot first position.
000722  3               	jsr qrand		; quick random angle.
000722  3               	and #60 		; keep within range.
000722  3               	ldy #1
000722  3               	sta (z80_ix),y		; angle.
000722  3               
000722  3               	dec z80_c		; one less piece of shrapnel to generate.
000722  3               	bne expld2 		; back to main explosion loop.
000722  3               	jmp expld3 		; restore sprite pointer and exit.
000722  3               
000722  3               ;explcnt:	.byte 0
000722  3               
000722  3               ;----------------------------------------------------
000722  3               ; Quick random
000722  3               ;----------------------------------------------------
000722  3               
000722  3               qrand:
000722  3               	jsr random		; r register.
000722  3               	eor seed3		; combine with seed.
000722  3               	sta seed3 		; new seed.
000722  3               	rts
000722  3               
000722  3               ;seed3:	.byte 0
000722  3               
000722  3               ;----------------------------------------------------
000722  3               ; Display all shrapnel.
000722  3               ;----------------------------------------------------
000722  3               
000722  3               dshrp:
000722  3               	lda #<plotde		; display routine.
000722  3               	sta proshx+1
000722  3               	lda #>plotde
000722  3               	sta proshx+2
000722  3               	jsr proshr		; process shrapnel.
000722  3               
000722  3               	lda #<prosh1		; processing routine.
000722  3               	sta proshx+1
000722  3               	lda #>prosh1
000722  3               	sta proshx+2
000722  3               	rts
000722  3               
000722  3               ;------------------------------------------------------
000722  3               ; Particle engine.
000722  3               ;
000722  3               ; Init particle data for 55 particles in SHRAPN table.
000722  3               ; Every particle has 6 bytes.
000722  3               ;
000722  3               ; global:	-
000722  3               ; local:	x,y,hl
000722  3               ; calls:	-
000722  3               ;------------------------------------------------------
000722  3               
000722  3               inishr:
000722  3               	lda #<SHRAPN 		; table.
000722  3               	sta z80_l
000722  3               	lda #>SHRAPN
000722  3               	sta z80_h
000722  3               
000722  3               	ldy #0
000722  3               	ldx #NUMSHR		; shrapnel pieces to process.
000722  3               inish0:
000722  3               	lda #255 		; kill the shrapnel.
000722  3               	sta (z80_hl),y
000722  3               
000722  3               	clc 			; point there.
000722  3               	lda z80_l
000722  3               	adc #SHRSIZ		; distance to next.
000722  3               	sta z80_l
000722  3               	bcc :+
000722  3               	inc z80_h
000722  3               :
000722  3               	dex
000722  3               	bne inish0 		; round again.
000722  3               	rts
000722  3               
000722  3               ;------------------------------------------------------
000722  3               ; Check for collision between laser and sprite.
000722  3               ;------------------------------------------------------
000722  3               
000722  3               lcol:
000722  3               	lda #<SHRAPN		; shrapnel table.
000722  3               	sta z80_l
000722  3               	lda #>SHRAPN
000722  3               	sta z80_h
000722  3               
000722  3               	lda #NUMSHR		; number of pieces in table.
000722  3               	sta z80_b
000722  3               lcol0:
000722  3               	ldy #0
000722  3               	lda (z80_hl),y 		; get type.
000722  3               	beq lcol1		; yes, check collision.
000722  3               lcol3:
000722  3               	clc			; point to more shrapnel.
000722  3               	lda z80_l
000722  3               	adc #SHRSIZ
000722  3               	sta z80_l
000722  3               	bcc :+
000722  3               	inc z80_h
000722  3               :
000722  3               	dec z80_b		; repeat for all shrapnel.
000722  3               	bne lcol0
000722  3               	rts 			; no collision, carry not set.
000722  3               lcol1:
000722  3               	ldy #3
000722  3               	lda (z80_hl),y		; get y.
000722  3               	sec
000722  3               	ldy #8
000722  3               	sbc (z80_ix),y		; subtract sprite y.
000722  3               lcolh:
000722  3               	cmp #SPR_HGT 		; within range?
000722  3               	bcc :+
000722  3               	jmp lcol2		; no, missed.
000722  3               :
000722  3               	ldy #5
000722  3               	lda (z80_hl),y 		; get x.
000722  3               	sec
000722  3               	ldy #9
000722  3               	sbc (z80_ix),y 		; subtract sprite y.
000722  3               	cmp #16			; within range?
000722  3               	bcs :+
000722  3               	jmp lcol4 		; yes, collision occurred.
000722  3               :
000722  3               lcol2:
000722  3               	jmp lcol3
000722  3               lcol4:
000722  3               	sec
000722  3               	rts 			; return with carry set for collision.
000722  3               .endif
000722  3               
000722  3               ;------------------------------------------------------
000722  3               ; Main game engine code starts here.
000722  3               ; After initialisation, mloop is the main loop
000722  3               ;------------------------------------------------------
000722  3               
000722  3               game:
000722  3               
000722  3               ; Set up screen address table.
000722  3               
000722  3               setsat:
000722  3  A9 00        	lda #<ScreenAddr		; start of screen.
000724  3  85 rr        	sta scraddr
000726  3  A9 80        	lda #>ScreenAddr
000728  3  85 rr        	sta scraddr+1
00072A  3               
00072A  3  A0 00        	ldy #0			; vertical lines on screen.
00072C  3               setsa0:
00072C  3  A5 rr        	lda scraddr
00072E  3  99 00 9B     	sta SCADTB_lb,y		; write low byte.
000731  3  A5 rr        	lda scraddr+1
000733  3  C0 C0        	cpy #192		; vertical lines on screen.
000735  3  90 02        	bcc :+
000737  3  09 F0        	ora #$F0		; plot sprites in rom if of screen
000739  3               :
000739  3  99 00 9C     	sta SCADTB_hb,y		; write high byte.
00073C  3  20 E5 14     	jsr nline		; next line down.
00073F  3  C8           	iny			; next position in table.
000740  3  D0 EA        	bne setsa0
000742  3               
000742  3               ; Init graphics mode
000742  3               
000742  3  A9 F0        	lda #ScrMode		; graphics mode
000744  3  8D 00 B0     	sta ScrSelAddr 		; screen selection address
000747  3  20 20 07     	jsr setpal 		; set up palette.
00074A  3               
00074A  3               ; Init AtoMMC joystick
00074A  3  20 15 10     	jsr joyinit		; AtoMMC joystick on PORT B
00074D  3               
00074D  3               rpblc2:
00074D  3               .if pflag
00074D  3               	jsr inishr 		; initialise particle engine.
00074D  3               .endif
00074D  3               evintr:
00074D  3  20 B1 1A     	jsr evnt12 		; call intro/menu event.
000750  3               
000750  3  A9 02        	lda #WALL 		; write default property.
000752  3  A2 00        	ldx #0
000754  3               clrmap:
000754  3  9D 00 98     	sta MAP,x 		; block properties.
000757  3  9D 00 99     	sta MAP+256,x
00075A  3  9D 00 9A     	sta MAP+512,x
00075D  3  E8           	inx			; next byte.
00075E  3  D0 F4        	bne clrmap
000760  3               .if oflag
000760  3               	jsr iniob 		; initialise objects.
000760  3               .endif
000760  3  A9 00        	lda #0			; put zero in accumulator.
000762  3  85 rr        	sta gamwon		; reset game won flag.
000764  3               
000764  3  20 CF 08     	jsr inisc 		; init the score.
000767  3               mapst:
000767  3  AD 44 1A     	lda stmap 		; start position on map.
00076A  3  8D 10 1A     	sta roomtb		; set up position in table, if there is one.
00076D  3               
00076D  3               inipbl:
00076D  3               .if aflag
00076D  3               	lda #<eop		; reset blockpointer
00076D  3               	sta pbptr
00076D  3               	lda #>eop
00076D  3               	sta pbptr+1
00076D  3               .endif
00076D  3  20 F8 15     	jsr initsc 		; set up first screen.
000770  3               
000770  3  A9 FF        	lda #<ssprit 		; default to spare sprite in table.
000772  3  85 68        	sta z80_x
000774  3  A9 19        	lda #>ssprit
000776  3  85 69        	sta z80_i
000778  3               evini:
000778  3  20 B5 1A     	jsr evnt13 		; initialisation.
00077B  3               
00077B  3               ; Two restarts.
00077B  3               ; First restart - clear all sprites and initialise everything.
00077B  3               
00077B  3               rstrt:
00077B  3  20 6F 08     	jsr rsevt 		; restart events.
00077E  3  20 79 06     	jsr xspr 		; clear sprite table.
000781  3  20 64 17     	jsr sprlst 		; fetch pointer to screen sprites.
000784  3  20 ED 17     	jsr ispr 		; initialise sprite table.
000787  3               
000787  3  4C 96 07     	jmp rstrt0
00078A  3               
00078A  3               ; Second restart - clear all but player, and don't initialise him.
00078A  3               
00078A  3               rstrtn:
00078A  3  20 6F 08     	jsr rsevt		; restart events.
00078D  3  20 91 17     	jsr nspr 		; clear all non-player sprites.
000790  3  20 64 17     	jsr sprlst 		; fetch pointer to screen sprites.
000793  3  20 2A 18     	jsr kspr 		; initialise sprite table, no more players.
000796  3               
000796  3               ; Set up the player and/or enemy sprites.
000796  3               
000796  3               rstrt0:
000796  3  A9 00        	lda #0 			; zero in accumulator.
000798  3  85 rr        	sta nexlev 		; reset next level flag.
00079A  3  85 rr        	sta restfl 		; reset restart flag.
00079C  3  85 rr        	sta deadf 		; reset dead flag.
00079E  3  20 3D 0C     	jsr droom 		; show screen layout.
0007A1  3               rpblc0:
0007A1  3               .if pflag
0007A1  3               	jsr inishr 		; initialise particle engine.
0007A1  3               .endif
0007A1  3               .if aflag
0007A1  3               	jsr rbloc		; draw blocks for this screen
0007A1  3               .endif
0007A1  3               .if oflag
0007A1  3               	jsr shwob		; draw objects.
0007A1  3               .endif
0007A1  3               
0007A1  3  A9 33        	lda #<sprtab 		; address of sprite table, even sprites.
0007A3  3  85 68        	sta z80_x
0007A5  3  A9 19        	lda #>sprtab
0007A7  3  85 69        	sta z80_i
0007A9  3  20 D6 12     	jsr dspr 		; display sprites.
0007AC  3               
0007AC  3  A9 44        	lda #<(sprtab+TABSIZ) 	; address of first odd sprite.
0007AE  3  85 68        	sta z80_x
0007B0  3  A9 19        	lda #>(sprtab+TABSIZ)
0007B2  3  85 69        	sta z80_i
0007B4  3  20 D6 12     	jsr dspr 		; display sprites.
0007B7  3               mloop:
0007B7  3  20 86 06     	jsr vsync 		; synchronise with display.
0007BA  3  A9 33        	lda #<sprtab 		; address of sprite table, even sprites.
0007BC  3  85 68        	sta z80_x
0007BE  3  A9 19        	lda #>sprtab
0007C0  3  85 69        	sta z80_i
0007C2  3  20 D6 12     	jsr dspr 		; display even sprites.
0007C5  3               
0007C5  3               ;	jsr plsnd 		; play sounds.
0007C5  3               
0007C5  3  20 21 07     	jsr proshr
0007C8  3  A9 44        	lda #<(sprtab+TABSIZ) 	; address of first odd sprite.
0007CA  3  85 68        	sta z80_x
0007CC  3  A9 19        	lda #>(sprtab+TABSIZ)
0007CE  3  85 69        	sta z80_i
0007D0  3  20 D6 12     	jsr dspr 		; display odd sprites.
0007D3  3               
0007D3  3  A9 FF        	lda #<(ssprit) 		; point to spare sprite for spawning purposes.
0007D5  3  85 68        	sta z80_x
0007D7  3  A9 19        	lda #>(ssprit)
0007D9  3  85 69        	sta z80_i
0007DB  3               evlp1:
0007DB  3  20 4F 1A     	jsr evnt10 		; called once per main loop.
0007DE  3  20 54 12     	jsr pspr 		; process sprites.
0007E1  3               
0007E1  3               ; Main loop events.
0007E1  3               
0007E1  3  A9 FF        	lda #<ssprit 		; point to spare sprite for spawning purposes.
0007E3  3  85 68        	sta z80_x
0007E5  3  A9 19        	lda #>ssprit
0007E7  3  85 69        	sta z80_i
0007E9  3               evlp2:
0007E9  3  20 B0 1A     	jsr evnt11 		; called once per main loop.
0007EC  3               bsortx:
0007EC  3  20 CA 11     	jsr bsort 		; sort sprites.
0007EF  3               
0007EF  3  A5 rr        	lda nexlev		; finished level flag.
0007F1  3  F0 03        	beq :+
0007F3  3  4C 1B 08     	jmp newlev		; is set, go to next level.
0007F6  3               :
0007F6  3  A5 rr        	lda gamwon		; finished game flag.
0007F8  3  F0 03        	beq :+
0007FA  3  4C 2A 08     	jmp evwon		; is set, finish the game.
0007FD  3               :
0007FD  3  A5 rr        	lda restfl 		; finished level flag.
0007FF  3  C9 01        	cmp #1			; has it been set?
000801  3  D0 03        	bne :+
000803  3  4C 7B 07     	jmp rstrt		; yes, go to next level.
000806  3               :
000806  3  C9 02        	cmp #2			; has it been set?
000808  3  D0 03        	bne :+
00080A  3  4C 8A 07     	jmp rstrtn		; yes, go to next level.
00080D  3               :
00080D  3  A5 rr        	lda deadf 		; dead flag.
00080F  3  F0 03        	beq :+
000811  3  4C 30 08     	jmp pdead		; yes, player dead.
000814  3               :
000814  3               ; back to start of main loop.
000814  3               
000814  3  E6 rr        	inc frmno
000816  3  E6 rr        	inc clock
000818  3  4C B7 07     	jmp mloop		; switched to a jmp mloop during test mode.
00081B  3               
00081B  3               ;----------------------------------------------------------
00081B  3               ; Read blocks from list and update screen accordingly.
00081B  3               ;----------------------------------------------------------
00081B  3               
00081B  3               .if aflag
00081B  3               rbloc:
00081B  3               	lda #<eop		; reset temp blockpointer
00081B  3               	sta pbbuf
00081B  3               	lda #>eop
00081B  3               	sta pbbuf+1
00081B  3               
00081B  3               rbloc2:
00081B  3               	lda pbbuf			; check for last block
00081B  3               	cmp pbptr
00081B  3               	bne rbloc1
00081B  3               	lda pbbuf+1
00081B  3               	cmp pbptr+1
00081B  3               	bne rbloc1
00081B  3               	rts
00081B  3               rbloc1:
00081B  3               	ldy #0
00081B  3               	lda (pbbuf),y		; check if block for this scno
00081B  3               	cmp scno
00081B  3               	bne rbloc0		; if not, skip
00081B  3               	iny
00081B  3               	lda (pbbuf),y		; get y
00081B  3               	sta dispy
00081B  3               	iny
00081B  3               	lda (pbbuf),y		; get x
00081B  3               	sta dispx
00081B  3               	iny
00081B  3               	lda (pbbuf),y		; get blocknr
00081B  3               	jsr pattr2		; draw block
00081B  3               rbloc0:
00081B  3               	clc			; point to next block
00081B  3               	lda pbbuf
00081B  3               	adc #4
00081B  3               	sta pbbuf
00081B  3               	bcc rbloc2
00081B  3               	inc pbbuf+1
00081B  3               	jmp rbloc2
00081B  3               .endif
00081B  3               
00081B  3               ;----------------------------------------------------------
00081B  3               ; New level
00081B  3               ;----------------------------------------------------------
00081B  3               
00081B  3               ;.repeat 270
00081B  3               ;  .byte 0
00081B  3               ;.endrep
00081B  3               
00081B  3               newlev:
00081B  3  A5 rr        	lda scno 			; current screen.
00081D  3  18           	clc
00081E  3  69 01        	adc #1				; next screen.
000820  3  CD 84 1B     	cmp numsc			; total number of screens.
000823  3  B0 05        	bcs evwon			; yes, game finished.
000825  3  85 rr        	sta scno			; set new level number.
000827  3  4C 7B 07     	jmp rstrt			; restart, clearing all aliens.
00082A  3               
00082A  3               evwon:
00082A  3  20 BA 1A     	jsr evnt18		 	; game completed.
00082D  3  4C 44 08     	jmp tidyup			; tidy up and return to BASIC/calling routine.
000830  3               
000830  3               ;----------------------------------------------------------
000830  3               ; Player dead.
000830  3               ;----------------------------------------------------------
000830  3               
000830  3               ;.repeat 258
000830  3               ;  .byte 0
000830  3               ;.endrep
000830  3               
000830  3               pdead:
000830  3  A9 00        	lda #0				; zeroise accumulator.
000832  3  85 rr        	sta deadf			; reset dead flag.
000834  3               evdie:
000834  3  20 B8 1A     	jsr evnt16 			; death subroutine.
000837  3  A5 rr        	lda numlif			; number of lives.
000839  3  F0 03        	beq :+
00083B  3  4C 7B 07     	jmp rstrt 			; restart game.
00083E  3               :
00083E  3               evfail:
00083E  3  20 B9 1A     	jsr evnt17 			; failure event.
000841  3  4C 22 07     	jmp game			; restart game
000844  3               
000844  3               ;----------------------------------------------------------
000844  3               ; Tidy things up
000844  3               ;----------------------------------------------------------
000844  3               
000844  3               ;.repeat 291
000844  3               ;  .byte 0
000844  3               ;.endrep
000844  3               
000844  3               tidyup:
000844  3  A0 00        	ldy #0				; digits to check.
000846  3               tidyu2:
000846  3  B9 B8 09     	lda score,y 			; get score digit.
000849  3  CD BE 09     	cmp hiscor 			; are we larger than high score digit?
00084C  3  90 07        	bcc tidyu0			; high score is bigger.
00084E  3  D0 0E        	bne tidyu1			; score is greater, record new high score.
000850  3  C8           	iny				; next digit of high score.
000851  3  C0 06        	cpy #6
000853  3  D0 F1        	bne tidyu2			; repeat for all digits
000855  3               tidyu0:
000855  3  A9 B8        	lda #<score			; return pointing to score.
000857  3  85 62        	sta z80_c
000859  3  A9 09        	lda #>score
00085B  3  85 63        	sta z80_b
00085D  3  60           	rts
00085E  3               tidyu1:
00085E  3  A0 05        	ldy #5
000860  3               tidyu3:
000860  3  B9 B8 09     	lda score,y			; score.
000863  3  99 BE 09     	sta hiscor,y			; high score.
000866  3  88           	dey
000867  3  10 F7        	bpl tidyu3 			; copy score to high score.
000869  3               evnewh:
000869  3  20 BB 1A     	jsr evnt19			; new high score event.
00086C  3  4C 55 08     	jmp tidyu0			; tidy up.
00086F  3               
00086F  3               ;--------------------------------------------------
00086F  3               ; Restart event.
00086F  3               ;--------------------------------------------------
00086F  3               
00086F  3               rsevt:
00086F  3  A9 FF        	lda #<ssprit 			; default to spare element in table.
000871  3  85 68        	sta z80_x
000873  3  A9 19        	lda #>ssprit
000875  3  85 69        	sta z80_i
000877  3               evrs:
000877  3  4C B6 1A     	jmp evnt14	 		; call restart event.
00087A  3               
00087A  3               ;------------------------------------------------------------------
00087A  3               ; Copy number passed in a to string position bc, right-justified.
00087A  3               ;
00087A  3               ; Input:
00087A  3               ;  A  = number
00087A  3               ;  BC = string address
00087A  3               ;
00087A  3               ; Output:
00087A  3               ;  BC = string with number
00087A  3               ;-----------------------------------------------------------------
00087A  3               
00087A  3               num2ch:
00087A  3  85 65        	sta z80_d		; Save number
00087C  3               
00087C  3  A9 00        	lda #0
00087E  3  85 rr        	sta flag
000880  3               numdg3:
000880  3  A2 64        	ldx #100		; hundreds column.
000882  3  86 64        	stx z80_e
000884  3  20 94 08     	jsr numdg		; show digit.
000887  3               numdg2:
000887  3  A2 0A        	ldx #10			; tens column.
000889  3  86 64        	stx z80_e
00088B  3  20 94 08     	jsr numdg		; show digit.
00088E  3               
00088E  3  E6 rr        	inc flag
000890  3  A2 01        	ldx #1			; units column.
000892  3  86 64        	stx z80_e
000894  3               numdg:
000894  3  A9 30        	lda #48			; clear digit.
000896  3  85 61        	sta z80_a
000898  3               numdg1:
000898  3  A5 65        	lda z80_d
00089A  3  C5 64        	cmp z80_e
00089C  3  90 0E        	bcc numdg0		; nothing to show.
00089E  3  38           	sec
00089F  3  A5 65        	lda z80_d
0008A1  3  E5 64        	sbc z80_e		; subtract from column.
0008A3  3  85 65        	sta z80_d
0008A5  3  E6 61        	inc z80_a		; increment digit.
0008A7  3  E6 rr        	inc flag
0008A9  3  4C 98 08     	jmp numdg1		; repeat until column is zero.
0008AC  3               numdg0:
0008AC  3  A0 00        	ldy #0
0008AE  3  A5 61        	lda z80_a
0008B0  3  91 62        	sta (z80_bc),y		; write digit to buffer.
0008B2  3  A5 rr        	lda flag
0008B4  3  F0 06        	beq :+
0008B6  3  E6 62        	inc z80_c		; next buffer position.
0008B8  3  D0 02        	bne :+
0008BA  3  E6 63        	inc z80_b
0008BC  3               :
0008BC  3  60           	rts
0008BD  3               num2dd:
0008BD  3  85 65        	sta z80_d		; Save number
0008BF  3               
0008BF  3  A9 01        	lda #1
0008C1  3  85 rr        	sta flag
0008C3  3               
0008C3  3  4C 87 08     	jmp numdg2
0008C6  3               num2td:
0008C6  3  85 65        	sta z80_d		; Save number
0008C8  3               
0008C8  3  A9 01        	lda #1
0008CA  3  85 rr        	sta flag
0008CC  3  4C 80 08     	jmp numdg3
0008CF  3               
0008CF  3               ;flag:	.byte 0
0008CF  3               
0008CF  3               ;---------------------------------------------------------
0008CF  3               ; Reset score to "000000"
0008CF  3               ;---------------------------------------------------------
0008CF  3               
0008CF  3               inisc:
0008CF  3  A9 30        	lda #'0'
0008D1  3  A2 05        	ldx #5			; digits to initialise.
0008D3  3               inisc0:
0008D3  3  9D B8 09     	sta score,x 		; write zero digit.
0008D6  3  CA           	dex			; next column.
0008D7  3  10 FA        	bpl inisc0		; repeat for all digits.
0008D9  3               
0008D9  3  60           	rts
0008DA  3               
0008DA  3               ;-----------------------------------------------------
0008DA  3               ; Multiply h by d and return in hl.
0008DA  3               ;
0008DA  3               ; Input:
0008DA  3               ;  H = first number
0008DA  3               ;  D = second number
0008DA  3               ;
0008DA  3               ; Output:
0008DA  3               ;  HL = result H x D
0008DA  3               ;-----------------------------------------------------
0008DA  3               
0008DA  3               imul:
0008DA  3  A5 65        	lda z80_d		; HL = H * D
0008DC  3  85 64        	sta z80_e
0008DE  3  A5 67        	lda z80_h
0008E0  3  85 62        	sta z80_c		; make c first multiplier.
0008E2  3               imul0:
0008E2  3  A9 00        	lda #0			; zeroise total.
0008E4  3  85 66        	sta z80_l
0008E6  3  85 67        	sta z80_h
0008E8  3               
0008E8  3  A5 67        	lda z80_h
0008EA  3  85 65        	sta z80_d		; zeroise high byte.
0008EC  3               
0008EC  3  A9 08        	lda #8			; repeat 8 times.
0008EE  3  85 63        	sta z80_b
0008F0  3               imul1:
0008F0  3  46 62        	lsr z80_c		; rotate rightmost bit into carry.
0008F2  3  90 0E        	bcc imul2		; wasn't set.
0008F4  3  18           	clc			; bit was set, so add de.
0008F5  3  A5 66        	lda z80_l
0008F7  3  65 64        	adc z80_e
0008F9  3  85 66        	sta z80_l
0008FB  3  A5 67        	lda z80_h
0008FD  3  65 65        	adc z80_d
0008FF  3  85 67        	sta z80_h
000901  3  18           	clc 			; reset carry.
000902  3               imul2:
000902  3  06 64        	asl z80_e 		; shift de 1 bit left.
000904  3  26 65        	rol z80_d
000906  3  C6 63        	dec z80_b
000908  3  D0 E6        	bne imul1		; repeat 8 times.
00090A  3               
00090A  3  60           	rts
00090B  3               
00090B  3               ;-----------------------------------------------
00090B  3               ; Divide d by e and return in d, remainder in a.
00090B  3               ;
00090B  3               ; Input:
00090B  3               ;  D = first number
00090B  3               ;  E = second number
00090B  3               ;
00090B  3               ; Output:
00090B  3               ;  D = result D/E
00090B  3               ;  A = remainder
00090B  3               ;-----------------------------------------------
00090B  3               
00090B  3               idiv:
00090B  3  A9 00        	lda #0
00090D  3  A0 08        	ldy #8		 	; bits to shift.
00090F  3  06 65        	asl z80_d
000911  3               idiv0:
000911  3  2A           	rol a 			; multiply d by 2.
000912  3  C5 64        	cmp z80_e 		; test if e is smaller.
000914  3  90 02        	bcc idiv1		; e is greater, no division this time.
000916  3  E5 64        	sbc z80_e		; subtract it.
000918  3               idiv1:
000918  3  26 65        	rol z80_d		; rotate into d.
00091A  3  88           	dey
00091B  3  D0 F4        	bne idiv0		; repeat
00091D  3  60           	rts
00091E  3               
00091E  3               ;---------------------------------------------------
00091E  3               ; Play AY sound effect
00091E  3               ;---------------------------------------------------
00091E  3               
00091E  3               plsnd:
00091E  3  60           	rts
00091F  3               
00091F  3               ;---------------------------------------------------
00091F  3               ; Objects handling.
00091F  3               ; 32 bytes for image
00091F  3               ; 3 for room, y and x
00091F  3               ; 3 for starting room, y and x.
00091F  3               ; 254 = disabled.
00091F  3               ; 255 = object in player"s pockets.
00091F  3               ;---------------------------------------------------
00091F  3               
00091F  3               ;---------------------------------------------------
00091F  3               ; Show items present.
00091F  3               ;---------------------------------------------------
00091F  3               
00091F  3               .if oflag
00091F  3               shwob:
00091F  3               	lda #<objdta 			; objects table.
00091F  3               	sta z80_l
00091F  3               	lda #>objdta
00091F  3               	sta z80_h
00091F  3               
00091F  3               	lda numob 			; number of objects in the game.
00091F  3               	sta sprcnt
00091F  3               shwob0:
00091F  3               	ldy #32 			; distance to room number.
00091F  3               	lda (z80_hl),y 			; same as an item?
00091F  3               	cmp scno 			; current location.
00091F  3               	bne :+
00091F  3               	jsr dobj 			; yes, display object.
00091F  3               :
00091F  3               	clc
00091F  3               	lda z80_l
00091F  3               	adc #38 			; distance to next item.
00091F  3               	sta z80_l
00091F  3               	lda z80_h
00091F  3               	adc #0
00091F  3               	sta z80_h	 		; point to it.
00091F  3               	dec sprcnt
00091F  3               	bne shwob0 			; repeat for others.
00091F  3               	rts
00091F  3               
00091F  3               ;---------------------------------------------------
00091F  3               ; Display object.
00091F  3               ; hl must point to object's start address.
00091F  3               ;
00091F  3               ; Input:
00091F  3               ;  HL = object address
00091F  3               ;---------------------------------------------------
00091F  3               
00091F  3               dobj:
00091F  3               	ldy #33
00091F  3               	lda (z80_hl),y 			; point to y.
00091F  3               	sta dispy
00091F  3               	iny
00091F  3               	lda (z80_hl),y 			; point to x.
00091F  3               	sta dispx
00091F  3               dobj1:
00091F  3               	jmp sprite 			; draw this sprite.
00091F  3               
00091F  3               ;--------------------------------------
00091F  3               ; Remove an object.
00091F  3               ;
00091F  3               ; Input:
00091F  3               ;  A = object number
00091F  3               ;--------------------------------------
00091F  3               
00091F  3               remob:
00091F  3               	cmp numob			; number of objects in game.
00091F  3               	bcc :+				; are we checking past the end?
00091F  3               	rts				; yes, can't get non-existent item.
00091F  3               :
00091F  3               	pha				; remember object.
00091F  3               	jsr getob			; pick it up if we haven't already got it.
00091F  3               	pla				; retrieve object number.
00091F  3               	jsr gotob			; get its address.
00091F  3               	lda #254
00091F  3               	ldy #32
00091F  3               	sta (z80_hl),y			; remove it.
00091F  3               	rts
00091F  3               
00091F  3               ;---------------------------------------------------
00091F  3               ; Pick up object number held in the accumulator.
00091F  3               ;
00091F  3               ; Input:
00091F  3               ;  A = object number
00091F  3               ;---------------------------------------------------
00091F  3               
00091F  3               getob:
00091F  3               	cmp numob 		; number of objects in game.
00091F  3               	bcc :+			; are we checking past the end?
00091F  3               	rts			; yes, can't get non-existent item.
00091F  3               :
00091F  3               	jsr gotob 		; check if we already have it.
00091F  3               	cmp #255
00091F  3               	bne :+
00091F  3               	rts			; we already do.
00091F  3               :
00091F  3               	ldy #32
00091F  3               	lda (z80_hl),y		; is it on this screen?
00091F  3               	cmp scno 		; current screen.
00091F  3               	bne getob0		; not on screen, so nothing to delete.
00091F  3               
00091F  3               	lda #255
00091F  3               	sta (z80_hl),y		; pick it up.
00091F  3               	iny 			; point to y coord.
00091F  3               getob1:
00091F  3               	ldy #33
00091F  3               	lda (z80_hl),y		; y coord.
00091F  3               	sta dispy
00091F  3               	ldy #34
00091F  3               	lda (z80_hl),y 		; x coord.
00091F  3               	sta dispx
00091F  3               	jmp dobj1 		; delete object sprite.
00091F  3               getob0:
00091F  3               	lda #255
00091F  3               	sta (z80_hl),y 		; pick it up.
00091F  3               	rts
00091F  3               .endif
00091F  3               
00091F  3               ;-----------------------------------------------------------------
00091F  3               ; Got object check.
00091F  3               ; Call with object in accumulator, returns zero set if in pockets.
00091F  3               ;
00091F  3               ; Input:
00091F  3               ;  A = object number
00091F  3               ;-----------------------------------------------------------------
00091F  3               .if oflag .or mflag
00091F  3               gotob:
00091F  3               	cmp numob 		; number of objects in game.
00091F  3               	bcc :+ 			; are we checking past the end?
00091F  3               	jmp gotob0 		; yes, we can't have a non-existent object.
00091F  3               :
00091F  3               	jsr findob		; find the object.
00091F  3               gotob1:
00091F  3               	rts
00091F  3               
00091F  3               gotob0:
00091F  3               	lda #254 		; missing.
00091F  3               	jmp gotob1
00091F  3               
00091F  3               findob:
00091F  3               	pha			; save object number
00091F  3               	lda #<objdta 		; objects.
00091F  3               	sta z80_l
00091F  3               	lda #>objdta
00091F  3               	sta z80_h
00091F  3               	pla			; retreive object number
00091F  3               	beq fndob1 		; is it zero? yes, skip loop.
00091F  3               	tax 			; loop counter
00091F  3               fndob2:
00091F  3               	clc
00091F  3               	lda z80_l
00091F  3               	adc #38 		; size of each object.
00091F  3               	sta z80_l
00091F  3               	bcc :+
00091F  3               	inc z80_h
00091F  3               :
00091F  3               	dex 			; repeat until we find address.
00091F  3               	bne fndob2
00091F  3               fndob1:
00091F  3               	ldy #32			; distance to room it's in.
00091F  3               	lda (z80_hl),y		; fetch status.
00091F  3               	rts
00091F  3               .endif
00091F  3               
00091F  3               ;---------------------------------------------
00091F  3               ; Drop object number at (dispx, dispy).
00091F  3               ;
00091F  3               ; Input:
00091F  3               ;  A = object number
00091F  3               ;---------------------------------------------
00091F  3               
00091F  3               .if oflag
00091F  3               drpob:
00091F  3               	cmp numob 		; are we checking past the end?
00091F  3               	bcc :+
00091F  3               	rts			; yes, can't drop non-existent item.
00091F  3               :
00091F  3               	jsr gotob		; make sure object is in inventory.
00091F  3               	cmp scno		; already on this screen?
00091F  3               	bne :+
00091F  3               	rts			; yes, nothing to do.
00091F  3               :
00091F  3               	ldy #32
00091F  3               	lda scno
00091F  3               	sta (z80_hl),y		; bring onto screen.
00091F  3               	lda dispy		; sprite y coordinate.
00091F  3               	iny
00091F  3               	sta (z80_hl),y		; point to object y.
00091F  3               	lda dispx 		; sprite x coordinate.
00091F  3               	iny
00091F  3               	sta (z80_hl),y 		; point to object x
00091F  3               	jmp dobj		; draw the object sprite.
00091F  3               
00091F  3               ;-----------------------------------------------
00091F  3               ; Seek objects at sprite position.
00091F  3               ;
00091F  3               ; Output:
00091F  3               ;  A = object number, if not found A=255
00091F  3               ;-----------------------------------------------
00091F  3               
00091F  3               skobj:
00091F  3               	lda #<objdta 		; pointer to objects.
00091F  3               	sta z80_l
00091F  3               	lda #>objdta
00091F  3               	sta z80_h
00091F  3               
00091F  3               	lda numob 		; number of objects in game.
00091F  3               	sta z80_b 		; set up the loop counter.
00091F  3               skobj0:
00091F  3               	lda scno		; current room number.
00091F  3               	ldy #32
00091F  3               	cmp (z80_hl),y		; is object in here?
00091F  3               	bne :+
00091F  3               	jsr skobj1		; yes, check coordinates.
00091F  3               :
00091F  3               	clc			; point to next object in table.
00091F  3               	lda z80_l
00091F  3               	adc #38			; size of each object.
00091F  3               	sta z80_l
00091F  3               	bcc :+
00091F  3               	inc z80_h
00091F  3               :
00091F  3               	dec z80_b
00091F  3               	bne skobj0		; repeat for all objects.
00091F  3               
00091F  3               	lda #255		; end of list and nothing found, return 255.
00091F  3               	rts
00091F  3               
00091F  3               skobj1:
00091F  3               	ldy #33			; point to y coordinate.
00091F  3               	lda (z80_hl),y		; point to y coordinate.
00091F  3               	sec
00091F  3               	ldy #8
00091F  3               	sbc (z80_ix),y 		; subtract sprite y.
00091F  3               	clc
00091F  3               	adc #15			; add sprite height minus one.
00091F  3               	cmp #31			; within range?
00091F  3               	bcs skobj2		; no, ignore object.
00091F  3               
00091F  3               	ldy #34			; point to x coordinate now.
00091F  3               	lda (z80_hl),y 		; get coordinate.
00091F  3               	sec
00091F  3               	ldy #9
00091F  3               	sbc (z80_ix),y 		; subtract the sprite x.
00091F  3               	clc			; add sprite width minus one.
00091F  3               	adc #15
00091F  3               	cmp #31			; within range?
00091F  3               	bcs skobj2		; no, ignore object.
00091F  3               
00091F  3               	pla			; remove return address from stack.
00091F  3               	pla
00091F  3               
00091F  3               	lda numob 		; objects in game.
00091F  3               	sec
00091F  3               	sbc z80_b		; subtract loop counter.
00091F  3               skobj2:
00091F  3               	rts			; accumulator now points to object.
00091F  3               .endif
00091F  3               
00091F  3               ;---------------------------------------------------------------------
00091F  3               ; Spawn a new sprite.
00091F  3               ;---------------------------------------------------------------------
00091F  3               
00091F  3                 offset = 20
00091F  3               
00091F  3               ;.repeat 343
00091F  3               ;  .byte 0
00091F  3               ;.endrep
00091F  3               
00091F  3               spawn:
00091F  3  A9 33        	lda #<sprtab		; sprite table.
000921  3  85 66        	sta z80_l
000923  3  A9 19        	lda #>sprtab
000925  3  85 67        	sta z80_h
000927  3               numsp1:
000927  3  A9 0C        	lda #NUMSPR		; number of sprites.
000929  3  85 rr        	sta spcnt
00092B  3               spaw0:
00092B  3  A0 00        	ldy #0
00092D  3  B1 66        	lda (z80_hl),y		; get sprite type.
00092F  3  C9 FF        	cmp #255		; is it an unused slot?
000931  3  F0 0F        	beq spaw1 		; yes, we can use this one.
000933  3               
000933  3  18           	clc 			; point to next sprite in table.
000934  3  A5 66        	lda z80_l
000936  3  69 11        	adc #TABSIZ		; size of each entry.
000938  3  85 66        	sta z80_l
00093A  3  90 02        	bcc :+
00093C  3  E6 67        	inc z80_h
00093E  3               :
00093E  3  C6 rr        	dec spcnt		; one less iteration.
000940  3  D0 E9        	bne spaw0		; keep going until we find a slot.
000942  3               
000942  3               ; Didn't find one but drop through and set up a dummy sprite instead.
000942  3               
000942  3               spaw1:
000942  3  A5 69        	lda z80_i		; address of original sprite.
000944  3  48           	pha
000945  3  A5 68        	lda z80_x
000947  3  48           	pha
000948  3               
000948  3  A5 66        	lda z80_l		; store spawned sprite address.
00094A  3  85 rr        	sta spptr
00094C  3  A5 67        	lda z80_h
00094E  3  85 rr        	sta spptr+1
000950  3               
000950  3  A5 62        	lda z80_c
000952  3  A0 00        	ldy #0
000954  3  91 66        	sta (z80_hl),y 		; set the type.
000956  3  A0 05        	ldy #5
000958  3  91 66        	sta (z80_hl),y		; copy
00095A  3               
00095A  3  A5 63        	lda z80_b
00095C  3  A0 01        	ldy #1
00095E  3  91 66        	sta (z80_hl),y		; set the image.
000960  3  A0 06        	ldy #6
000962  3  91 66        	sta (z80_hl),y		; copy
000964  3               
000964  3  A9 00        	lda #0 			; frame zero.
000966  3  A0 02        	ldy #2
000968  3  91 66        	sta (z80_hl),y		; set frame.
00096A  3  A0 07        	ldy #7
00096C  3  91 66        	sta (z80_hl),y		; copy
00096E  3               
00096E  3  A0 08        	ldy #8
000970  3  B1 68        	lda (z80_ix),y 		; x coordinate.
000972  3  A0 03        	ldy #3
000974  3  91 66        	sta (z80_hl),y		; set sprite coordinate.
000976  3  A0 08        	ldy #8
000978  3  91 66        	sta (z80_hl),y		; copy
00097A  3               
00097A  3  A0 09        	ldy #9
00097C  3  B1 68        	lda (z80_ix),y 		; y coordinate.
00097E  3  A0 04        	ldy #4
000980  3  91 66        	sta (z80_hl),y		; set sprite coordinate.
000982  3  A0 09        	ldy #9
000984  3  91 66        	sta (z80_hl),y		; copy
000986  3               
000986  3  A0 0A        	ldy #10			; direction of original.
000988  3  B1 68        	lda (z80_ix),y
00098A  3  91 66        	sta (z80_hl),y		; direction
00098C  3               
00098C  3  A9 00        	lda #0
00098E  3  A0 0B        	ldy #11
000990  3  91 66        	sta (z80_hl),y		; reset parameter.
000992  3  C8           	iny
000993  3  91 66        	sta (z80_hl),y		; reset parameter.
000995  3  C8           	iny
000996  3  91 66        	sta (z80_hl),y		; reset parameter.
000998  3  C8           	iny
000999  3  91 66        	sta (z80_hl),y		; reset parameter.
00099B  3               rtssp:
00099B  3  A5 rr        	lda spptr		; address of new sprite.
00099D  3  85 68        	sta z80_x
00099F  3  A5 rr        	lda spptr+1
0009A1  3  85 69        	sta z80_i
0009A3  3               evis1:
0009A3  3  20 4E 1A     	jsr evnt09 		; call sprite initialisation event.
0009A6  3               
0009A6  3  A5 rr        	lda spptr 		; address of new sprite.
0009A8  3  85 68        	sta z80_x
0009AA  3  A5 rr        	lda spptr+1
0009AC  3  85 69        	sta z80_i
0009AE  3  20 FC 13     	jsr sspria 		; display the new sprite.
0009B1  3               
0009B1  3  68           	pla			; address of original sprite.
0009B2  3  85 68        	sta z80_x
0009B4  3  68           	pla
0009B5  3  85 69        	sta z80_i
0009B7  3               
0009B7  3  60           	rts
0009B8  3               
0009B8  3               ;spcnt:	.byte 0
0009B8  3               ;spptr:	.word 0			; spawned sprite pointer.
0009B8  3               ;seed:	.byte 0			; seed for random numbers.
0009B8  3  30 30 30 30  score:	.byte "000000"		; player"s score.
0009BC  3  30 30        
0009BE  3  30 30 30 30  hiscor:	.byte "000000"		; high score.
0009C2  3  30 30        
0009C4  3  30 30 30 30  bonus:	.byte "000000"		; bonus.
0009C8  3  30 30        
0009CA  3  00 80        grbase:	.word ScreenAddr	; graphics base address.
0009CC  3               
0009CC  3               ;----------------------------------------------------
0009CC  3               ; Check y-pos
0009CC  3               ;----------------------------------------------------
0009CC  3               
0009CC  3               checkx:
0009CC  3  A5 rr        	lda dispy		; y position.
0009CE  3  C9 18        	cmp #24			; off screen?
0009D0  3  B0 01        	bcs :+
0009D2  3  60           	rts			; no, it's okay.
0009D3  3               :
0009D3  3  68           	pla			; remove return address from stack.
0009D4  3  85 66        	sta z80_l
0009D6  3  68           	pla
0009D7  3  85 67        	sta z80_h
0009D9  3  60           	rts
0009DA  3               
0009DA  3               ;-----------------------------------------------
0009DA  3               ; Displays the current high score.
0009DA  3               ;-----------------------------------------------
0009DA  3               
0009DA  3               dhisc:
0009DA  3  A9 BE        	lda #<hiscor 		; high score text.
0009DC  3  8D 11 0A     	sta dscor3+1
0009DF  3  8D 2C 0A     	sta bscor3+1
0009E2  3  A9 09        	lda #>hiscor
0009E4  3  8D 12 0A     	sta dscor3+2
0009E7  3  8D 2D 0A     	sta bscor3+2
0009EA  3  4C FD 09     	jmp dscor1		; check in printable range then show 6 digits.
0009ED  3               
0009ED  3               ;------------------------------------------------------
0009ED  3               ; Displays the current score.
0009ED  3               ;------------------------------------------------------
0009ED  3               
0009ED  3               ;.repeat 322
0009ED  3               ;  .byte 0
0009ED  3               ;.endrep
0009ED  3               
0009ED  3               dscor:
0009ED  3  A9 B8        	lda #<score		; score text.
0009EF  3  8D 11 0A     	sta dscor3+1
0009F2  3  8D 2C 0A     	sta bscor3+1
0009F5  3  A9 09        	lda #>score
0009F7  3  8D 12 0A     	sta dscor3+2
0009FA  3  8D 2D 0A     	sta bscor3+2
0009FD  3               dscor1:
0009FD  3  8C 28 0A     	sty tmpscr
000A00  3  20 9E 11     	jsr preprt		; set up font and print position.
000A03  3  20 CC 09     	jsr checkx		; make sure we're in a printable range.
000A06  3               
000A06  3               ;	lda #6			; digits to display.
000A06  3               ;	sta z80_b
000A06  3  A5 rr        	lda prtmod		; get print mode.
000A08  3  F0 03        	beq :+			; standard size text?
000A0A  3  4C 29 0A     	jmp bscor0		; no, show double-height.
000A0D  3               :
000A0D  3               dscor0:
000A0D  3               ;	ldy #0
000A0D  3               ;	lda (z80_hl),y 		; fetch character.
000A0D  3  AC 28 0A     	ldy tmpscr
000A10  3               dscor3:
000A10  3  B9 B8 09     	lda score,y
000A13  3  20 60 0B     	jsr pchar 		; display character.
000A16  3  E6 rr        	inc dispx		; move along x coordinate
000A18  3               
000A18  3               ;	inc z80_l		; next score column.
000A18  3               ;	bne :+
000A18  3               ;	inc z80_h
000A18  3               ;:
000A18  3  EE 28 0A     	inc tmpscr
000A1B  3  C6 63        	dec z80_b
000A1D  3  D0 EE        	bne dscor0 		; repeat for all digits.
000A1F  3               dscor2:
000A1F  3  A5 rr        	lda dispx 		; set up display coordinates.
000A21  3  85 rr        	sta charx
000A23  3  A5 rr        	lda dispy
000A25  3  85 rr        	sta chary
000A27  3  60           	rts
000A28  3               
000A28  3  00           tmpscr:	.byte 0
000A29  3               ;------------------------------------------------------
000A29  3               ; Displays the current score in double-height characters.
000A29  3               ;
000A29  3               ; Input:
000A29  3               ;  B  = digit number
000A29  3               ;  HL = score string
000A29  3               ;------------------------------------------------------
000A29  3               
000A29  3               bscor0:
000A29  3               ;	ldy #0
000A29  3               
000A29  3               ;	lda (z80_hl),y 		; fetch character.
000A29  3  A4 rr        	ldy tmp
000A2B  3               bscor3:
000A2B  3  B9 B8 09     	lda score,y
000A2E  3  20 25 11     	jsr bchar 		; display big char.
000A31  3               
000A31  3               ;	inc z80_l 		; next score column.
000A31  3               ;	bne :+
000A31  3               ;	inc z80_h
000A31  3               ;:
000A31  3  E6 rr        	inc tmp
000A33  3  C6 63        	dec z80_b
000A35  3  F0 03        	beq :+
000A37  3  4C 29 0A     	jmp bscor0 		; repeat for all digits.
000A3A  3               :
000A3A  3  4C 1F 0A     	jmp dscor2 		; tidy up line and column variables.
000A3D  3               
000A3D  3               ;-----------------------------------------------------
000A3D  3               ; Adds number in the hl pair to the score.
000A3D  3               ;-----------------------------------------------------
000A3D  3               
000A3D  3               addsc:
000A3D  3  A9 B9        	lda #<(score+1) 	; ten thousands column.
000A3F  3  85 64        	sta z80_e
000A41  3  A9 09        	lda #>(score+1)
000A43  3  85 65        	sta z80_d
000A45  3  A9 10        	lda #<10000		; amount to add each time.
000A47  3  85 62        	sta z80_c
000A49  3  A9 27        	lda #>10000
000A4B  3  85 63        	sta z80_b
000A4D  3  20 91 0A     	jsr incsc		; add to score.
000A50  3               
000A50  3  E6 64        	inc z80_e		; thousands column.
000A52  3  D0 02        	bne :+
000A54  3  E6 65        	inc z80_d
000A56  3               :
000A56  3  A9 E8        	lda #<1000		; amount to add each time.
000A58  3  85 62        	sta z80_c
000A5A  3  A9 03        	lda #>1000
000A5C  3  85 63        	sta z80_b
000A5E  3  20 91 0A     	jsr incsc 		; add to score.
000A61  3               
000A61  3  E6 64        	inc z80_e		; hundreds column.
000A63  3  D0 02        	bne :+
000A65  3  E6 65        	inc z80_d
000A67  3               :
000A67  3  A9 64        	lda #<100		; amount to add each time.
000A69  3  85 62        	sta z80_c
000A6B  3  A9 00        	lda #>100
000A6D  3  85 63        	sta z80_b
000A6F  3  20 91 0A     	jsr incsc		; add to score.
000A72  3               
000A72  3  E6 64        	inc z80_e 		; tens column.
000A74  3  D0 02        	bne :+
000A76  3  E6 65        	inc z80_d
000A78  3               :
000A78  3  A9 0A        	lda #<10		; amount to add each time.
000A7A  3  85 62        	sta z80_c
000A7C  3  A9 00        	lda #>10
000A7E  3  85 63        	sta z80_b
000A80  3  20 91 0A     	jsr incsc 		; add to score.
000A83  3               
000A83  3  E6 64        	inc z80_e		; units column.
000A85  3  D0 02        	bne :+
000A87  3  E6 65        	inc z80_d
000A89  3               :
000A89  3  A9 01        	lda #<1			; units.
000A8B  3  85 62        	sta z80_c
000A8D  3  A9 00        	lda #>1
000A8F  3  85 63        	sta z80_b
000A91  3               incsc:
000A91  3  A5 67        	lda z80_h		; store amount to add.
000A93  3  48           	pha
000A94  3  A5 66        	lda z80_l
000A96  3  48           	pha
000A97  3               
000A97  3  38           	sec			; subtract from amount to add.
000A98  3  A5 66        	lda z80_l
000A9A  3  E5 62        	sbc z80_c
000A9C  3  85 66        	sta z80_l
000A9E  3  A5 67        	lda z80_h
000AA0  3  E5 63        	sbc z80_b
000AA2  3  85 67        	sta z80_h
000AA4  3  90 14        	bcc incsc0		; too much, restore value.
000AA6  3               
000AA6  3  68           	pla			; delete the previous amount from the stack.
000AA7  3  68           	pla
000AA8  3               
000AA8  3  A5 65        	lda z80_d 		; store column position.
000AAA  3  48           	pha
000AAB  3  A5 64        	lda z80_e
000AAD  3  48           	pha
000AAE  3  20 C1 0A     	jsr incsc2		; do the increment.
000AB1  3               
000AB1  3  68           	pla			; restore column.
000AB2  3  85 64        	sta z80_e
000AB4  3  68           	pla
000AB5  3  85 65        	sta z80_d
000AB7  3  4C 91 0A     	jmp incsc		; repeat until all added.
000ABA  3               
000ABA  3               incsc0:
000ABA  3  68           	pla			; restore previous value.
000ABB  3  85 66        	sta z80_l
000ABD  3  68           	pla
000ABE  3  85 67        	sta z80_h
000AC0  3  60           	rts
000AC1  3               incsc2:
000AC1  3  A0 00        	ldy #0
000AC3  3  B1 64        	lda (z80_de),y 		; get amount.
000AC5  3  18           	clc
000AC6  3  69 01        	adc #1			; add one to column.
000AC8  3  91 64        	sta (z80_de),y		; write new column total.
000ACA  3  C9 3A        	cmp #'9'+1		; gone beyond range of digits?
000ACC  3  B0 01        	bcs :+
000ACE  3  60           	rts			; no, carry on.
000ACF  3               :
000ACF  3  A9 30        	lda #'0'		; make it zero.
000AD1  3  91 64        	sta (z80_de),y		; write new column total.
000AD3  3  C6 64        	dec z80_e		; back one column.
000AD5  3  D0 02        	bne :+
000AD7  3  C6 65        	dec z80_d
000AD9  3               :
000AD9  3  4C C1 0A     	jmp incsc2
000ADC  3               
000ADC  3               ;------------------------------------
000ADC  3               ; Add bonus to score and reset bonus
000ADC  3               ;------------------------------------
000ADC  3               
000ADC  3               addbo:
000ADC  3  A2 05        	ldx #5			; last digit.
000ADE  3  18           	clc
000ADF  3               addbo0:
000ADF  3  BD B8 09     	lda score,x		; get score.
000AE2  3  7D C4 09     	adc bonus,x		; add bonus.
000AE5  3  38           	sec			; 0 to 18.
000AE6  3  E9 30        	sbc #48
000AE8  3  48           	pha
000AE9  3  A9 30        	lda #'0'
000AEB  3  9D C4 09     	sta bonus,x
000AEE  3  68           	pla
000AEF  3  C9 3A        	cmp #58
000AF1  3  90 03        	bcc addbo1
000AF3  3  38           	sec
000AF4  3  E9 0A        	sbc #10
000AF6  3               addbo1:
000AF6  3  9D B8 09     	sta score,x		; zeroise bonus.
000AF9  3  CA           	dex			; next digit.
000AFA  3  10 E3        	bpl addbo0		; repeat for all 6 digits.
000AFC  3  60           	rts
000AFD  3               
000AFD  3               ;------------------------------------
000AFD  3               ; Swap score and bonus.
000AFD  3               ;------------------------------------
000AFD  3               
000AFD  3               swpsb:
000AFD  3  A2 05        	ldx #5			; digits to add.
000AFF  3               swpsb0:
000AFF  3  BD B8 09     	lda score,x 		; get score digits.
000B02  3  48           	pha			; save digit
000B03  3  BD C4 09     	lda bonus,x 		; get bonus digits.
000B06  3  9D B8 09     	sta score,x		; switch score-bonus
000B09  3  68           	pla
000B0A  3  9D C4 09     	sta bonus,x
000B0D  3  CA           	dex 			; repeat for all 6 digits.
000B0E  3  10 EF        	bpl swpsb0
000B10  3  60           	rts
000B11  3               
000B11  3               ;----------------------------------------------------
000B11  3               ; Get print address.
000B11  3               ;----------------------------------------------------
000B11  3               
000B11  3               gprad:
000B11  3  A5 rr        	lda dispx		; get x
000B13  3  85 rr        	sta scraddr		; store lb address
000B15  3               
000B15  3  2A           	rol a
000B16  3  26 rr        	rol tmp
000B18  3  2A           	rol a
000B19  3  26 rr        	rol tmp
000B1B  3  2A           	rol a
000B1C  3  26 rr        	rol tmp
000B1E  3  A5 rr        	lda tmp
000B20  3  29 07        	and #7
000B22  3  85 rr        	sta tmp
000B24  3  A5 rr        	lda prtmod
000B26  3  F0 02        	beq :+
000B28  3  06 rr        	asl tmp
000B2A  3               :
000B2A  3  A5 rr        	lda tmp
000B2C  3  18           	clc
000B2D  3  65 rr        	adc dispy		; get y
000B2F  3  09 80        	ora #$80		; add $80
000B31  3  85 rr        	sta scraddr+1		; store hb address
000B33  3  60           	rts
000B34  3               
000B34  3               ;--------------------------------------------------------------
000B34  3               ; Get property buffer address of char at (dispx, dispy) in hl.
000B34  3               ;
000B34  3               ; Output:
000B34  3               ;  bufaddr = MAP + dispy*32 + dispx
000B34  3               ;--------------------------------------------------------------
000B34  3               
000B34  3               pradd:
000B34  3  A5 rr        	lda dispy 		; y coordinate.
000B36  3  85 rr        	sta bufaddr
000B38  3  A9 00        	lda #0
000B3A  3  85 rr        	sta bufaddr+1
000B3C  3  06 rr        	asl bufaddr  		; multiply char by 32
000B3E  3  26 rr        	rol bufaddr+1
000B40  3  06 rr        	asl bufaddr
000B42  3  26 rr        	rol bufaddr+1
000B44  3  06 rr        	asl bufaddr
000B46  3  26 rr        	rol bufaddr+1
000B48  3  06 rr        	asl bufaddr
000B4A  3  26 rr        	rol bufaddr+1
000B4C  3  06 rr        	asl bufaddr
000B4E  3  26 rr        	rol bufaddr+1
000B50  3  18           	clc			; add address of MAP graphics.
000B51  3  A5 rr        	lda bufaddr
000B53  3  65 rr        	adc dispx
000B55  3  69 00        	adc #<MAP
000B57  3  85 rr        	sta bufaddr
000B59  3  A5 rr        	lda bufaddr+1
000B5B  3  69 98        	adc #>MAP
000B5D  3  85 rr        	sta bufaddr+1
000B5F  3  60           	rts
000B60  3               
000B60  3               ;----------------------------------------------------
000B60  3               ; Display character in A at dispx,dispy.
000B60  3               ;
000B60  3               ; Input:
000B60  3               ;  A 	   = character to print
000B60  3               ;----------------------------------------------------
000B60  3               
000B60  3               pchar:
000B60  3  85 rr        	sta fntaddr
000B62  3  A9 00        	lda #0
000B64  3  85 rr        	sta fntaddr+1
000B66  3  06 rr        	asl fntaddr  		; multiply char by 8.
000B68  3  26 rr        	rol fntaddr+1
000B6A  3  06 rr        	asl fntaddr
000B6C  3  26 rr        	rol fntaddr+1
000B6E  3  06 rr        	asl fntaddr
000B70  3  26 rr        	rol fntaddr+1
000B72  3               
000B72  3  A5 rr        	lda fntaddr
000B74  3  18           	clc
000B75  3  69 B0        	adc #<(FONT-256)
000B77  3  85 rr        	sta fntaddr		; that's the low byte.
000B79  3  A5 rr        	lda fntaddr+1
000B7B  3  69 1A        	adc #>(FONT-256)
000B7D  3  85 rr        	sta fntaddr+1		; add displacement.
000B7F  3               pchark:
000B7F  3  20 11 0B     	jsr gprad		; get screen address.
000B82  3  A2 07        	ldx #7			; lines to write.
000B84  3               pchar0:
000B84  3  A0 00        	ldy #0
000B86  3  B1 rr        	lda (fntaddr),y 	; get image byte.
000B88  3  BC 97 0B     	ldy scrtab,x		; Get rowoffset
000B8B  3               .if iflag
000B8B  3               	eor #$ff
000B8B  3               .endif
000B8B  3  91 rr        	sta (scraddr),y 	; copy to screen.
000B8D  3  E6 rr        	inc fntaddr		; next image byte.
000B8F  3  D0 02        	bne :+
000B91  3  E6 rr        	inc fntaddr+1
000B93  3               :
000B93  3  CA           	dex			; next screen row down.
000B94  3  10 EE        	bpl pchar0		; repeat.
000B96  3  60           	rts
000B97  3               
000B97  3  E0 C0 A0 80  scrtab:		.byte $e0,$c0,$a0,$80,$60,$40,$20,$00
000B9B  3  60 40 20 00  
000B9F  3               
000B9F  3               ;----------------------------------------------
000B9F  3               
000B9F  3               ; Print attributes, properties and pixels.
000B9F  3               ;
000B9F  3               ; Input:
000B9F  3               ;  A	= tile number
000B9F  3               ;----------------------------------------------
000B9F  3               
000B9F  3               ;.repeat 294
000B9F  3               ;  .byte 0
000B9F  3               ;.endrep
000B9F  3               
000B9F  3               pbpattr:			; entry PUTBLOCK command
000B9F  3  A4 rr        	ldy charx
000BA1  3  84 rr        	sty dispx
000BA3  3  A4 rr        	ldy chary
000BA5  3  84 rr        	sty dispy
000BA7  3               pattr:
000BA7  3               .if aflag
000BA7  3               	pha
000BA7  3               	jsr wbloc		; save blockinfo
000BA7  3               	pla
000BA7  3               .endif
000BA7  3               
000BA7  3               pattr2:
000BA7  3  85 63        	sta z80_b		; store cell in b register for now.
000BA9  3  AA           	tax
000BAA  3  BD F4 1A     	lda bprop,x 		; block properties.
000BAD  3  85 62        	sta z80_c
000BAF  3  C9 08        	cmp #COLECT
000BB1  3  D0 05        	bne :+
000BB3  3  A5 63        	lda z80_b
000BB5  3  8D C6 0B     	sta colpatt
000BB8  3               :
000BB8  3  20 34 0B     	jsr pradd 		; get property buffer address.
000BBB  3  A5 62        	lda z80_c
000BBD  3  A0 00        	ldy #0
000BBF  3  91 rr        	sta (bufaddr),y 	; write property.
000BC1  3  A5 63        	lda z80_b 		; restore cell.
000BC3  3  4C C7 0B     	jmp panp
000BC6  3               ; Print attributes, no properties.
000BC6  3               
000BC6  3               ;.repeat 263
000BC6  3               ; .byte 0
000BC6  3               ;.endrep
000BC6  3               
000BC6  3  00           colpatt:	.byte 0
000BC7  3               
000BC7  3               panp:
000BC7  3  85 64        	sta z80_e		; displacement in e.
000BC9  3  A9 00        	lda #0
000BCB  3  85 65        	sta z80_d		; no high byte.
000BCD  3  06 64        	asl z80_e  		; multiply char by 8.
000BCF  3  26 65        	rol z80_d
000BD1  3  06 64        	asl z80_e
000BD3  3  26 65        	rol z80_d
000BD5  3  06 64        	asl z80_e
000BD7  3  26 65        	rol z80_d
000BD9  3  18           	clc
000BDA  3  A5 64        	lda z80_e
000BDC  3  69 EC        	adc #<chgfx 		; address of graphics.
000BDE  3  85 rr        	sta tileaddr
000BE0  3  A5 65        	lda z80_d
000BE2  3  69 1A        	adc #>chgfx
000BE4  3  85 rr        	sta tileaddr+1
000BE6  3  20 11 0B     	jsr gprad 		; get screen address.
000BE9  3  A2 07        	ldx #7			; number of pixel rows to write.
000BEB  3               panp0:
000BEB  3  A0 00        	ldy #0
000BED  3  B1 rr        	lda (tileaddr),y 	; get image byte.
000BEF  3               .if iflag
000BEF  3               	eor #$ff		; Invert
000BEF  3               .endif
000BEF  3  BC 97 0B     	ldy scrtab,x
000BF2  3  91 rr        	sta (scraddr),y 	; copy to screen.
000BF4  3  E6 rr        	inc tileaddr 		; next image byte.
000BF6  3  D0 02        	bne :+
000BF8  3  E6 rr        	inc tileaddr+1
000BFA  3               :
000BFA  3  CA           	dex	 		; repeat for 8 pixel rows.
000BFB  3  10 EE        	bpl panp0
000BFD  3  E6 rr        	inc dispx 		; move along one.
000BFF  3  E6 rr        	inc charx
000C01  3  60           	rts
000C02  3               
000C02  3               ;----------------------------------------------
000C02  3               ; Write block
000C02  3               ;----------------------------------------------
000C02  3               
000C02  3               .if aflag
000C02  3               wbloc:
000C02  3               	ldy #3
000C02  3               	sta (pbptr),y		; store block number
000C02  3               	dey
000C02  3               	lda dispx
000C02  3               	sta (pbptr),y		; write x position of block.
000C02  3               	dey
000C02  3               	lda dispy
000C02  3               	sta (pbptr),y		; write y position of block.
000C02  3               	dey
000C02  3               	lda scno
000C02  3               	sta (pbptr),y		; write screen.
000C02  3               	clc			; point to next free location
000C02  3               	lda pbptr
000C02  3               	adc #4
000C02  3               	sta pbptr
000C02  3               	bcc :+
000C02  3               	inc pbptr+1
000C02  3               :
000C02  3               	rts
000C02  3               .endif
000C02  3               
000C02  3               ;----------------------------------------------
000C02  3               ; Print character pixels, no more.
000C02  3               ;
000C02  3               ; Input:
000C02  3               ;  A	= character to print
000C02  3               ;----------------------------------------------
000C02  3               
000C02  3               pchr:
000C02  3  20 60 0B     	jsr pchar 		; show character in accumulator.
000C05  3  E6 rr        	inc dispx		; move along one.
000C07  3  60           	rts
000C08  3               
000C08  3               ;----------------------------------------------------
000C08  3               ; Shifter sprite routine for objects.
000C08  3               ;----------------------------------------------------
000C08  3               
000C08  3               .if oflag
000C08  3               sprit7:
000C08  3               	lda z80_b
000C08  3               	beq sprit0
000C08  3               	sta z80_a
000C08  3               sprit3:
000C08  3               	lsr spr			; shift into position.
000C08  3               	ror spr+1
000C08  3               	ror spr+2
000C08  3               	dec z80_a		; one less iteration.
000C08  3               	bne sprit3
000C08  3               sprit0:
000C08  3               	rts 			; now apply to screen.
000C08  3               
000C08  3               ;----------------------------------------------------
000C08  3               ; Draw sprite
000C08  3               ;----------------------------------------------------
000C08  3               
000C08  3               sprite:
000C08  3               	stx xtmp		; Save X-reg
000C08  3               	jsr scadd 		; get screen address in scraddr.
000C08  3               
000C08  3               	lda dispx 		; x position.
000C08  3               	and #7 			; position straddling cells.
000C08  3               	sta z80_b		; store in b register.
000C08  3               
000C08  3               	lda z80_l		; store sprite graphic address.
000C08  3               	sta sprit1+1
000C08  3               	sta sprit2+1
000C08  3               	lda z80_h
000C08  3               	sta sprit1+2
000C08  3               	sta sprit2+2
000C08  3               
000C08  3               	ldx #0			; pixel height.
000C08  3               	ldy #0
000C08  3               sprit1:
000C08  3               	lda objdta,x		; fetch first byte.
000C08  3               	sta spr
000C08  3               	inx
000C08  3               sprit2:
000C08  3               	lda objdta,x
000C08  3               	sta spr+1
000C08  3               
000C08  3               	lda #0
000C08  3               	sta spr+2
000C08  3               	jsr sprit7		; shift sprite
000C08  3               
000C08  3               	dex
000C08  3               	lda spr			; fetch graphic.
000C08  3               	ldy spritetab,x
000C08  3               	eor (scraddr),y		; merge with screen image.
000C08  3               	sta (scraddr),y		; write to screen.
000C08  3               	inx			; next screen byte.
000C08  3               
000C08  3               	lda spr+1		; fetch graphic.
000C08  3               	ldy spritetab,x
000C08  3               	eor (scraddr),y		; merge with screen image.
000C08  3               	sta (scraddr),y		; write to screen.
000C08  3               	iny
000C08  3               
000C08  3               	lda spr+2		; fetch graphic.
000C08  3               	eor (scraddr),y		; merge with screen image.
000C08  3               	sta (scraddr),y		; write to screen.
000C08  3               
000C08  3               	inx			; next source byte.
000C08  3               	cpx #16
000C08  3               	bne :+
000C08  3               	inc scraddr+1
000C08  3               :
000C08  3               	cpx #32
000C08  3               	bne sprit1		; repeat
000C08  3               
000C08  3               	ldx xtmp		; retreive X-reg
000C08  3               	rts
000C08  3               
000C08  3               spritetab:
000C08  3               	.byte $00,$01,$20,$21,$40,$41,$60,$61
000C08  3               	.byte $80,$81,$a0,$a1,$c0,$c1,$e0,$e1
000C08  3               	.byte $00,$01,$20,$21,$40,$41,$60,$61
000C08  3               	.byte $80,$81,$a0,$a1,$c0,$c1,$e0,$e1
000C08  3               
000C08  3               spr:	.byte 0,0,0
000C08  3               
000C08  3               ;xtmp:	.byte 0
000C08  3               .endif
000C08  3               
000C08  3               ;-----------------------------------------------------------
000C08  3               ; Get room address.
000C08  3               ;-----------------------------------------------------------
000C08  3               
000C08  3               ;.repeat 273
000C08  3               ;  .byte 0
000C08  3               ;.endrep
000C08  3               
000C08  3               groom:
000C08  3  A6 rr        	ldx scno 		; screen number.
000C0A  3  A0 00        	ldy #0
000C0C  3               groomx:
000C0C  3  A9 79        	lda #<scdat 		; pointer to screens.
000C0E  3  85 66        	sta z80_l
000C10  3  A9 1B        	lda #>scdat
000C12  3  85 67        	sta z80_h
000C14  3               groom1:
000C14  3  E0 00        	cpx #0			; is it the first one?
000C16  3  F0 15        	beq groom0 		; no more screens to skip.
000C18  3               
000C18  3  18           	clc
000C19  3  A5 66        	lda z80_l
000C1B  3  79 79 1B     	adc scdat,y 		; low byte of screen size.
000C1E  3  85 66        	sta z80_l
000C20  3  C8           	iny			; point to high byte.
000C21  3  A5 67        	lda z80_h
000C23  3  79 79 1B     	adc scdat,y 		; high byte of screen size.
000C26  3  85 67        	sta z80_h
000C28  3  C8           	iny			; next address.
000C29  3               
000C29  3  CA           	dex 			; one less iteration.
000C2A  3  4C 14 0C     	jmp groom1 		; loop until we reach the end.
000C2D  3               groom0:
000C2D  3  AD 84 1B     	lda numsc 		; add displacement.
000C30  3  0A           	asl a
000C31  3  18           	clc			; add double displacement to address.
000C32  3  65 66        	adc z80_l
000C34  3  85 66        	sta z80_l
000C36  3  A5 67        	lda z80_h
000C38  3  69 00        	adc #0
000C3A  3  85 67        	sta z80_h
000C3C  3  60           	rts
000C3D  3               
000C3D  3               ;-----------------------------------------------------------
000C3D  3               ; Draw present room.
000C3D  3               ;-----------------------------------------------------------
000C3D  3               
000C3D  3               droom:
000C3D  3  AD 49 06     	lda wintop 		; window top.
000C40  3  85 rr        	sta dispy		; set cursor y position.
000C42  3               droom2:
000C42  3  20 08 0C     	jsr groom 		; get address of current room.
000C45  3  A9 00        	lda #0	 		; zero in accumulator.
000C47  3  85 rr        	sta comcnt 		; reset compression counter.
000C49  3  AD 4B 06     	lda winhgt 		; height of window.
000C4C  3  85 rr        	sta rrow		; set row counter
000C4E  3               droom0:
000C4E  3  AD 4A 06     	lda winlft 		; window left edge.
000C51  3  85 rr        	sta dispx 		; set cursor x position.
000C53  3  AD 4C 06     	lda winwid 		; width of window.
000C56  3  85 rr        	sta rcol		; set column counter
000C58  3               droom1:
000C58  3  20 69 0C     	jsr flbyt 		; decompress next byte on the fly.
000C5B  3  20 A7 0B     	jsr pattr2 		; show attributes and block.
000C5E  3  C6 rr        	dec rcol		; one less column.
000C60  3  D0 F6        	bne droom1 		; repeat for entire line.
000C62  3  E6 rr        	inc dispy		; move down one line.
000C64  3  C6 rr        	dec rrow 		; one less row.
000C66  3  D0 E6        	bne droom0 		; repeat for all rows.
000C68  3  60           	rts
000C69  3               
000C69  3               ;rcol:	.byte 0
000C69  3               ;rrow:	.byte 0
000C69  3               
000C69  3               ;----------------------------------------------
000C69  3               ; Decompress bytes on-the-fly.
000C69  3               ;----------------------------------------------
000C69  3               
000C69  3               flbyt:
000C69  3  A5 rr        	lda comcnt 		; compression counter.
000C6B  3  D0 21        	bne flbyt1		; any more to decompress?  yes.
000C6D  3               
000C6D  3  A0 00        	ldy #0
000C6F  3  B1 66        	lda (z80_hl),y 		; fetch next byte.
000C71  3  E6 66        	inc z80_l 		; point to next cell.
000C73  3  D0 02        	bne :+
000C75  3  E6 67        	inc z80_h
000C77  3               :
000C77  3  C9 FF        	cmp #255 		; is this byte a control code?
000C79  3  F0 01        	beq :+
000C7B  3  60           	rts 			; no, this byte is uncompressed.
000C7C  3               :
000C7C  3  B1 66        	lda (z80_hl),y 		; fetch byte type.
000C7E  3  85 rr        	sta combyt 		; set up the type.
000C80  3  E6 66        	inc z80_l 		; point to quantity.
000C82  3  D0 02        	bne :+
000C84  3  E6 67        	inc z80_h
000C86  3               :
000C86  3  B1 66        	lda (z80_hl),y 		; get quantity.
000C88  3  E6 66        	inc z80_l 		; point to next byte.
000C8A  3  D0 02        	bne :+
000C8C  3  E6 67        	inc z80_h
000C8E  3               :
000C8E  3               flbyt1:
000C8E  3  85 rr        	sta comcnt 		; store new quantity.
000C90  3  C6 rr        	dec comcnt		; one less.
000C92  3  A5 rr        	lda combyt 		; byte to expand.
000C94  3  60           	rts
000C95  3               
000C95  3               ;combyt:	.byte 0			; byte type compressed.
000C95  3               ;comcnt:	.byte 0			; compression counter.
000C95  3               
000C95  3               ;------------------------------------------
000C95  3               ; Ladder down check.
000C95  3               ;
000C95  3               ; Input:
000C95  3               ;  IX = sprite pointer
000C95  3               ;------------------------------------------
000C95  3               
000C95  3               .if lflag
000C95  3               laddd:
000C95  3               	ldy #9
000C95  3               	lda (z80_ix),y		; x coordinate.
000C95  3               	sta dispx
000C95  3               
000C95  3               	ldy #8
000C95  3               	lda (z80_ix),y		; y coordinate.
000C95  3               	and #254		; make it even.
000C95  3               	sta (z80_ix),y 		; reset it.
000C95  3               	clc 			; look down 16 pixels.
000C95  3               numsp5:
000C95  3               	adc #SPR_HGT
000C95  3               	sta dispy		; coords in dispx,dispy.
000C95  3               	jmp laddv
000C95  3               
000C95  3               ;------------------------------------------
000C95  3               ; Ladder up check.
000C95  3               ;
000C95  3               ; Input:
000C95  3               ;  IX = sprite pointer
000C95  3               ;
000C95  3               ; Output:
000C95  3               ;  A  = 0 is ok, A <>0 is not ok
000C95  3               ;------------------------------------------
000C95  3               
000C95  3               laddu:
000C95  3               	ldy #9
000C95  3               	lda (z80_ix),y		; x coordinate.
000C95  3               	sta dispx
000C95  3               
000C95  3               	ldy #8
000C95  3               	lda (z80_ix),y		; y coordinate.
000C95  3               	and #254 		; make it even.
000C95  3               	sta (z80_ix),y		; reset it.
000C95  3               	clc 			; look 2 pixels above feet.
000C95  3               numsp6:
000C95  3               	adc #SPR_HGT-2
000C95  3               	sta dispy		; coords in dispx,dispy.
000C95  3               laddv:
000C95  3               	jsr tstbl 		; get map address.
000C95  3               	jsr ldchk 		; standard ladder check.
000C95  3               	beq :+
000C95  3               	rts 			; no way through.
000C95  3               :
000C95  3               	inc bufaddr 		; look right one cell.
000C95  3               	bne :+
000C95  3               	inc bufaddr+1
000C95  3               :
000C95  3               	jsr ldchk 		; do the check.
000C95  3               	beq :+
000C95  3               	rts 			; impassable.
000C95  3               :
000C95  3               	lda dispx 		; y coordinate.
000C95  3               	and #7 			; position straddling block cells.
000C95  3               	bne :+
000C95  3               	rts 			; no more checks needed.
000C95  3               :
000C95  3               	inc bufaddr 		; look to third cell.
000C95  3               	bne :+
000C95  3               	inc bufaddr+1
000C95  3               :
000C95  3               	jsr ldchk 		; do the check.
000C95  3               	rts  			; return with zero flag set accordingly.
000C95  3               .endif
000C95  3               
000C95  3               ;---------------------------------------------------------
000C95  3               ; Can go up check.
000C95  3               ;
000C95  3               ; Input:
000C95  3               ;  IX = sprite pointer
000C95  3               ;
000C95  3               ; Output:
000C95  3               ;  A  = 0 is ok, A <>0 is not ok
000C95  3               ;---------------------------------------------------------
000C95  3               
000C95  3               cangu:
000C95  3  A0 09        	ldy #9
000C97  3  B1 68        	lda (z80_ix),y		; x coordinate.
000C99  3  85 rr        	sta dispx
000C9B  3  A0 08        	ldy #8
000C9D  3  B1 68        	lda (z80_ix),y 		; y coordinate.
000C9F  3  38           	sec
000CA0  3  E9 02        	sbc #2
000CA2  3  85 rr        	sta dispy		; coords in dispx,dispy.
000CA4  3  20 3F 0F     	jsr tstbl 		; get map address.
000CA7  3  20 57 0E     	jsr lrchk 		; standard left/right check.
000CAA  3  F0 01        	beq :+
000CAC  3  60           	rts			; no way through.
000CAD  3               :
000CAD  3  E6 rr        	inc bufaddr		; look right one cell.
000CAF  3  D0 02        	bne :+
000CB1  3  E6 rr        	inc bufaddr+1
000CB3  3               :
000CB3  3  20 57 0E     	jsr lrchk 		; do the check.
000CB6  3  F0 01        	beq :+
000CB8  3  60           	rts			; impassable.
000CB9  3               :
000CB9  3  A5 rr        	lda dispx		; x coordinate.
000CBB  3  29 07        	and #7			; position straddling block cells.
000CBD  3  D0 01        	bne :+
000CBF  3  60           	rts			; no more checks needed.
000CC0  3               :
000CC0  3  E6 rr        	inc bufaddr		; look to third cell.
000CC2  3  D0 02        	bne :+
000CC4  3  E6 rr        	inc bufaddr+1
000CC6  3               :
000CC6  3  20 57 0E     	jsr lrchk		; do the check.
000CC9  3  60           	rts 			; return with zero flag set accordingly.
000CCA  3               
000CCA  3               ;---------------------------------------------------------
000CCA  3               ; Can go down check.
000CCA  3               ;
000CCA  3               ; Input:
000CCA  3               ;  IX = sprite pointer
000CCA  3               ;
000CCA  3               ; Output:
000CCA  3               ;  A  = 0 is ok, A <>0 is not ok
000CCA  3               ;---------------------------------------------------------
000CCA  3               
000CCA  3               ;.repeat 264
000CCA  3               ;  .byte 0
000CCA  3               ;.endrep
000CCA  3               
000CCA  3               cangd:
000CCA  3  A0 09        	ldy #9
000CCC  3  B1 68        	lda (z80_ix),y 		; x coordinate.
000CCE  3  85 rr        	sta dispx
000CD0  3  A0 08        	ldy #8
000CD2  3  B1 68        	lda (z80_ix),y		; y coordinate.
000CD4  3  18           	clc
000CD5  3               numsp3:
000CD5  3  69 10        	adc #SPR_HGT 		; look down 16 pixels.
000CD7  3  85 rr        	sta dispy		; coords in dispx,dispy.
000CD9  3  20 3F 0F     	jsr tstbl 		; get map address.
000CDC  3  20 6C 0E     	jsr plchk 		; block, platform check.
000CDF  3  F0 01        	beq :+
000CE1  3  60           	rts			; no way through.
000CE2  3               :
000CE2  3  E6 rr        	inc bufaddr		; look right one cell.
000CE4  3  D0 02        	bne :+
000CE6  3  E6 rr        	inc bufaddr+1
000CE8  3               :
000CE8  3  20 6C 0E     	jsr plchk		; block, platform check.
000CEB  3  F0 01        	beq :+
000CED  3  60           	rts			; impassable.
000CEE  3               :
000CEE  3  A5 rr        	lda dispx		; x coordinate.
000CF0  3  29 07        	and #7			; position straddling block cells.
000CF2  3  D0 01        	bne :+
000CF4  3  60           	rts			; no more checks needed.
000CF5  3               :
000CF5  3  E6 rr        	inc bufaddr		; look to third cell.
000CF7  3  D0 02        	bne :+
000CF9  3  E6 rr        	inc bufaddr+1
000CFB  3               :
000CFB  3  20 6C 0E     	jsr plchk		; block, platform check.
000CFE  3  60           	rts			; return with zero flag set accordingly.
000CFF  3               
000CFF  3               ;---------------------------------------------------------
000CFF  3               ; Can go left check.
000CFF  3               ;
000CFF  3               ; Input:
000CFF  3               ;  IX = sprite pointer
000CFF  3               ;
000CFF  3               ; Output:
000CFF  3               ;  A  = 0 is ok, A <>0 is not ok
000CFF  3               ;---------------------------------------------------------
000CFF  3               
000CFF  3               cangl:
000CFF  3  A0 08        	ldy #8
000D01  3  B1 68        	lda (z80_ix),y 		; y coordinate.
000D03  3  85 rr        	sta dispy
000D05  3  A0 09        	ldy #9
000D07  3  B1 68        	lda (z80_ix),y 		; x coordinate.
000D09  3  38           	sec
000D0A  3  E9 02        	sbc #2			; look left 2 pixels.
000D0C  3  85 rr        	sta dispx		; coords in dispx,dispy.
000D0E  3  4C 30 0E     	jmp cangh		; test if we can go there.
000D11  3               
000D11  3               ;---------------------------------------------------------
000D11  3               ; Can go right check.
000D11  3               ;
000D11  3               ; Input:
000D11  3               ;  IX = sprite pointer
000D11  3               ;
000D11  3               ; Output:
000D11  3               ;  A  = 0 is ok, A <>0 is not ok
000D11  3               ;---------------------------------------------------------
000D11  3               
000D11  3  00 00 00 00  .repeat 272
000D15  3  00 00 00 00  
000D19  3  00 00 00 00  
000E21  3                 .byte 0
000E21  3               .endrep
000E21  3               
000E21  3               cangr:
000E21  3  A0 08        	ldy #8
000E23  3  B1 68        	lda (z80_ix),y		; y coordinate.
000E25  3  85 rr        	sta dispy
000E27  3  A0 09        	ldy #9
000E29  3  B1 68        	lda (z80_ix),y		; x coordinate.
000E2B  3  18           	clc
000E2C  3  69 10        	adc #16			; look right 16 pixels.
000E2E  3  85 rr        	sta dispx		; coords in dispx,dispy.
000E30  3               cangh:
000E30  3               cangh2:
000E30  3  A9 03        	lda #(SPR_HGT/8+1)	; default rows to write.
000E32  3  85 63        	sta z80_b
000E34  3  A5 rr        	lda dispy		; y position.
000E36  3  29 07        	and #7			; does x straddle cells?
000E38  3  D0 02        	bne cangh0		; yes, loop counter is good.
000E3A  3  C6 63        	dec z80_b		; one less row to write.
000E3C  3               cangh0:
000E3C  3  20 3F 0F     	jsr tstbl		; get map address.
000E3F  3               cangh1:
000E3F  3  20 57 0E     	jsr lrchk		; standard left/right check.
000E42  3  F0 01        	beq :+
000E44  3  60           	rts			; no way through.
000E45  3               :
000E45  3  48           	pha
000E46  3  18           	clc
000E47  3  A5 rr        	lda bufaddr
000E49  3  69 20        	adc #32			; look down.
000E4B  3  85 rr        	sta bufaddr
000E4D  3  90 02        	bcc :+
000E4F  3  E6 rr        	inc bufaddr+1
000E51  3               :
000E51  3  68           	pla
000E52  3               
000E52  3  C6 63        	dec z80_b
000E54  3  D0 E9        	bne cangh1
000E56  3  60           	rts
000E57  3               
000E57  3               ;-------------------------------------
000E57  3               ; Check left/right movement is okay.
000E57  3               ;
000E57  3               ; Input:
000E57  3               ;  bufaddr = MAP + x/8 + y/8*32
000E57  3               ;
000E57  3               ; Output:
000E57  3               ;  A  = 0 is ok, A <>0 is not ok
000E57  3               ;-------------------------------------
000E57  3               
000E57  3               lrchk:
000E57  3  A0 00        	ldy #0
000E59  3  B1 rr        	lda (bufaddr),y		; fetch map cell.
000E5B  3  C9 02        	cmp #WALL 		; is it passable?
000E5D  3  F0 0A        	beq lrchkx		; no.
000E5F  3               
000E5F  3  C9 04        	cmp #FODDER		; fodder has to be dug.
000E61  3  F0 06        	beq lrchkx		; not passable.
000E63  3  A9 00        	lda #0
000E65  3  60           	rts
000E66  3               
000E66  3               ;--------------------------------------------------------------
000E66  3               ; Called by mmenu
000E66  3               ;--------------------------------------------------------------
000E66  3               
000E66  3               always:
000E66  3  A9 FF        	lda #255		; report it as okay.
000E68  3  60           	rts
000E69  3               
000E69  3               lrchkx:
000E69  3  A9 01        	lda #1 			; reset all bits.
000E6B  3  60           	rts
000E6C  3               
000E6C  3               
000E6C  3               ;--------------------------------------------------------------
000E6C  3               ; Check platform or solid item is not in way.
000E6C  3               ;
000E6C  3               ; Input:
000E6C  3               ;  bufaddr = MAP + x/8 + y/8*32
000E6C  3               ;
000E6C  3               ; Output:
000E6C  3               ;  A  = 0 is ok, A <>0 is not ok
000E6C  3               ;--------------------------------------------------------------
000E6C  3               
000E6C  3               plchk:
000E6C  3  A0 00        	ldy #0
000E6E  3  B1 rr        	lda (bufaddr),y 	; fetch map cell.
000E70  3  C9 02        	cmp #WALL 		; is it passable?
000E72  3  F0 F5        	beq lrchkx		; no.
000E74  3               .if pflag .or dflag
000E74  3               	cmp #FODDER		; fodder has to be dug.
000E74  3               	beq lrchkx		; not passable.
000E74  3               .endif
000E74  3  C9 01        	cmp #PLATFM		; platform is solid.
000E76  3  F0 03        	beq plchkx		; not passable.
000E78  3               .if lflag
000E78  3               	cmp #LADDER		; is it a ladder?
000E78  3               	beq lrchkx		; on ladder, deny movement.
000E78  3               .endif
000E78  3               plchk0:
000E78  3  A9 00        	lda #0			; report as ok
000E7A  3  60           	rts
000E7B  3               plchkx:
000E7B  3  A5 rr        	lda dispy		; x coordinate.
000E7D  3  29 07        	and #7			; position straddling blocks.
000E7F  3  F0 E8        	beq lrchkx		; on platform, deny movement.
000E81  3  4C 78 0E     	jmp plchk0
000E84  3               
000E84  3               ;--------------------------------------------------------------
000E84  3               ; Check ladder is available.
000E84  3               ;
000E84  3               ; Input:
000E84  3               ;  bufaddr = MAP + x/8 + y/8*32
000E84  3               ;
000E84  3               ; Output:
000E84  3               ;  A  = 0 is ok, A <>0 is not ok
000E84  3               ;--------------------------------------------------------------
000E84  3               
000E84  3               .if lflag
000E84  3               ldchk:
000E84  3               	ldy #0
000E84  3               	lda (bufaddr),y 	; fetch cell.
000E84  3               	cmp #LADDER 		; is it a ladder?
000E84  3               	beq :+
000E84  3               	lda #1
000E84  3               	rts  			; return with zero flag set accordingly.
000E84  3               :
000E84  3               	lda #0
000E84  3               	rts
000E84  3               .endif
000E84  3               
000E84  3               ;--------------------------------------------------------------
000E84  3               ; Get collectables.
000E84  3               ;--------------------------------------------------------------
000E84  3               
000E84  3               .if cflag
000E84  3               getcol:
000E84  3                       lda #COLECT             ; collectable blocks.
000E84  3                       sta z80_b
000E84  3                       jsr tded                ; test for collectable blocks.
000E84  3                       cmp z80_b               ; did we find one?
000E84  3                       beq :+
000E84  3                       rts                     ; none were found, job done.
000E84  3               :
000E84  3                       jsr gtblk               ; get block.
000E84  3                       jsr evnt20              ; collected block event.
000E84  3                       jmp getcol              ; repeat until none left.
000E84  3               
000E84  3               ; Get collectable block.
000E84  3               
000E84  3               gtblk:
000E84  3               	ldy #0
000E84  3               	lda (bufaddr),y
000E84  3               	sta z80_a
000E84  3                       lda #0
000E84  3                       sta (bufaddr),y		; make it empty now.
000E84  3               
000E84  3               	lda bufaddr		; set dispx
000E84  3               	and #31
000E84  3               	sta dispx
000E84  3               
000E84  3               	lda bufaddr+1		; Set dispy
000E84  3               	sec
000E84  3               	sbc #>MAP
000E84  3               	sta bufaddr+1
000E84  3               	asl bufaddr
000E84  3               	rol bufaddr+1
000E84  3               	asl bufaddr
000E84  3               	rol bufaddr+1
000E84  3               	asl bufaddr
000E84  3               	rol bufaddr+1
000E84  3               	lda bufaddr+1
000E84  3               	sta dispy
000E84  3               
000E84  3               	lda colpatt		; get blocknr
000E84  3               	sta z80_e		; displacement in e.
000E84  3               	lda #0
000E84  3               	sta z80_d		; no high byte.
000E84  3               	asl z80_e  		; multiply char by 8.
000E84  3               	rol z80_d
000E84  3               	asl z80_e
000E84  3               	rol z80_d
000E84  3               	asl z80_e
000E84  3               	rol z80_d
000E84  3               	clc
000E84  3               	lda z80_e
000E84  3               	adc #<chgfx 		; address of graphics.
000E84  3               	sta tileaddr
000E84  3               	lda z80_d
000E84  3               	adc #>chgfx
000E84  3               	sta tileaddr+1
000E84  3               	jsr gprad 		; get screen address.
000E84  3               	ldx #7			; number of pixel rows to write.
000E84  3               gtblk0:
000E84  3               	ldy #0
000E84  3               	lda (tileaddr),y 	; get image byte.
000E84  3               	ldy scrtab,x
000E84  3               	eor (scraddr),y 	; XOR tile on screen
000E84  3               	sta (scraddr),y 	; copy to screen.
000E84  3               	inc tileaddr 		; next image byte.
000E84  3               	bne :+
000E84  3               	inc tileaddr+1
000E84  3               :
000E84  3               	dex	 		; repeat for 8 pixel rows.
000E84  3               	bpl gtblk0
000E84  3               	rts
000E84  3               .endif
000E84  3               
000E84  3               ;--------------------------------------------------------------
000E84  3               ; Touched deadly block check.
000E84  3               ; returns with DEADLY (must be non-zero) in accumulator if true.
000E84  3               ;
000E84  3               ; Input:
000E84  3               ;  IX = sprite address
000E84  3               ;
000E84  3               ; Output:
000E84  3               ;  A  = 0 is ok, A=5 is not ok
000E84  3               ;--------------------------------------------------------------
000E84  3               
000E84  3               tded:
000E84  3  A0 08        	ldy #8
000E86  3  B1 68        	lda (z80_ix),y 		; y coordinate.
000E88  3  85 rr        	sta dispy
000E8A  3  C8           	iny
000E8B  3  B1 68        	lda (z80_ix),y 		; x coordinate.
000E8D  3  85 rr        	sta dispx		; coords in dispx,dispy.
000E8F  3  20 3F 0F     	jsr tstbl		; get map address.
000E92  3  48           	pha
000E93  3  A9 1F        	lda #31			; default distance to next line down.
000E95  3  85 64        	sta z80_e
000E97  3  68           	pla
000E98  3  C5 63        	cmp z80_b		; is this the required block?
000E9A  3  D0 01        	bne :+
000E9C  3  60           	rts			; yes.
000E9D  3               :
000E9D  3  E6 rr        	inc bufaddr 		; next cell.
000E9F  3  D0 02        	bne :+
000EA1  3  E6 rr        	inc bufaddr+1
000EA3  3               :
000EA3  3  A0 00        	ldy #0
000EA5  3  B1 rr        	lda (bufaddr),y		; fetch type.
000EA7  3  C5 63        	cmp z80_b 		; is this deadly/custom?
000EA9  3  D0 01        	bne :+
000EAB  3  60           	rts			; yes.
000EAC  3               :
000EAC  3  A5 rr        	lda dispx		; horizontal position.
000EAE  3  85 62        	sta z80_c 		; store column in c register.
000EB0  3  29 07        	and #7			; is it straddling cells?
000EB2  3  D0 03        	bne :+
000EB4  3  4C C8 0E     	jmp tded0		; no.
000EB7  3               :
000EB7  3  E6 rr        	inc bufaddr 		; last cell.
000EB9  3  D0 02        	bne :+
000EBB  3  E6 rr        	inc bufaddr+1
000EBD  3               :
000EBD  3  A0 00        	ldy #0
000EBF  3  B1 rr        	lda (bufaddr),y 	; fetch type.
000EC1  3  C5 63        	cmp z80_b		; is this the block?
000EC3  3  D0 01        	bne :+
000EC5  3  60           	rts			; yes.
000EC6  3               :
000EC6  3  C6 64        	dec z80_e		; one less cell to next row down.
000EC8  3               tded0:
000EC8  3  18           	clc 			; point to next row.
000EC9  3  A5 rr        	lda bufaddr
000ECB  3  65 64        	adc z80_e
000ECD  3  85 rr        	sta bufaddr
000ECF  3  90 02        	bcc :+
000ED1  3  E6 rr        	inc bufaddr+1
000ED3  3               :
000ED3  3  A0 00        	ldy #0
000ED5  3  B1 rr        	lda (bufaddr),y		; fetch left cell block.
000ED7  3  C5 63        	cmp z80_b		; is this fatal?
000ED9  3  D0 01        	bne :+
000EDB  3  60           	rts			; yes.
000EDC  3               :
000EDC  3  E6 rr        	inc bufaddr 		; next cell.
000EDE  3  D0 02        	bne :+
000EE0  3  E6 rr        	inc bufaddr+1
000EE2  3               :
000EE2  3  A0 00        	ldy #0
000EE4  3  B1 rr        	lda (bufaddr),y 	; fetch type.
000EE6  3  C5 63        	cmp z80_b		; is this fatal?
000EE8  3  D0 01        	bne :+
000EEA  3  60           	rts			; yes.
000EEB  3               :
000EEB  3  A5 62        	lda z80_c		; horizontal position.
000EED  3  29 07        	and #7			; is it straddling cells?
000EEF  3  D0 03        	bne :+
000EF1  3  4C 03 0F     	jmp tded1 		; no.
000EF4  3               :
000EF4  3  E6 rr        	inc bufaddr		; last cell.
000EF6  3  D0 02        	bne :+
000EF8  3  E6 rr        	inc bufaddr+1
000EFA  3               :
000EFA  3  A0 00        	ldy #0
000EFC  3  B1 rr        	lda (bufaddr),y		; fetch type.
000EFE  3  C5 63        	cmp z80_b		; is this fatal?
000F00  3  D0 01        	bne :+
000F02  3  60           	rts			; yes.
000F03  3               :
000F03  3               tded1:
000F03  3  A5 rr        	lda dispy		; vertical position.
000F05  3  29 07        	and #7 			; is it straddling cells?
000F07  3  D0 01        	bne :+
000F09  3  60           	rts			; no, job done.
000F0A  3               :
000F0A  3  18           	clc			; point to next row.
000F0B  3  A5 rr        	lda bufaddr
000F0D  3  65 64        	adc z80_e
000F0F  3  85 rr        	sta bufaddr
000F11  3  90 02        	bcc :+
000F13  3  E6 rr        	inc bufaddr+1
000F15  3               :
000F15  3  A0 00        	ldy #0
000F17  3  B1 rr        	lda (bufaddr),y 	; fetch left cell block.
000F19  3  C5 63        	cmp z80_b		; is this fatal?
000F1B  3  D0 01        	bne :+
000F1D  3  60           	rts			; yes.
000F1E  3               :
000F1E  3  E6 rr        	inc bufaddr		; next cell.
000F20  3  D0 02        	bne :+
000F22  3  E6 rr        	inc bufaddr+1
000F24  3               :
000F24  3  A0 00        	ldy #0
000F26  3  B1 rr        	lda (bufaddr),y 	; fetch type.
000F28  3  C5 63        	cmp z80_b		; is this fatal?
000F2A  3  D0 01        	bne :+
000F2C  3  60           	rts			; yes.
000F2D  3               :
000F2D  3  A5 62        	lda z80_c		; horizontal position.
000F2F  3  29 07        	and #7			; is it straddling cells?
000F31  3  D0 01        	bne :+
000F33  3  60           	rts			; no.
000F34  3               :
000F34  3  E6 rr        	inc bufaddr		; last cell.
000F36  3  D0 02        	bne :+
000F38  3  E6 rr        	inc bufaddr+1
000F3A  3               :
000F3A  3  A0 00        	ldy #0
000F3C  3  B1 rr        	lda (bufaddr),y		; fetch final type.
000F3E  3  60           	rts 			; return with final type in accumulator.
000F3F  3               
000F3F  3               ;---------------------------------------------------
000F3F  3               ; Fetch block type at (dispx, dispy).
000F3F  3               ;
000F3F  3               ; Output:
000F3F  3               ;  A = block type
000F3F  3               ;---------------------------------------------------
000F3F  3               
000F3F  3               tstbl:
000F3F  3  A5 rr        	lda dispy 		; fetch y coord.
000F41  3  4A           	lsr a			; bufaddr = y/8
000F42  3  4A           	lsr a
000F43  3  4A           	lsr a
000F44  3  85 rr        	sta chary
000F46  3               
000F46  3  85 rr        	sta bufaddr
000F48  3  A9 00        	lda #0
000F4A  3  85 rr        	sta bufaddr+1
000F4C  3               
000F4C  3  06 rr        	asl bufaddr  		; bufaddr = y/8 * 32
000F4E  3  26 rr        	rol bufaddr+1
000F50  3  06 rr        	asl bufaddr
000F52  3  26 rr        	rol bufaddr+1
000F54  3  06 rr        	asl bufaddr
000F56  3  26 rr        	rol bufaddr+1
000F58  3  06 rr        	asl bufaddr
000F5A  3  26 rr        	rol bufaddr+1
000F5C  3  06 rr        	asl bufaddr
000F5E  3  26 rr        	rol bufaddr+1
000F60  3               
000F60  3  A5 rr        	lda dispx		; x/8
000F62  3  4A           	lsr a
000F63  3  4A           	lsr a
000F64  3  4A           	lsr a
000F65  3  85 rr        	sta charx
000F67  3               
000F67  3  18           	clc			; bufaddr = MAP + x/8 + y/8*32
000F68  3  65 rr        	adc bufaddr
000F6A  3  69 00        	adc #<MAP
000F6C  3  85 rr        	sta bufaddr
000F6E  3  A5 rr        	lda bufaddr+1
000F70  3  69 98        	adc #>MAP
000F72  3  85 rr        	sta bufaddr+1
000F74  3               
000F74  3  A0 00        	ldy #0
000F76  3  B1 rr        	lda (bufaddr),y 	; fetch byte there.
000F78  3  60           	rts
000F79  3               
000F79  3               
000F79  3               ;-------------------------------------------------------------------
000F79  3               ; Jump - if we can.
000F79  3               ; Requires initial speed to be set up in accumulator prior to call.
000F79  3               ;
000F79  3               ; Input:
000F79  3               ;  IX = sprite address
000F79  3               ;-------------------------------------------------------------------
000F79  3               
000F79  3               jump:
000F79  3  A0 0D        	ldy #13
000F7B  3  B1 68        	lda (z80_ix),y		; jump table low.
000F7D  3  A0 0E        	ldy #14
000F7F  3  11 68        	ora (z80_ix),y		; jump table high.
000F81  3  F0 01        	beq :+
000F83  3  60           	rts			; already in the air.
000F84  3               :
000F84  3  A9 1E        	lda #>jtab
000F86  3  A0 0E        	ldy #14
000F88  3  91 68        	sta (z80_ix),y		; set jump high.
000F8A  3  A9 B0        	lda #<jtab		; jump table start.
000F8C  3  A0 0D        	ldy #13
000F8E  3  91 68        	sta (z80_ix),y		; set jump low.
000F90  3  60           	rts
000F91  3               
000F91  3               ; Jump table.
000F91  3               
000F91  3               ;jtab:
000F91  3               ;	.byte 248,250,252
000F91  3               ;	.byte 254,254,255
000F91  3               ;	.byte 255,255,0,0
000F91  3               ;	.byte 0,1,1,1,2,2
000F91  3               ;	.byte 4,6,8,8,8,99
000F91  3               
000F91  3               ;------------------------------------------------
000F91  3               ; Random numbers code.
000F91  3               ; Pseudo-random number generator, 8-bit.
000F91  3               ;
000F91  3               ; Output:
000F91  3               ;  RND = random number
000F91  3               ;------------------------------------------------
000F91  3               
000F91  3               random:
000F91  3  A5 rr        	lda seed
000F93  3  F0 05        	beq doEor
000F95  3  0A           	asl a
000F96  3  F0 04        	beq noEor
000F98  3  90 02        	bcc noEor
000F9A  3  49 1D        doEor:	eor #$1d
000F9C  3  85 rr        noEor:	sta seed
000F9E  3  60           	rts
000F9F  3               
000F9F  3  A5 rr        	lda seed		; get last random number.
000FA1  3  0A           	asl a
000FA2  3  0A           	asl a
000FA3  3  18           	clc
000FA4  3  65 rr        	adc seed
000FA6  3  18           	clc
000FA7  3  69 45        	adc #$45
000FA9  3  85 rr        	sta seed		; store new seed.
000FAB  3  85 rr        	sta varrnd		; return number in variable.
000FAD  3  60           	rts
000FAE  3               
000FAE  3               ;--------------------------------------------------------
000FAE  3               ; Keys
000FAE  3               ;
000FAE  3               ; Out: joyval=x65FUDLR (bit cleared if key pressed)
000FAE  3               ;             ||||||||
000FAE  3               ;             |||||||+> Right    KEY 0  - X
000FAE  3               ;             ||||||+-> Left     KEY 1  - Z
000FAE  3               ;             |||||+--> Down     KEY 2  - .
000FAE  3               ;             ||||+---> Up       KEY 3  - ;
000FAE  3               ;             |||+----> Fire1    KEY 4  - SPC
000FAE  3               ;             ||+-----> Fire2    KEY 5  - Q
000FAE  3               ;             |+------> Fire3    KEY 6  - P
000FAE  3               ;             +-------> Not used
000FAE  3               ;
000FAE  3               ;                       Option1  KEY 7  - 1
000FAE  3               ;                       Option2  KEY 8  - 2
000FAE  3               ;                       Option3  KEY 9  - 3
000FAE  3               ;                       Option4  KEY 10 - 4
000FAE  3               ;--------------------------------------------------------
000FAE  3               
000FAE  3               ;              X   Z   .   ;  SPC  Q   P
000FAE  3               ;keys:   .byte $35,$15,$93,$22,$90,$04,$14       ; Keys defined by game designer.
000FAE  3               ;        .byte $21,$11,$01,$92                   ; menu options.
000FAE  3  03 01 02 04  jkeys:  .byte $03,$01,$02,$04,$00,$04,$14       ; Joykey keys
000FB2  3  00 04 14     
000FB5  3  21 11 01 92          .byte $21,$11,$01,$92                   ; menu options.
000FB9  3               
000FB9  3               ;--------------------------------------------------------
000FB9  3               ; Keyboard test routine.
000FB9  3               ;
000FB9  3               ; Input:
000FB9  3               ;  A = key to read, high nibble=row and low nibble=col
000FB9  3               ;
000FB9  3               ; Output:
000FB9  3               ;  carry clr = key pressed
000FB9  3               ;  carry set = key not pressed
000FB9  3               ;--------------------------------------------------------
000FB9  3               
000FB9  3               ktest:
000FB9  3  85 61        	sta z80_a		; save key
000FBB  3               
000FBB  3  4A           	lsr a			; set row
000FBC  3  4A           	lsr a
000FBD  3  4A           	lsr a
000FBE  3  4A           	lsr a
000FBF  3  09 F0        	ora #ScrMode		; don't flip screenmode
000FC1  3  8D 00 B0     	sta KeyRowAddr
000FC4  3               
000FC4  3  A5 61        	lda z80_a
000FC6  3  29 0F        	and #$0f
000FC8  3  AA           	tax
000FC9  3  AD 01 B0     	lda KeyColAddr		; read column
000FCC  3               
000FCC  3  3D D5 0F     	and keymask,x		; check key pressed
000FCF  3  F0 02        	beq pressed
000FD1  3  38           	sec			; key not pressed
000FD2  3  60           	rts
000FD3  3               pressed:
000FD3  3  18           	clc			; key pressed
000FD4  3  60           	rts
000FD5  3               
000FD5  3  01 02 04 08  keymask:	.byte $01,$02,$04,$08,$10,$20
000FD9  3  10 20        
000FDB  3               
000FDB  3               ;-------------------------------------------------------
000FDB  3               ; Joystick and keyboard reading routines.
000FDB  3               ;
000FDB  3               ; contrl = 0, Keyboard
000FDB  3               ;          1, JoyKeyb
000FDB  3               ;          2, JoyMMC
000FDB  3               ;-------------------------------------------------------
000FDB  3               
000FDB  3               joykey:
000FDB  3  A5 rr        	lda contrl 		; control flag.
000FDD  3  C9 01        	cmp #1
000FDF  3  D0 03        	bne :+
000FE1  3  4C FF 0F     	jmp joyjoy 		; read keyboard joystick
000FE4  3               :
000FE4  3  C9 02        	cmp #2
000FE6  3  D0 03        	bne :+
000FE8  3  4C 28 10     	jmp joysin 		; read MMC joystick.
000FEB  3               :
000FEB  3               ; Keyboard controls.
000FEB  3               
000FEB  3  A9 00        	lda #0		 	; zero reading.
000FED  3  85 64        	sta z80_e
000FEF  3               
000FEF  3  A0 06        	ldy #6	 		; address of last key.
000FF1  3               joyke0:
000FF1  3  B9 B1 1E     	lda keys,y 		; get key from table.
000FF4  3  20 B9 0F     	jsr ktest		; being pressed?
000FF7  3  26 64        	rol z80_e 		; rotate into reading.
000FF9  3               
000FF9  3  88           	dey		 	; next key.
000FFA  3  10 F5        	bpl joyke0 		; repeat for all keys.
000FFC  3  4C 10 10     	jmp joyjo1 		; store the value.
000FFF  3               
000FFF  3               ; Keyboard joystick controls.
000FFF  3               
000FFF  3               joyjoy:
000FFF  3  A9 00        	lda #0		 	; zero reading.
001001  3  85 64        	sta z80_e
001003  3               
001003  3  A0 06        	ldy #6	 		; address of last key.
001005  3               joyjo3:
001005  3  B9 AE 0F     	lda jkeys,y 		; get key from table.
001008  3  20 B9 0F     	jsr ktest		; being pressed?
00100B  3  26 64        	rol z80_e 		; rotate into reading.
00100D  3               
00100D  3  88           	dey		 	; next key.
00100E  3  10 F5        	bpl joyjo3 		; repeat for all keys.
001010  3               joyjo1:
001010  3  A5 64        	lda z80_e 		; copy e register to accumulator.
001012  3               joyjo2:
001012  3  85 rr        	sta joyval		; remember value.
001014  3  60           	rts
001015  3               
001015  3               
001015  3               ; AtoMMC joystick controls.
001015  3               
001015  3               ; Set PORTB direction
001015  3               
001015  3               joyinit:
001015  3  A9 FF        	lda #$ff   		; Write value to latch, bits 0-7 input
001017  3  8D 01 B4     	sta DatReg
00101A  3  20 56 10     	jsr interwritedelay
00101D  3  A9 A1        	lda #$a1   		; Write direction in latch to PORTB
00101F  3  8D 00 B4     	sta CmdReg
001022  3               
001022  3               wait_until_not_busy:
001022  3  AD 00 B4     	lda CmdReg
001025  3  30 FB        	bmi wait_until_not_busy
001027  3  60           	rts
001028  3               
001028  3               ; Get PORTB value
001028  3               
001028  3               joysin:
001028  3  A9 A2        	lda #$a2   		; Read value PORTB in latch
00102A  3  8D 00 B4     	sta CmdReg
00102D  3  20 56 10     	jsr interwritedelay
001030  3               
001030  3  AD 01 B4     	lda DatReg		; Read joystick status
001033  3  29 7F        	and #$7f
001035  3  85 rr        	sta joyval
001037  3  85 F0        	sta $f0
001039  3               
001039  3  AD B6 1E     	lda keys+5		; check fire2
00103C  3  20 B9 0F     	jsr ktest
00103F  3  B0 06        	bcs :+
001041  3  A5 rr        	lda joyval
001043  3  29 DF        	and #$df
001045  3  85 rr        	sta joyval
001047  3               :
001047  3  AD B7 1E     	lda keys+6		; check fire3
00104A  3  20 B9 0F     	jsr ktest
00104D  3  B0 06        	bcs :+
00104F  3  A5 rr        	lda joyval
001051  3  29 BF        	and #$bf
001053  3  85 rr        	sta joyval
001055  3               :
001055  3  60           	rts
001056  3               
001056  3               ; Short delay
001056  3               ; Enough to intersperse 2 writes to the FATPIC.
001056  3               
001056  3               interwritedelay:
001056  3  A9 08        	lda  #8
001058  3  38           	sec
001059  3               loop:
001059  3  E9 01        	sbc  #1
00105B  3  D0 FC        	bne  loop
00105D  3  60           	rts
00105E  3               
00105E  3               ;tmp_byte:   .byte 0
00105E  3               
00105E  3               ;---------------------------------------------------------------
00105E  3               ; Getkey in column,row format
00105E  3               ;
00105E  3               ; Output:
00105E  3               ;  A = high nibble=row and low nibble=column key in matrix
00105E  3               ;---------------------------------------------------------------
00105E  3               
00105E  3               kget:
00105E  3  A9 F0        	lda #ScrMode		; high-mono mode.
001060  3  8D 00 B0     	sta ScrSelAddr		; screen select port
001063  3  86 rr        	stx xtmp
001065  3               kget4:
001065  3  20 71 FE     	jsr READKEY		; read key until pressed
001068  3  C0 FF        	cpy #255
00106A  3  F0 F9        	beq kget4
00106C  3  85 rr        	sta rcol		; save column
00106E  3  86 rr        	stx rrow		; determine row
001070  3               kget3:
001070  3  20 71 FE     	jsr READKEY		; wait until key released
001073  3  C0 FF        	cpy #255
001075  3  D0 F9        	bne kget3
001077  3               
001077  3  38           	sec			; calculate matrix row
001078  3  A9 0A        	lda #10
00107A  3  E5 rr        	sbc rrow
00107C  3  0A           	asl a
00107D  3  0A           	asl a
00107E  3  0A           	asl a
00107F  3  0A           	asl a
001080  3  85 rr        	sta rrow
001082  3               
001082  3  A0 FF        	ldy #255		; find column mask
001084  3               kget1:
001084  3  C8           	iny
001085  3  B9 D5 0F     	lda keymask,y
001088  3  C5 rr        	cmp rcol
00108A  3  F0 03        	beq kget2
00108C  3  4C 84 10     	jmp kget1
00108F  3               kget2:
00108F  3  98           	tya			; determine column
001090  3  18           	clc
001091  3  65 rr        	adc rrow
001093  3  A6 rr        	ldx xtmp
001095  3  60           	rts
001096  3               
001096  3               ;---------------------------------------------------------------
001096  3               ; Display message.
001096  3               ;
001096  3               ; Input:
001096  3               ;  A = message number
001096  3               ;---------------------------------------------------------------
001096  3               
001096  3               dmsg:
001096  3  AA           	tax
001097  3  A9 BE        	lda #<msgdat		; pointer to messages.
001099  3  85 66        	sta z80_l
00109B  3  A9 1A        	lda #>msgdat
00109D  3  85 67        	sta z80_h
00109F  3  20 B1 11     	jsr getwrd		; get message number.
0010A2  3               dmsg3:
0010A2  3  20 9E 11     	jsr preprt		; pre-printing stuff.
0010A5  3  20 CC 09     	jsr checkx		; make sure we"re in a printable range.
0010A8  3  A5 rr        	lda prtmod		; print mode.
0010AA  3  D0 47        	bne bmsg1		; no, double-height text.
0010AC  3               dmsg0:
0010AC  3  A5 67        	lda z80_h		; store string pointer.
0010AE  3  48           	pha
0010AF  3  A5 66        	lda z80_l
0010B1  3  48           	pha
0010B2  3               
0010B2  3  A0 00        	ldy #0
0010B4  3  B1 66        	lda (z80_hl),y		; fetch byte to display.
0010B6  3  29 7F        	and #127		; remove any end marker.
0010B8  3  C9 0D        	cmp #13
0010BA  3  F0 24        	beq dmsg1
0010BC  3  20 60 0B     	jsr pchar		; display character.
0010BF  3  20 8B 11     	jsr nexpos 		; display position.
0010C2  3  D0 03        	bne dmsg2		; not on a new line.
0010C4  3  20 90 11     	jsr nexlin		; next line down.
0010C7  3               dmsg2:
0010C7  3  68           	pla			; retrieve string pointer
0010C8  3  85 66        	sta z80_l
0010CA  3  68           	pla
0010CB  3  85 67        	sta z80_h
0010CD  3               
0010CD  3  A0 00        	ldy #0
0010CF  3  B1 66        	lda (z80_hl),y		; fetch last character.
0010D1  3  0A           	asl a  			; was it the end?
0010D2  3  90 03        	bcc :+
0010D4  3  4C 1F 0A     	jmp dscor2		; yes, job done.
0010D7  3               :
0010D7  3  E6 66        	inc z80_l		; next character to display.
0010D9  3  D0 02        	bne :+
0010DB  3  E6 67        	inc z80_h
0010DD  3               :
0010DD  3  4C AC 10     	jmp dmsg0
0010E0  3               dmsg1:
0010E0  3  E6 rr        	inc dispy
0010E2  3  A5 rr        	lda dispy
0010E4  3  C9 18        	cmp #24
0010E6  3  90 04        	bcc dmsg4
0010E8  3  A9 00        	lda #0
0010EA  3  85 rr        	sta dispy
0010EC  3               dmsg4:
0010EC  3  A9 00        	lda #0
0010EE  3  85 rr        	sta dispx
0010F0  3  4C C7 10     	jmp dmsg2
0010F3  3               
0010F3  3               ;prtmod:	.byte 0            	; print mode, 0 = standard, 1 = double-height.
0010F3  3               
0010F3  3               ;----------------------------------------------------------
0010F3  3               ; Display message in big text.
0010F3  3               ;
0010F3  3               ; Input:
0010F3  3               ;  HL = string pointer
0010F3  3               ;----------------------------------------------------------
0010F3  3               
0010F3  3               bmsg1:
0010F3  3  A0 00        	ldy #0
0010F5  3  B1 66        	lda (z80_hl),y 		; get character to display.
0010F7  3  29 7F        	and #127		; only want 7 bits.
0010F9  3  C9 0D        	cmp #13
0010FB  3  F0 13        	beq bmsg2
0010FD  3  20 25 11     	jsr bchar 		; display big char.
001100  3               bmsg3:
001100  3  A0 00        	ldy #0
001102  3  B1 66        	lda (z80_hl),y 		; look at last character.
001104  3  48           	pha
001105  3  E6 66        	inc z80_l 		; next character in list.
001107  3  D0 02        	bne :+
001109  3  E6 67        	inc z80_h
00110B  3               :
00110B  3  68           	pla
00110C  3  0A           	asl a  			; was terminator flag set?
00110D  3  90 E4        	bcc bmsg1		; no, keep going.
00110F  3  60           	rts
001110  3               bmsg2:
001110  3  A9 00        	lda #0
001112  3  85 rr        	sta dispx
001114  3  E6 rr        	inc dispy
001116  3  E6 rr        	inc dispy
001118  3  A5 rr        	lda dispy
00111A  3  C9 17        	cmp #23
00111C  3  90 E2        	bcc bmsg3
00111E  3  A9 00        	lda #0
001120  3  85 rr        	sta dispy
001122  3  4C 00 11     	jmp bmsg3
001125  3               
001125  3               ;----------------------------------------------------------
001125  3               ; Big character display.
001125  3               ;
001125  3               ; Input:
001125  3               ;  A = character
001125  3               ;----------------------------------------------------------
001125  3               
001125  3               bchar:
001125  3  85 64        	sta z80_e		; save char in lb
001127  3  A9 00        	lda #0
001129  3  85 65        	sta z80_d		; reset hb
00112B  3               
00112B  3  06 64        	asl z80_e 		; multiply char by 8.
00112D  3  26 65        	rol z80_d
00112F  3  06 64        	asl z80_e
001131  3  26 65        	rol z80_d
001133  3  06 64        	asl z80_e
001135  3  26 65        	rol z80_d		; de = a*8
001137  3               
001137  3  18           	clc			; de = Fontpointer + a*8
001138  3  A5 64        	lda z80_e
00113A  3  69 B0        	adc #<(FONT-256) 		; address of font.
00113C  3  85 64        	sta z80_e
00113E  3  A5 65        	lda z80_d
001140  3  69 1A        	adc #>(FONT-256)
001142  3  85 65        	sta z80_d
001144  3               
001144  3  20 11 0B     	jsr gprad 		; get screen address.
001147  3               
001147  3  A2 00        	ldx #0			; height of character in font.
001149  3               bchar0:
001149  3  A0 00        	ldy #0
00114B  3  B1 64        	lda (z80_de),y 		; get a bit of the font.
00114D  3               
00114D  3               .if iflag
00114D  3               	eor #$ff
00114D  3               .endif
00114D  3               
00114D  3  91 rr        	sta (scraddr),y
00114F  3  48           	pha
001150  3  20 E5 14     	jsr nline 		; next line down.
001153  3  68           	pla
001154  3  91 rr        	sta (scraddr),y
001156  3  20 E5 14     	jsr nline 		; next line down.
001159  3               
001159  3  18           	clc
00115A  3  E6 64        	inc z80_e 		; next line of font.
00115C  3  D0 02        	bne :+
00115E  3  E6 65        	inc z80_d
001160  3               :
001160  3  E8           	inx
001161  3  E0 08        	cpx #8
001163  3  D0 E4        	bne bchar0
001165  3               
001165  3  20 8B 11     	jsr nexpos		; display position.
001168  3  D0 05        	bne bchar2 		; not on a new line.
00116A  3               bchar3:
00116A  3  E6 rr        	inc dispy
00116C  3  20 90 11     	jsr nexlin 		; next line check.
00116F  3               bchar2:
00116F  3  4C 1F 0A     	jmp dscor2		; tidy up line and column variables.
001172  3               
001172  3               
001172  3               ;-------------------------------------------------
001172  3               ; Display a character.
001172  3               ;
001172  3               ; Input:
001172  3               ;  A = character
001172  3               ;-------------------------------------------------
001172  3               
001172  3               achar:
001172  3  85 63        	sta z80_b 		; copy to b.
001174  3  20 9E 11     	jsr preprt 		; get ready to print.
001177  3  A5 63        	lda z80_b		; character in accumulator.
001179  3  A6 rr        	ldx prtmod 		; print mode.
00117B  3  F0 03        	beq :+
00117D  3  4C 25 11     	jmp bchar 		; no, double-height text.
001180  3               :
001180  3  20 60 0B     	jsr pchar 		; display character.
001183  3  20 8B 11     	jsr nexpos 		; display position.
001186  3  F0 E2        	beq bchar3		; next line down.
001188  3  4C 6F 11     	jmp bchar2 		; tidy up.
00118B  3               
00118B  3               
00118B  3               ;-------------------------------------------------
00118B  3               ; Get next print column position.
00118B  3               ;-------------------------------------------------
00118B  3               
00118B  3               nexpos:
00118B  3  E6 rr        	inc dispx		; move along one position.
00118D  3  A5 rr        	lda dispx 		; get coordinate.
00118F  3               ;	and #31
00118F  3  60           	rts 			; return with status in zero flag.
001190  3               
001190  3               ;-------------------------------------------------
001190  3               ; Get next print line position.
001190  3               ;-------------------------------------------------
001190  3               
001190  3               nexlin:
001190  3  E6 rr        	inc dispy 		; newline.
001192  3  A5 rr        	lda dispy		; vertical position.
001194  3  C9 18        	cmp #24			; past screen edge?
001196  3  B0 01        	bcs :+
001198  3  60           	rts			; no, still okay.
001199  3               :
001199  3  A9 00        	lda #0			; restart at top.
00119B  3  85 rr        	sta dispy
00119D  3  60           	rts
00119E  3               
00119E  3               ;--------------------------------------------------------
00119E  3               ; Pre-print preliminaries.
00119E  3               ;--------------------------------------------------------
00119E  3               
00119E  3               preprt:
00119E  3  A9 B0        	lda #<(FONT-256)		; font pointer.
0011A0  3  8D CA 09     	sta grbase		; set up graphics base.
0011A3  3  A9 1A        	lda #>(FONT-256)
0011A5  3  8D CB 09     	sta grbase+1
0011A8  3               prescr:
0011A8  3  A5 rr        	lda charx 		; display coordinates.
0011AA  3  85 rr        	sta dispx		; set up general coordinates.
0011AC  3  A5 rr        	lda chary
0011AE  3  85 rr        	sta dispy
0011B0  3  60           	rts
0011B1  3               
0011B1  3               ;--------------------------------------------------------------
0011B1  3               ; Get messagenr x in hl
0011B1  3               ;
0011B1  3               ; Input:
0011B1  3               ;  HL = pointer to message list
0011B1  3               ;  X  = message number.
0011B1  3               ;--------------------------------------------------------------
0011B1  3               
0011B1  3               getwrd:
0011B1  3  E0 00        	cpx #0
0011B3  3  D0 01        	bne:+ 			; first word in list?
0011B5  3  60           	rts 			; yep, don't search.
0011B6  3               :
0011B6  3  A0 00        	ldy #0
0011B8  3               getwd0:
0011B8  3  B1 66        	lda (z80_hl),y
0011BA  3  48           	pha
0011BB  3  E6 66        	inc z80_l
0011BD  3  D0 02        	bne :+
0011BF  3  E6 67        	inc z80_h
0011C1  3               :
0011C1  3  68           	pla
0011C2  3  C9 80        	cmp #128		; found end?
0011C4  3  30 F2        	bmi getwd0		; no, carry on.
0011C6  3  CA           	dex			; until we have right number.
0011C7  3  D0 EF        	bne getwd0
0011C9  3  60           	rts
0011CA  3               
0011CA  3               ;-----------------------------------------------------------
0011CA  3               ; Bubble sort.
0011CA  3               ;-----------------------------------------------------------
0011CA  3               
0011CA  3               bsort:
0011CA  3  A9 0B        	lda #NUMSPR - 1		; sprites to swap.
0011CC  3  85 rr        	sta qscnt
0011CE  3               
0011CE  3  A9 33        	lda #<sprtab 		; sprite table.
0011D0  3  85 68        	sta z80_x
0011D2  3  A9 19        	lda #>sprtab
0011D4  3  85 69        	sta z80_i
0011D6  3               bsort0:
0011D6  3  A0 00        	ldy #0
0011D8  3  B1 68        	lda (z80_ix),y 		; first sprite type.
0011DA  3  C9 FF        	cmp #255 		; is it switched off?
0011DC  3  F0 30        	beq swemp		; yes, may need to switch another in here.
0011DE  3               
0011DE  3  A0 11        	ldy #TABSIZ
0011E0  3  B1 68        	lda (z80_ix),y 		; check next slot exists.
0011E2  3  C9 FF        	cmp #255 		; is it enabled?
0011E4  3  F0 0A        	beq bsort2 		; no, nothing to swap.
0011E6  3               
0011E6  3  A0 14        	ldy #TABSIZ+3
0011E8  3  B1 68        	lda (z80_ix),y 		; fetch next sprite's coordinate.
0011EA  3  A0 03        	ldy #3
0011EC  3  D1 68        	cmp (z80_ix),y 		; compare with this x coordinate.
0011EE  3  90 10        	bcc bsort1		; next sprite is higher - may need to switch.
0011F0  3               bsort2:
0011F0  3  18           	clc
0011F1  3  A5 68        	lda z80_x
0011F3  3  69 11        	adc #TABSIZ 		; distance to next odd/even entry.
0011F5  3  85 68        	sta z80_x
0011F7  3  90 02        	bcc :+
0011F9  3  E6 69        	inc z80_i
0011FB  3               :
0011FB  3  C6 rr        	dec qscnt
0011FD  3  D0 D7        	bne bsort0		; repeat for remaining sprites.
0011FF  3  60           	rts
001200  3               
001200  3               ;qscnt:	.byte 0
001200  3               
001200  3               bsort1:
001200  3  A0 11        	ldy #TABSIZ
001202  3  B1 68        	lda (z80_ix),y		; sprite on/off flag.
001204  3  C9 FF        	cmp #255		; is it enabled?
001206  3  F0 E8        	beq bsort2		; no, nothing to swap.
001208  3  20 1C 12     	jsr swspr		; swap positions.
00120B  3  4C F0 11     	jmp bsort2
00120E  3               swemp:
00120E  3  A0 11        	ldy #TABSIZ
001210  3  B1 68        	lda (z80_ix),y		; next table entry.
001212  3  C9 FF        	cmp #255		; is that one on?
001214  3  F0 DA        	beq bsort2		; no, nothing to swap.
001216  3  20 1C 12     	jsr swspr		; swap positions.
001219  3  4C F0 11     	jmp bsort2
00121C  3               
00121C  3               ; Swap sprites.
00121C  3               
00121C  3               swspr:
00121C  3  A5 68        	lda z80_x		; table address
00121E  3  85 64        	sta z80_e		; copy to de pair.
001220  3  85 66        	sta z80_l		; copy to hl pair.
001222  3  A5 69        	lda z80_i
001224  3  85 67        	sta z80_h
001226  3  85 65        	sta z80_d
001228  3               
001228  3  18           	clc
001229  3  A5 66        	lda z80_l
00122B  3  69 11        	adc #TABSIZ		; distance to second entry.
00122D  3  85 66        	sta z80_l
00122F  3  90 02        	bcc :+
001231  3  E6 67        	inc z80_h
001233  3               :
001233  3  A9 11        	lda #TABSIZ		; bytes to swap.
001235  3  85 63        	sta z80_b
001237  3  A0 00        	ldy #0
001239  3               swspr0:
001239  3  B1 66        	lda (z80_hl),y		; fetch second byte.
00123B  3  48           	pha
00123C  3  B1 64        	lda (z80_de),y 		; fetch first byte.
00123E  3  91 66        	sta (z80_hl),y 		; copy to second.
001240  3  68           	pla
001241  3  91 64        	sta (z80_de),y 		; copy to first sprite entry.
001243  3               
001243  3  E6 64        	inc z80_e 		; next byte.
001245  3  D0 02        	bne :+
001247  3  E6 65        	inc z80_d
001249  3               :
001249  3  E6 66        	inc z80_l 		; next byte.
00124B  3  D0 02        	bne :+
00124D  3  E6 67        	inc z80_h
00124F  3               :
00124F  3  C6 63        	dec z80_b
001251  3  D0 E6        	bne swspr0 		; swap all bytes in table entry.
001253  3  60           	rts
001254  3               
001254  3               ;----------------------------------------------------
001254  3               ; Process sprites.
001254  3               ;----------------------------------------------------
001254  3               
001254  3               pspr:
001254  3  A9 0C        	lda #NUMSPR		; sprites to process.
001256  3  85 rr        	sta sprptr
001258  3               
001258  3  A9 33        	lda #<sprtab 		; sprite table.
00125A  3  85 68        	sta z80_x
00125C  3  A9 19        	lda #>sprtab
00125E  3  85 69        	sta z80_i
001260  3               pspr1:
001260  3  A0 00        	ldy #0
001262  3  B1 68        	lda (z80_ix),y		; fetch sprite type.
001264  3  C9 09        	cmp #9 			; within range of sprite types?
001266  3  B0 03        	bcs :+
001268  3  20 7B 12     	jsr pspr2 		; yes, process this one.
00126B  3               :
00126B  3  18           	clc
00126C  3  A5 68        	lda z80_x
00126E  3  69 11        	adc #TABSIZ 		; distance to next odd/even entry.
001270  3  85 68        	sta z80_x
001272  3  90 02        	bcc :+
001274  3  E6 69        	inc z80_i		; next sprite.
001276  3               :
001276  3  C6 rr        	dec sprptr 		; repeat for remaining sprites.
001278  3  D0 E6        	bne pspr1
00127A  3  60           	rts
00127B  3               
00127B  3               ;sprptr:	.byte 0
00127B  3               
00127B  3               pspr2:
00127B  3  A5 68        	lda z80_x 		; store original sprite pointer.
00127D  3  85 rr        	sta ogptr
00127F  3  A5 69        	lda z80_i
001281  3  85 rr        	sta ogptr+1
001283  3  20 8F 12     	jsr pspr3		; do the routine.
001286  3               rtorg:
001286  3  A5 rr        	lda ogptr 		; restore original pointer to sprite.
001288  3  85 68        	sta z80_x
00128A  3  A5 rr        	lda ogptr+1
00128C  3  85 69        	sta z80_i
00128E  3               rtorg0:
00128E  3  60           	rts
00128F  3               
00128F  3               pspr3:
00128F  3  A9 C4        	lda #<evtyp0		; sprite type events list.
001291  3  85 66        	sta z80_l
001293  3  A9 12        	lda #>evtyp0
001295  3  85 67        	sta z80_h
001297  3               pspr4:
001297  3  B1 68        	lda (z80_ix),y
001299  3  0A           	asl a			; double accumulator.
00129A  3  18           	clc
00129B  3  65 66        	adc z80_l
00129D  3  85 66        	sta z80_l
00129F  3  90 02        	bcc :+
0012A1  3  E6 67        	inc z80_h
0012A3  3               :
0012A3  3  B1 66        	lda (z80_hl),y
0012A5  3  85 64        	sta z80_e 		; copy to de.
0012A7  3  48           	pha
0012A8  3               
0012A8  3  E6 66        	inc z80_l 		; next byte of address.
0012AA  3  D0 02        	bne :+
0012AC  3  E6 67        	inc z80_h
0012AE  3               :
0012AE  3  B1 66        	lda (z80_hl),y 		; address high.
0012B0  3  85 65        	sta z80_d
0012B2  3               
0012B2  3  48           	pha	 		; swap address into hl.
0012B3  3  A5 67        	lda z80_h
0012B5  3  85 65        	sta z80_d
0012B7  3  68           	pla
0012B8  3  85 67        	sta z80_h
0012BA  3  68           	pla
0012BB  3  85 66        	sta z80_l
0012BD  3  A5 66        	lda z80_l
0012BF  3  85 64        	sta z80_e
0012C1  3               
0012C1  3  6C 66 00     	jmp (z80_hl) 		; go there.
0012C4  3               
0012C4  3               ;ogptr:	.word 0			; original sprite pointer.
0012C4  3               
0012C4  3               ; Address of each sprite type's routine.
0012C4  3               
0012C4  3  45 1A        evtyp0:	.word evnt00
0012C6  3  46 1A        evtyp1:	.word evnt01
0012C8  3  47 1A        evtyp2:	.word evnt02
0012CA  3  48 1A        evtyp3:	.word evnt03
0012CC  3  49 1A        evtyp4:	.word evnt04
0012CE  3  4A 1A        evtyp5:	.word evnt05
0012D0  3  4B 1A        evtyp6:	.word evnt06
0012D2  3  4C 1A        evtyp7:	.word evnt07
0012D4  3  4D 1A        evtyp8:	.word evnt08
0012D6  3               
0012D6  3               ;--------------------------------------------------------------
0012D6  3               ; Display sprites.
0012D6  3               ;
0012D6  3               ; Input:
0012D6  3               ;  IX = sprite table
0012D6  3               ;--------------------------------------------------------------
0012D6  3               
0012D6  3               dspr:
0012D6  3  A9 06        	lda #(NUMSPR/2)		; number of sprites to display.
0012D8  3  85 rr        	sta sprcnt
0012DA  3               dspr0:
0012DA  3  A0 00        	ldy #0
0012DC  3  B1 68        	lda (z80_ix),y 		; get sprite type.
0012DE  3  C9 FF        	cmp #255 		; is it enabled?
0012E0  3  D0 42        	bne dspr1 		; yes, it needs deleting.
0012E2  3               dspr5:
0012E2  3  A0 05        	ldy #5
0012E4  3  B1 68        	lda (z80_ix),y 		; new type.
0012E6  3  C9 FF        	cmp #255		; is it enabled?
0012E8  3  D0 77        	bne dspr3 		; yes, it needs drawing.
0012EA  3               dspr2:
0012EA  3  A0 05        	ldy #5
0012EC  3  B1 68        	lda (z80_ix),y 		; copy new type.
0012EE  3  A0 00        	ldy #0
0012F0  3  91 68        	sta (z80_ix),y
0012F2  3  A0 06        	ldy #6
0012F4  3  B1 68        	lda (z80_ix),y 		; copy new image number.
0012F6  3  A0 01        	ldy #1
0012F8  3  91 68        	sta (z80_ix),y
0012FA  3  A0 07        	ldy #7
0012FC  3  B1 68        	lda (z80_ix),y 		; copy new frame.
0012FE  3  A0 02        	ldy #2
001300  3  91 68        	sta (z80_ix),y
001302  3  A0 08        	ldy #8
001304  3  B1 68        	lda (z80_ix),y 		; copy new y.
001306  3  A0 03        	ldy #3
001308  3  91 68        	sta (z80_ix),y
00130A  3  A0 09        	ldy #9
00130C  3  B1 68        	lda (z80_ix),y 		; copy new x.
00130E  3  A0 04        	ldy #4
001310  3  91 68        	sta (z80_ix),y
001312  3               
001312  3  18           	clc
001313  3  A5 68        	lda z80_x
001315  3  69 22        	adc #(TABSIZ*2)		; distance to next odd/even entry.
001317  3  85 68        	sta z80_x
001319  3  A5 69        	lda z80_i
00131B  3  69 00        	adc #0
00131D  3  85 69        	sta z80_i 		; next sprite.
00131F  3  C6 rr        	dec sprcnt
001321  3  D0 B7        	bne dspr0		; repeat for remaining sprites.
001323  3  60           	rts
001324  3               dspr1:
001324  3  A0 05        	ldy #5
001326  3  B1 68        	lda (z80_ix),y 		; type of new sprite.
001328  3  C9 FF        	cmp #255		; is this enabled?
00132A  3  D0 06        	bne dspr4 		; yes, display both.
00132C  3               dspr6:
00132C  3  20 FC 13     	jsr sspria 		; show single sprite.
00132F  3  4C EA 12     	jmp dspr2
001332  3               
001332  3               ; Displaying two sprites.  Don't bother redrawing if nothing has changed.
001332  3               
001332  3               dspr4:
001332  3  A0 04        	ldy #4
001334  3  B1 68        	lda (z80_ix),y		; old x.
001336  3  A0 09        	ldy #9
001338  3  D1 68        	cmp (z80_ix),y 		; compare with new value.
00133A  3  D0 1F        	bne dspr7 		; they differ, need to redraw.
00133C  3               
00133C  3  A0 03        	ldy #3
00133E  3  B1 68        	lda (z80_ix),y		; old y.
001340  3  A0 08        	ldy #8
001342  3  D1 68        	cmp (z80_ix),y 		; compare against new value.
001344  3  D0 15        	bne dspr7		; they differ, need to redraw.
001346  3               
001346  3  A0 02        	ldy #2
001348  3  B1 68        	lda (z80_ix),y 		; old frame.
00134A  3  A0 07        	ldy #7
00134C  3  D1 68        	cmp (z80_ix),y 		; compare against new value.
00134E  3  4C 5B 13     	jmp dspr7 		; they differ, need to redraw.
001351  3               
001351  3  A0 01        	ldy #1
001353  3  B1 68        	lda (z80_ix),y 		; old image.
001355  3  A0 06        	ldy #6
001357  3  D1 68        	cmp (z80_ix),y 		; compare against new value.
001359  3  F0 8F        	beq dspr2		; everything is the same, don't redraw.
00135B  3               dspr7:
00135B  3  20 29 14     	jsr sspric 		; delete old sprite, draw new one simultaneously.
00135E  3  4C EA 12     	jmp dspr2
001361  3               dspr3:
001361  3  20 23 14     	jsr ssprib 		; show single sprite.
001364  3  4C EA 12     	jmp dspr2
001367  3               
001367  3               ;sprcnt:	.byte 0
001367  3               
001367  3               ;-----------------------------------------
001367  3               ; Get sprite address calculations.
001367  3               ; gspran = new sprite, gsprad = old sprite.
001367  3               ;
001367  3               ; Input:
001367  3               ;  IX = sprite address
001367  3               ;-----------------------------------------
001367  3               
001367  3               gspran:
001367  3  A0 08        	ldy #8
001369  3  B1 68        	lda (z80_ix),y 		; new y coordinate.
00136B  3  85 rr        	sta dispy
00136D  3  A0 09        	ldy #9
00136F  3  B1 68        	lda (z80_ix),y 		; new x coordinate.
001371  3  85 rr        	sta dispx
001373  3  A0 06        	ldy #6
001375  3  B1 68        	lda (z80_ix),y 		; new sprite image.
001377  3  20 55 17     	jsr gfrm		; fetch start frame for this sprite.
00137A  3               
00137A  3  A0 00        	ldy #0
00137C  3  B1 66        	lda (z80_hl),y 		; frame in accumulator.
00137E  3  A0 07        	ldy #7
001380  3  18           	clc
001381  3  71 68        	adc (z80_ix),y 		; new add frame number.
001383  3  4C A2 13     	jmp gspra0
001386  3               
001386  3               ;-----------------------------------------
001386  3               ; Calculate old sprite address
001386  3               ;
001386  3               ; Input:
001386  3               ;  IX = sprite address
001386  3               ;
001386  3               ; Output:
001386  3               ;  B  = right byte mask
001386  3               ;  C  = left byte mask
001386  3               ;  DE = spriteframe address
001386  3               ;  scraddr = screenaddress(dispx,dispy)
001386  3               ;-----------------------------------------
001386  3               
001386  3               gsprad:
001386  3  A0 03        	ldy #3
001388  3  B1 68        	lda (z80_ix),y		; y coordinate.
00138A  3  85 rr        	sta dispy
00138C  3  A0 04        	ldy #4
00138E  3  B1 68        	lda (z80_ix),y		; x coordinate.
001390  3  85 rr        	sta dispx
001392  3  A0 01        	ldy #1
001394  3  B1 68        	lda (z80_ix),y 		; sprite image.
001396  3  20 55 17     	jsr gfrm 		; fetch start frame for this sprite.
001399  3               
001399  3  A0 00        	ldy #0
00139B  3  B1 66        	lda (z80_hl),y 		; frame in accumulator.
00139D  3  A0 02        	ldy #2
00139F  3  18           	clc
0013A0  3  71 68        	adc (z80_ix),y 		; add frame number.
0013A2  3               gspra0:
0013A2  3  4A           	lsr a	  		; multiply by 128.
0013A3  3  85 65        	sta z80_d 		; store in d.
0013A5  3  8D FA 13     	sta tmp1
0013A8  3  A9 00        	lda #0
0013AA  3  6A           	ror a
0013AB  3  85 64        	sta z80_e 		; got low byte.
0013AD  3  8D FB 13     	sta tmp2
0013B0  3               .if bflag
0013B0  3               	lsr tmp1
0013B0  3               	ror tmp2
0013B0  3               	clc
0013B0  3               	lda tmp2
0013B0  3               	adc z80_e
0013B0  3               	sta z80_e
0013B0  3               	lda tmp1
0013B0  3               	adc z80_d
0013B0  3               	sta z80_d
0013B0  3               .endif
0013B0  3  18           	clc 			; address of play sprites.
0013B1  3  A5 64        	lda z80_e
0013B3  3  69 F5        	adc #<sprgfx
0013B5  3  85 64        	sta z80_e
0013B7  3  A5 65        	lda z80_d
0013B9  3  69 1A        	adc #>sprgfx
0013BB  3  85 65        	sta z80_d
0013BD  3               
0013BD  3  A5 rr        	lda dispx 		; y coordinate.
0013BF  3  29 06        	and #6 			; position within byte boundary.
0013C1  3  AA           	tax	 		; low byte of table displacement.
0013C2  3               
0013C2  3  0A           	asl a	  		; multiply by 32.
0013C3  3  0A           	asl a  			; already a multiple
0013C4  3  0A           	asl a  			; of 2, so just 4
0013C5  3               .if bflag
0013C5  3               	sta tmp1
0013C5  3               	asl a  			; shifts needed.
0013C5  3               	clc
0013C5  3               	adc tmp1
0013C5  3               .else
0013C5  3  0A           	asl a  			; shifts needed.
0013C6  3               .endif
0013C6  3  18           	clc 			; add to sprite address.
0013C7  3  65 64        	adc z80_e
0013C9  3  85 64        	sta z80_e
0013CB  3  90 02        	bcc :+
0013CD  3  E6 65        	inc z80_d
0013CF  3               :
0013CF  3  BD F2 13     	lda spmask,x		 ; pointer to mask table.
0013D2  3  85 62        	sta z80_c 		; left mask.
0013D4  3  BD F3 13     	lda spmask+1,x
0013D7  3  85 63        	sta z80_b 		; right mask.
0013D9  3               
0013D9  3               ;------------------------------------------------------------------
0013D9  3               ; Drop into screen address routine.
0013D9  3               ; This routine returns a screen address for (dispx, dispy) in scraddr.
0013D9  3               ;------------------------------------------------------------------
0013D9  3               
0013D9  3               scadd:
0013D9  3  A6 rr        	ldx dispy
0013DB  3  E0 C0        	cpx #192
0013DD  3  90 02        	bcc :+
0013DF  3  A2 C0        	ldx #192
0013E1  3               :
0013E1  3  A5 rr        	lda dispx
0013E3  3  4A           	lsr a
0013E4  3  4A           	lsr a
0013E5  3  4A           	lsr a
0013E6  3  18           	clc
0013E7  3  7D 00 9B     	adc SCADTB_lb,x
0013EA  3  85 rr        	sta scraddr
0013EC  3  BD 00 9C     	lda SCADTB_hb,x
0013EF  3  85 rr        	sta scraddr+1
0013F1  3  60           	rts
0013F2  3               
0013F2  3  FF 00        spmask:	.byte $ff,$00
0013F4  3  3F C0        	.byte $3f,$c0
0013F6  3  0F F0        	.byte $0f,$f0
0013F8  3  03 FC        	.byte $03,$fc
0013FA  3               
0013FA  3  00           tmp1:	.byte 0
0013FB  3  00           tmp2:	.byte 0
0013FC  3               
0013FC  3               ;-----------------------------------------------------------------
0013FC  3               ; These are the sprite routines.
0013FC  3               ; sspria = single sprite, old (ix).
0013FC  3               ; ssprib = single sprite, new (ix+5).
0013FC  3               ; sspric = both sprites, old (ix) and new (ix+5).
0013FC  3               ;-----------------------------------------------------------------
0013FC  3               
0013FC  3               sspria:
0013FC  3  20 86 13     	jsr gsprad		; get old sprite address.
0013FF  3               sspri2:
0013FF  3  A5 64        	lda z80_e
001401  3  8D 71 14     	sta dline1+1		; Set spritedata address
001404  3  8D 80 14     	sta dline2+1
001407  3  A5 65        	lda z80_d
001409  3  8D 72 14     	sta dline1+2
00140C  3  8D 81 14     	sta dline2+2
00140F  3  86 rr        	stx xtmp
001411  3  A2 00        	ldx #0			; vertical lines.
001413  3               sspri0:
001413  3  20 6D 14     	jsr dline		; draw a line.
001416  3  E0 10        	cpx #16			; detect block boundery
001418  3  D0 02        	bne :+			; skip if not
00141A  3  E6 rr        	inc scraddr+1		; jump to next blockline
00141C  3               :
00141C  3  E0 20        	cpx #32			; check finished
00141E  3               .if bflag
00141E  3               	bne :+			; skip if not
00141E  3               	inc scraddr+1		; jump to next blockline
00141E  3               	inc z80_hlp+1		; jump to next blockline
00141E  3               :
00141E  3               	cpx #48			; check finished
00141E  3               .endif
00141E  3  D0 F3        	bne sspri0		; no, repeat
001420  3  A6 rr        	ldx xtmp
001422  3  60           	rts
001423  3               
001423  3               ;-----------------------------------------------------------------
001423  3               
001423  3               ssprib:
001423  3  20 67 13     	jsr gspran 		; get new sprite address.
001426  3  4C FF 13     	jmp sspri2
001429  3               
001429  3               ;-----------------------------------------------------------------
001429  3               
001429  3               sspric:
001429  3  20 86 13     	jsr gsprad 		; get old sprite address.
00142C  3  A5 64        	lda z80_e
00142E  3  8D 95 14     	sta ddline1+1		; Set spritedata address
001431  3  8D A4 14     	sta ddline2+1
001434  3  A5 65        	lda z80_d
001436  3  8D 96 14     	sta ddline1+2
001439  3  8D A5 14     	sta ddline2+2
00143C  3  20 BC 1E     	jsr exx  		; store addresses.
00143F  3               
00143F  3  20 67 13     	jsr gspran 		; get new sprite addresses.
001442  3  A5 64        	lda z80_e
001444  3  8D 71 14     	sta dline1+1		; Set spritedata address
001447  3  8D 80 14     	sta dline2+1
00144A  3  A5 65        	lda z80_d
00144C  3  8D 72 14     	sta dline1+2
00144F  3  8D 81 14     	sta dline2+2
001452  3               
001452  3  86 rr        	stx xtmp
001454  3  A2 00        	ldx #0			; vertical lines.
001456  3               lloop:
001456  3  20 6D 14     	jsr dline 		; draw a line.
001459  3  CA           	dex
00145A  3  CA           	dex
00145B  3  20 91 14     	jsr ddline 		; delete a line.
00145E  3  E0 10        	cpx #16			; detect block boundery
001460  3  D0 04        	bne :+			; skip if not
001462  3  E6 rr        	inc scraddr+1		; jump to next blockline
001464  3  E6 73        	inc z80_hlp+1		; jump to next blockline
001466  3               :
001466  3  E0 20        	cpx #32			; check finished
001468  3               .if bflag
001468  3               	bne :+			; skip if not
001468  3               	inc scraddr+1		; jump to next blockline
001468  3               	inc z80_hlp+1		; jump to next blockline
001468  3               :
001468  3               	cpx #48			; check finished
001468  3               .endif
001468  3  D0 EC        	bne lloop		; no, repeat
00146A  3  A6 rr        	ldx xtmp
00146C  3  60           	rts
00146D  3               
00146D  3               
00146D  3               ;-----------------------------------------------------------------
00146D  3               
00146D  3               dline:
00146D  3  BC B5 14     	ldy sprline,x		; point to screenleft
001470  3               dline1:
001470  3  BD 8A 1B     	lda objdta,x		; fetch spriteleft byte
001473  3  85 61        	sta z80_a		; save spriteright byte
001475  3  A5 61        	lda z80_a
001477  3  25 62        	and z80_c		; mask left
001479  3  51 rr        	eor (scraddr),y		; merge with screenleft
00147B  3  91 rr        	sta (scraddr),y		; write screenleft
00147D  3               sline:
00147D  3  E8           	inx			; next spritebyte
00147E  3  C8           	iny			; point to screenmiddle
00147F  3               dline2:
00147F  3  BD 8A 1B     	lda objdta,x		; fetch spritemiddle byte
001482  3  51 rr        	eor (scraddr),y		; merge with screenmiddle
001484  3  91 rr        	sta (scraddr),y		; write screenmiddle
001486  3               sline2:
001486  3  C8           	iny			; point to screenright
001487  3  A5 61        	lda z80_a		; fetch spriteright byte
001489  3  25 63        	and z80_b		; mask right
00148B  3  51 rr        	eor (scraddr),y		; merge with screenright
00148D  3  91 rr        	sta (scraddr),y		; write screenright
00148F  3               sline3:
00148F  3  E8           	inx			; next spritebyte
001490  3               
001490  3  60           	rts
001491  3               
001491  3               ;-----------------------------------------------------------------
001491  3               
001491  3               ddline:
001491  3  BC B5 14     	ldy sprline,x		; point to screenleft
001494  3               ddline1:
001494  3  BD 8A 1B     	lda objdta,x		; fetch spriteleft byte
001497  3  85 61        	sta z80_a		; save spriteright byte
001499  3  A5 61        	lda z80_a
00149B  3  25 6E        	and z80_cp		; mask left
00149D  3  51 72        	eor (z80_hlp),y		; merge with screenleft
00149F  3  91 72        	sta (z80_hlp),y		; write screenleft
0014A1  3               dsline:
0014A1  3  E8           	inx			; next spritebyte
0014A2  3  C8           	iny			; point to screenmiddle
0014A3  3               ddline2:
0014A3  3  BD 8A 1B     	lda objdta,x		; fetch spritemiddle byte
0014A6  3  51 72        	eor (z80_hlp),y		; merge with screenmiddle
0014A8  3  91 72        	sta (z80_hlp),y		; write screenmiddle
0014AA  3               dsline2:
0014AA  3  C8           	iny			; point to screenright
0014AB  3  A5 61        	lda z80_a		; fetch spriteright byte
0014AD  3  25 6F        	and z80_bp		; mask right
0014AF  3  51 72        	eor (z80_hlp),y		; merge with screenright
0014B1  3  91 72        	sta (z80_hlp),y		; write screenright
0014B3  3               dsline3:
0014B3  3  E8           	inx			; next spritebyte
0014B4  3               
0014B4  3  60           	rts
0014B5  3               
0014B5  3               sprline:
0014B5  3  00 01 20 21  	.byte $00,$01,$20,$21,$40,$41,$60,$61
0014B9  3  40 41 60 61  
0014BD  3  80 81 A0 A1  	.byte $80,$81,$a0,$a1,$c0,$c1,$e0,$e1
0014C1  3  C0 C1 E0 E1  
0014C5  3  00 01 20 21  	.byte $00,$01,$20,$21,$40,$41,$60,$61
0014C9  3  40 41 60 61  
0014CD  3  80 81 A0 A1  	.byte $80,$81,$a0,$a1,$c0,$c1,$e0,$e1
0014D1  3  C0 C1 E0 E1  
0014D5  3  00 01 20 21  	.byte $00,$01,$20,$21,$40,$41,$60,$61
0014D9  3  40 41 60 61  
0014DD  3  80 81 A0 A1  	.byte $80,$81,$a0,$a1,$c0,$c1,$e0,$e1
0014E1  3  C0 C1 E0 E1  
0014E5  3               
0014E5  3               ;----------------------------------------------------------------------
0014E5  3               ; Line drawn, now work out next target address.
0014E5  3               ;----------------------------------------------------------------------
0014E5  3               
0014E5  3               nline:
0014E5  3  18           	clc
0014E6  3  A5 rr        	lda scraddr 		; get low byte of address.
0014E8  3  69 20        	adc #$20
0014EA  3  85 rr        	sta scraddr 		; new low byte of address.
0014EC  3  90 02        	bcc :+
0014EE  3  E6 rr        	inc scraddr+1 		; new high byte of address.
0014F0  3               :
0014F0  3  60           	rts
0014F1  3               
0014F1  3               ;-------------------------------------------------------------
0014F1  3               ; Line drawn, now work out next target address.
0014F1  3               ;
0014F1  3               ; Input:
0014F1  3               ;  BP  = right mask
0014F1  3               ;  CP  = left mask
0014F1  3               ;  DEP = spriteaddress
0014F1  3               ;  z80_hlp = screen address
0014F1  3               ;-------------------------------------------------------------
0014F1  3               
0014F1  3               
0014F1  3               ;-----------------------------------------------------------
0014F1  3               ; Animates a sprite.
0014F1  3               ;
0014F1  3               ; Input:
0014F1  3               ;  IX = sprite address
0014F1  3               ;  HL = last sprite address
0014F1  3               ;-----------------------------------------------------------
0014F1  3               
0014F1  3               animsp:
0014F1  3  25 rr        	and frmno
0014F3  3  F0 01        	beq :+
0014F5  3  60           	rts
0014F6  3               :
0014F6  3  A0 06        	ldy #6
0014F8  3  B1 68        	lda (z80_ix),y		; sprite image
0014FA  3  20 55 17     	jsr gfrm		; get frame data.
0014FD  3               
0014FD  3  E6 66        	inc z80_l		; point to frames.
0014FF  3  D0 02        	bne :+
001501  3  E6 67        	inc z80_h
001503  3               :
001503  3  A0 07        	ldy #7
001505  3  B1 68        	lda (z80_ix),y		; sprite frame.
001507  3  18           	clc
001508  3  69 01        	adc #1			; next one along.
00150A  3  A0 00        	ldy #0
00150C  3  D1 66        	cmp (z80_hl),y		; reached the last frame?
00150E  3  90 02        	bcc anims0		; no, not yet.
001510  3  A9 00        	lda #0			; start at first frame.
001512  3               anims0:
001512  3  A0 07        	ldy #7
001514  3  91 68        	sta (z80_ix),y		; new frame.
001516  3  60           	rts
001517  3               
001517  3               ;--------------------------------------------------------------
001517  3               ; Animate back
001517  3               ;
001517  3               ; Input:
001517  3               ;  IX = sprite address
001517  3               ;  HL = last sprite address
001517  3               ;--------------------------------------------------------------
001517  3               
001517  3               animbk:
001517  3  25 rr        	and frmno
001519  3  F0 01        	beq :+
00151B  3  60           	rts
00151C  3               :
00151C  3  A0 06        	ldy #6
00151E  3  B1 68        	lda (z80_ix),y		; sprite image.
001520  3  20 55 17     	jsr gfrm		; get frame data.
001523  3               
001523  3  E6 66        	inc z80_l 		; point to frames.
001525  3  D0 02        	bne :+
001527  3  E6 67        	inc z80_h
001529  3               :
001529  3  A0 07        	ldy #7
00152B  3  B1 68        	lda (z80_ix),y 		; sprite frame.
00152D  3  F0 03        	beq :+
00152F  3  4C 36 15     	jmp rtanb0 		; yes, start at end.
001532  3               :
001532  3  A0 00        	ldy #0
001534  3  B1 66        	lda (z80_hl),y 		; last sprite.
001536  3               rtanb0:
001536  3  38           	sec
001537  3  E9 01        	sbc #1			; next one along.
001539  3  4C 12 15     	jmp anims0		; set new frame.
00153C  3               
00153C  3               ;--------------------------------------------------------------
00153C  3               ; Check for collision with other sprite, strict enforcement.
00153C  3               ;
00153C  3               ; Input:
00153C  3               ;  b		= sprite to test for
00153C  3               ;  ix		= current sprite pointer
00153C  3               ;
00153C  3               ; global:	b
00153C  3               ; local:	x,y,hl,de,skptr
00153C  3               ; calls:	-
00153C  3               ;--------------------------------------------------------------
00153C  3               
00153C  3               sktyp:
00153C  3  A9 33        	lda #<sprtab				; sprite table.
00153E  3  85 66        	sta z80_l
001540  3  A9 19        	lda #>sprtab
001542  3  85 67        	sta z80_h
001544  3               numsp2:
001544  3  A9 0C        	lda #NUMSPR				; number of sprites.
001546  3  85 rr        	sta sktptr
001548  3               sktyp0:
001548  3  A5 66        	lda z80_l 				; store pointer to sprite.
00154A  3  85 rr        	sta skptr
00154C  3  A5 67        	lda z80_h
00154E  3  85 rr        	sta skptr+1
001550  3               
001550  3  A0 00        	ldy #0
001552  3  B1 66        	lda (z80_hl),y 				; get sprite type.
001554  3  C5 63        	cmp z80_b				; is it the type we seek?
001556  3  F0 1D        	beq coltyp				; yes, we can use this one.
001558  3               sktyp1:
001558  3  18           	clc
001559  3  A5 rr        	lda skptr				; retrieve sprite pointer.
00155B  3  69 11        	adc #TABSIZ				; size of each entry.
00155D  3  85 66        	sta z80_l
00155F  3  A5 rr        	lda skptr+1
001561  3  69 00        	adc #0
001563  3  85 67        	sta z80_h
001565  3  C6 rr        	dec sktptr					; one less iteration.
001567  3  D0 DF        	bne sktyp0				; keep going until we find a slot.
001569  3  A9 00        	lda #0					; default to ROM address - no sprite.
00156B  3  85 66        	sta z80_l
00156D  3  85 67        	sta z80_h
00156F  3  85 rr        	sta skptr				; store pointer to sprite.
001571  3  85 rr        	sta skptr+1
001573  3               
001573  3  18           	clc					; don't return with zero flag set.
001574  3  60           	rts 					; didn't find one.
001575  3               
001575  3               ;skptr:	.word 0					; search pointer.
001575  3               ;sktptr:	.byte 0
001575  3               
001575  3               coltyp:
001575  3  A0 00        	ldy #0
001577  3  B1 68        	lda (z80_ix),y				; current sprite type.
001579  3  C5 63        	cmp z80_b				; seeking sprite of same type?
00157B  3  F0 3D        	beq colty1				; yes, need to check we're not detecting ourselves.
00157D  3               colty0:
00157D  3  A0 09        	ldy #9					; distance to x position in table.
00157F  3  B1 66        	lda (z80_hl),y				; fetch x coordinate.
001581  3  85 64        	sta z80_e
001583  3  88           	dey
001584  3  B1 66        	lda (z80_hl),y				; fetch y coordinate.
001586  3  85 65        	sta z80_d
001588  3               
001588  3               ; Drop into collision detection.
001588  3               
001588  3               colc16:
001588  3  A0 09        	ldy #9
00158A  3  B1 68        	lda (z80_ix),y			 	; x coord.
00158C  3  38           	sec					; subtract x.
00158D  3  E5 64        	sbc z80_e
00158F  3  B0 05        	bcs  colc1a 				; result is positive.
001591  3  49 FF        	eor #$ff				; make negative positive.
001593  3  18           	clc
001594  3  69 01        	adc #1
001596  3               colc1a:
001596  3  C9 10        	cmp #16 				; within x range?
001598  3  B0 BE        	bcs sktyp1				; no - they"ve missed.
00159A  3  85 62        	sta z80_c				; store difference.
00159C  3               
00159C  3  A0 08        	ldy #8
00159E  3  B1 68        	lda (z80_ix),y				; y coord.
0015A0  3  38           	sec
0015A1  3  E5 65        	sbc z80_d				; subtract y.
0015A3  3  B0 05        	bcs colc1b				; result is positive.
0015A5  3  49 FF        	eor #$ff				; make negative positive.
0015A7  3  18           	clc
0015A8  3  69 01        	adc #1
0015AA  3               colc1b:
0015AA  3  C9 10        	cmp #16					; within y range?
0015AC  3  B0 AA        	bcs sktyp1 				; no - they've missed.
0015AE  3  18           	clc					; add x difference.
0015AF  3  65 62        	adc z80_c
0015B1  3  C9 1A        	cmp #26					; only 5 corner pixels touching?
0015B3  3  B0 02        	bcs :+
0015B5  3  38           	sec
0015B6  3  60           	rts 					; carry set if there's a collision.
0015B7  3               :
0015B7  3  4C 58 15     	jmp sktyp1				; try next sprite in table.
0015BA  3               colty1:
0015BA  3  A5 68        	lda z80_x  				; compare the two.
0015BC  3  C5 66        	cmp z80_l
0015BE  3  D0 09        	bne end_col
0015C0  3  A5 69        	lda z80_i
0015C2  3  C5 67        	cmp z80_h
0015C4  3  D0 03        	bne end_col
0015C6  3  4C 58 15     	jmp sktyp1 				; addresses are identical.
0015C9  3               end_col:
0015C9  3  4C 7D 15     	jmp colty0
0015CC  3               
0015CC  3               ;-----------------------------------------------------------
0015CC  3               ; Display number, left aligned
0015CC  3               ;
0015CC  3               ; Input:
0015CC  3               ;  a		= number
0015CC  3               ;
0015CC  3               ; global:	-
0015CC  3               ; local:	a,y,bc,hl,displ0
0015CC  3               ; calls:	num2ch,dmsg3
0015CC  3               ;-----------------------------------------------------------
0015CC  3               
0015CC  3               disply:
0015CC  3  85 61        	sta z80_a
0015CE  3  A9 F4        	lda #<displ0				; display workspace.
0015D0  3  85 62        	sta z80_c
0015D2  3  A9 15        	lda #>displ0
0015D4  3  85 63        	sta z80_b
0015D6  3  A5 61        	lda z80_a
0015D8  3  20 7A 08     	jsr num2ch				; convert accumulator to string.
0015DB  3               displ1:
0015DB  3  C6 62        	dec z80_c				; back one character.
0015DD  3  D0 02        	bne :+
0015DF  3  C6 63        	dec z80_b
0015E1  3               :
0015E1  3  A0 00        	ldy #0
0015E3  3  B1 62        	lda (z80_bc),y				; fetch digit.
0015E5  3  09 80        	ora #128				; insert end marker.
0015E7  3  91 62        	sta (z80_bc),y				; new value.
0015E9  3               
0015E9  3  A9 F4        	lda #<displ0				; display space.
0015EB  3  85 66        	sta z80_l
0015ED  3  A9 15        	lda #>displ0
0015EF  3  85 67        	sta z80_h
0015F1  3  4C A2 10     	jmp dmsg3				; display the string.
0015F4  3               
0015F4  3  00 00 00 8D  displ0:	.byte 0,0,0,13+128
0015F8  3               
0015F8  3               ;----------------------------------------------------------------
0015F8  3               ; Initialise screen.
0015F8  3               ;
0015F8  3               ; global:	roomtb,scno
0015F8  3               ; local:	-
0015F8  3               ; calls:	tstcs
0015F8  3               ;----------------------------------------------------------------
0015F8  3               
0015F8  3               initsc:
0015F8  3  AD 10 1A     	lda roomtb 			; whereabouts in the map are we?
0015FB  3  20 05 16     	jsr tstsc 			; find displacement.
0015FE  3  C9 FF        	cmp #255 			; is it valid?
001600  3  F0 02        	beq init_end 			; no, it's rubbish.
001602  3  85 rr        	sta scno			; store new room number.
001604  3               init_end:
001604  3  60           	rts
001605  3               
001605  3               ;----------------------------------------------------------------
001605  3               ; Test screen.
001605  3               ;
001605  3               ; global:	-
001605  3               ; local:	x
001605  3               ; calls:	-
001605  3               ;----------------------------------------------------------------
001605  3               
001605  3               tstsc:
001605  3  85 rr        	sta tmproom
001607  3  18           	clc
001608  3  69 03        	adc #MAPWID 			; add width in case we"re negative.
00160A  3  AA           	tax 				; add displacement to map data.
00160B  3  BD 3B 1A     	lda mapdat-MAPWID,x 		; find room number there.
00160E  3  60           	rts
00160F  3               
00160F  3               ;tmproom:	.byte 0
00160F  3               
00160F  3               ;--------------------------
00160F  3               ; Screen left.
00160F  3               ;--------------------------
00160F  3               
00160F  3               scrl:
00160F  3  AD 10 1A     	lda roomtb 			; present room table pointer.
001612  3  38           	sec
001613  3  E9 01        	sbc #1				; room left.
001615  3               scrl0:
001615  3  20 05 16     	jsr tstsc			; test screen.
001618  3  C9 FF        	cmp #255			; is there a screen this way?
00161A  3  D0 01        	bne :+
00161C  3  60           	rts				; no, return to loop.
00161D  3               :
00161D  3  A5 rr        	lda tmproom			; restore room displacement.
00161F  3  8D 10 1A     	sta roomtb			; new room table position.
001622  3               scrl1:
001622  3  20 F8 15     	jsr initsc 			; set new screen.
001625  3  A9 02        	lda #2
001627  3  85 rr        	sta restfl 			; set it.
001629  3  60           	rts
00162A  3               scrr:
00162A  3  AD 10 1A     	lda roomtb 			; room table pointer.
00162D  3  18           	clc
00162E  3  69 01        	adc #1				; room right.
001630  3  4C 15 16     	jmp scrl0
001633  3               scru:
001633  3  AD 10 1A     	lda roomtb 			; room table pointer.
001636  3  38           	sec
001637  3  E9 03        	sbc #MAPWID 			; room up.
001639  3  4C 15 16     	jmp scrl0
00163C  3               scrd:
00163C  3  AD 10 1A     	lda roomtb 			; room table pointer.
00163F  3  18           	clc
001640  3  69 03        	adc #MAPWID 			; room down.
001642  3  4C 15 16     	jmp scrl0
001645  3               
001645  3               ;-----------------------------------------
001645  3               ; Jump to new screen.
001645  3               ;-----------------------------------------
001645  3               
001645  3               nwscr:
001645  3  A2 00        	ldx #0				; start of map data.
001647  3               nwscr0:
001647  3  DD 3E 1A     	cmp mapdat,x
00164A  3  F0 06        	beq nwscr1			; have we found a match for screen?
00164C  3  E8           	inx 				; next room.
00164D  3  E0 50        	cpx #80				; zero room count, 80 to search.
00164F  3  D0 F6        	bne nwscr0			; keep looking.
001651  3  60           	rts
001652  3               nwscr1:
001652  3  8E 10 1A     	stx roomtb			; set the map position.
001655  3  4C 22 16     	jmp scrl1			; draw new room.
001658  3               
001658  3               
001658  3               ;----------------------------------------------------------
001658  3               ; Gravity processing.
001658  3               ;----------------------------------------------------------
001658  3               
001658  3               grav:
001658  3  A0 0D        	ldy #13
00165A  3  B1 68        	lda (z80_ix),y			; jump pointer low.
00165C  3  85 66        	sta z80_l
00165E  3  A0 0E        	ldy #14
001660  3  B1 68        	lda (z80_ix),y			; jump pointer high.
001662  3  85 67        	sta z80_h
001664  3  05 66        	ora z80_l			; merge in low byte.
001666  3  D0 01        	bne :+
001668  3  60           	rts				; if neither is set, we're not in the air.
001669  3               :
001669  3  A0 00        	ldy #0
00166B  3  B1 66        	lda (z80_hl),y			; pixels to move.
00166D  3  85 61        	sta z80_a
00166F  3  C9 63        	cmp #99				; reached the end?
001671  3  D0 0C        	bne grav0			; no, continue.
001673  3               grav2:
001673  3  C6 66        	dec z80_l			; go back to previous value.
001675  3  C9 FF        	cmp #$ff
001677  3  D0 02        	bne :+
001679  3  C6 67        	dec z80_h
00167B  3               :
00167B  3  B1 66        	lda (z80_hl),y			; fetch that from table.
00167D  3  85 61        	sta z80_a
00167F  3               grav0:
00167F  3  E6 66        	inc z80_l			; point to next table entry.
001681  3  D0 02        	bne :+
001683  3  E6 67        	inc z80_h
001685  3               :
001685  3  A5 66        	lda z80_l
001687  3  A0 0D        	ldy #13
001689  3  91 68        	sta (z80_ix),y			; store new pointer low.
00168B  3  A5 67        	lda z80_h
00168D  3  A0 0E        	ldy #14
00168F  3  91 68        	sta (z80_ix),y			; store new pointer high.
001691  3               grav1:
001691  3  A5 61        	lda z80_a
001693  3  D0 01        	bne :+				; any movement required?
001695  3  60           	rts				; no, not this time.
001696  3               :
001696  3  A5 61        	lda z80_a
001698  3  C9 80        	cmp #128			; is it up or down?
00169A  3  B0 15        	bcs gravu			; it's up.
00169C  3               gravd:
00169C  3  85 63        	sta z80_b			; set pixels to move.
00169E  3               gravd0:
00169E  3  20 CA 0C     	jsr cangd			; can we go down?
0016A1  3  D0 28        	bne gravst			; can't move down, so stop.
0016A3  3  A0 08        	ldy #8
0016A5  3  B1 68        	lda (z80_ix),y			; adjust new x coord.
0016A7  3  18           	clc
0016A8  3  69 01        	adc #1
0016AA  3  91 68        	sta (z80_ix),y
0016AC  3  C6 63        	dec z80_b
0016AE  3  D0 EE        	bne gravd0
0016B0  3  60           	rts
0016B1  3               gravu:
0016B1  3  49 FF        	eor #$ff			; flip the sign so it's positive.
0016B3  3  18           	clc
0016B4  3  69 01        	adc #1
0016B6  3  85 63        	sta z80_b			; set pixels to move.
0016B8  3               gravu0:
0016B8  3  20 95 0C     	jsr cangu			; can we go up?
0016BB  3  D0 6E        	bne ifalls			; can't move up, go down next.
0016BD  3  A0 08        	ldy #8
0016BF  3  B1 68        	lda (z80_ix),y
0016C1  3  38           	sec
0016C2  3  E9 01        	sbc #1
0016C4  3  91 68        	sta (z80_ix),y			; adjust new x coord.
0016C6  3  C6 63        	dec z80_b
0016C8  3  D0 EE        	bne gravu0
0016CA  3  60           	rts
0016CB  3               gravst:
0016CB  3  A0 0D        	ldy #13
0016CD  3  B1 68        	lda (z80_ix),y			; jump pointer low.
0016CF  3  85 66        	sta z80_l
0016D1  3  A0 0E        	ldy #14
0016D3  3  B1 68        	lda (z80_ix),y			; jump pointer high.
0016D5  3  85 67        	sta z80_h
0016D7  3               
0016D7  3  A9 00        	lda #0				; null value in pointer.
0016D9  3  A0 0D        	ldy #13
0016DB  3  91 68        	sta (z80_ix),y			; store new pointer low.
0016DD  3  C8           	iny
0016DE  3  91 68        	sta (z80_ix),y			; store new pointer high.
0016E0  3               
0016E0  3  A0 00        	ldy #0
0016E2  3  B1 66        	lda (z80_hl),y			; fetch byte from table.
0016E4  3  C9 63        	cmp #99				; is it the end marker?
0016E6  3               evftf:
0016E6  3  F0 01        	beq :+				; yes, fallen too far.
0016E8  3  60           	rts
0016E9  3               :
0016E9  3  4C B7 1A     	jmp evnt15			; EVENT FELLTOOFAR
0016EC  3               
0016EC  3               ;------------------------------------------------
0016EC  3               ; Initiate fall check.
0016EC  3               ;------------------------------------------------
0016EC  3               
0016EC  3               ifall:
0016EC  3  A0 0D        	ldy #13
0016EE  3  B1 68        	lda (z80_ix),y 			; jump pointer low.
0016F0  3  85 66        	sta z80_l
0016F2  3  A0 0E        	ldy #14
0016F4  3  B1 68        	lda (z80_ix),y 			; jump pointer high.
0016F6  3  85 67        	sta z80_h			; high byte in accumulator.
0016F8  3  05 66        	ora z80_l			; merge in low byte.
0016FA  3  F0 01        	beq :+
0016FC  3  60           	rts				; if either is set, we're already in the air.
0016FD  3               :
0016FD  3  A0 09        	ldy #9
0016FF  3  B1 68        	lda (z80_ix),y			; y coordinate.
001701  3  85 rr        	sta dispx
001703  3  A0 08        	ldy #8
001705  3  B1 68        	lda (z80_ix),y			; look x coordinate.
001707  3  18           	clc
001708  3               numsp7:
001708  3  69 10        	adc #SPR_HGT			; add 16 pixels.
00170A  3  85 rr        	sta dispy			; set up test coordinates.
00170C  3  20 3F 0F     	jsr tstbl			; get map address.
00170F  3  20 6C 0E     	jsr plchk			; block, platform check.
001712  3  F0 01        	beq :+
001714  3  60           	rts				; it's solid, don't fall.
001715  3               :
001715  3  E6 rr        	inc bufaddr			; look right one cell.
001717  3  20 6C 0E     	jsr plchk			; block, platform check.
00171A  3  F0 01        	beq :+
00171C  3  60           	rts				; it's solid, don't fall.
00171D  3               :
00171D  3  A5 rr        	lda dispx			; y coordinate.
00171F  3  29 07        	and #7				; position straddling block cells.
001721  3  F0 08        	beq ifalls			; no more checks needed.
001723  3  E6 rr        	inc bufaddr			; look to third cell.
001725  3  20 6C 0E     	jsr plchk			; block, platform check.
001728  3  F0 01        	beq :+
00172A  3  60           	rts				; it's solid, don't fall.
00172B  3               :
00172B  3               ifalls:
00172B  3  A9 B0        	lda #<jtab			; jump table start.
00172D  3  85 66        	sta z80_l
00172F  3  A9 1E        	lda #>jtab
001731  3  85 67        	sta z80_h
001733  3               ifal0:
001733  3  E6 66        	inc z80_l			; point to next value.
001735  3  D0 02        	bne :+
001737  3  E6 67        	inc z80_h
001739  3               :
001739  3  A0 00        	ldy #0
00173B  3  B1 66        	lda (z80_hl),y			; fetch value.
00173D  3  F0 F4        	beq ifal0			; no, get next value.
00173F  3  C9 63        	cmp #99				; reached end of table?
001741  3  D0 01        	bne :+
001743  3  60           	rts				; yes, don't fall.
001744  3               :
001744  3  C9 80        	cmp #128			; is it going up?
001746  3  B0 EB        	bcs ifal0			; yes, looking for first movement down.
001748  3               
001748  3  A0 0D        	ldy #13
00174A  3  A5 66        	lda z80_l
00174C  3  91 68        	sta (z80_ix),y 			; set jump low.
00174E  3  A0 0E        	ldy #14
001750  3  A5 67        	lda z80_h
001752  3  91 68        	sta (z80_ix),y 			; set jump high.
001754  3  60           	rts
001755  3               
001755  3               
001755  3               ;----------------------------------------------------
001755  3               ; Get frame data for a particular sprite.
001755  3               ; Input:
001755  3               ;  a		= framenumer
001755  3               ; Output:
001755  3               ;  hl		= frame address
001755  3               ;
001755  3               ; global:	hl,frmptr
001755  3               ; local:	-
001755  3               ; calls:	-
001755  3               ;----------------------------------------------------
001755  3               
001755  3               gfrm:
001755  3  0A           	asl a	 		 	; multiple of 2.
001756  3  18           	clc
001757  3  6D 3D 06     	adc frmptr 			; frames used by game.
00175A  3  85 66        	sta z80_l
00175C  3  AD 3E 06     	lda frmptr+1
00175F  3  69 00        	adc #0
001761  3  85 67        	sta z80_h 			; point to frame start.
001763  3  60           	rts
001764  3               
001764  3               ;----------------------------------------------------
001764  3               ; Find sprite list for current room.
001764  3               ;
001764  3               ; global:	hl
001764  3               ; local:	x,y
001764  3               ; calls:	-
001764  3               ;----------------------------------------------------
001764  3               
001764  3               sprlst:
001764  3  A9 85        	lda #<nmedat 			; list of enemy sprites.
001766  3  85 66        	sta z80_l
001768  3  A9 1B        	lda #>nmedat
00176A  3  85 67        	sta z80_h
00176C  3  A6 rr        	ldx scno 			; screen number.
00176E  3  D0 01        	bne sprls2 			; is it the first screen?
001770  3  60           	rts 				; yes, don't need to search data.
001771  3               sprls2:
001771  3  A0 00        	ldy #0
001773  3               sprls1:
001773  3  B1 66        	lda (z80_hl),y 			; fetch type of sprite.
001775  3  C9 FF        	cmp #255			; is it an end marker?
001777  3  F0 0E        	beq sprls0 			; yes, end of this room.
001779  3               
001779  3  18           	clc 				; point to next sprite in list.
00177A  3  A5 66        	lda z80_l
00177C  3  69 04        	adc #NMESIZ
00177E  3  85 66        	sta z80_l
001780  3  90 02        	bcc :+
001782  3  E6 67        	inc z80_h
001784  3               :
001784  3  4C 73 17     	jmp sprls1 			; continue until end of room.
001787  3               sprls0:
001787  3  E6 66        	inc z80_l 			; point to start of next screen.s
001789  3  D0 02        	bne :+
00178B  3  E6 67        	inc z80_h
00178D  3               :
00178D  3  CA           	dex
00178E  3  D0 E3        	bne sprls1 			; continue until room found.
001790  3  60           	rts
001791  3               
001791  3               
001791  3               ;----------------------------------------------------
001791  3               ; Clear all but a single player sprite.
001791  3               ;
001791  3               ; global:	-
001791  3               ; local:	x,y,ix
001791  3               ; calls:	-
001791  3               ;----------------------------------------------------
001791  3               
001791  3               nspr:
001791  3  A9 0C        	lda #NUMSPR			; sprite slots in table.
001793  3  85 rr        	sta sprcnt
001795  3  A9 33        	lda #<sprtab 			; sprite table.
001797  3  85 68        	sta z80_x
001799  3  A9 19        	lda #>sprtab
00179B  3  85 69        	sta z80_i
00179D  3               nspr0:
00179D  3  A0 00        	ldy #0 				; fetch sprite type.
00179F  3  B1 68        	lda (z80_ix),y 			; is it a player?
0017A1  3  F0 1A        	beq nspr1 			; yes, keep this one.
0017A3  3               
0017A3  3  A9 FF        	lda #255
0017A5  3  A0 00        	ldy #0 				; fetch sprite type.
0017A7  3  91 68        	sta (z80_ix),y 			; delete sprite.
0017A9  3  A0 05        	ldy #5
0017AB  3  91 68        	sta (z80_ix),y 			; remove next type.
0017AD  3               
0017AD  3  18           	clc	 			; next sprite.
0017AE  3  A5 68        	lda z80_x
0017B0  3  69 11        	adc #TABSIZ 			; distance to next odd/even entry.
0017B2  3  85 68        	sta z80_x
0017B4  3  90 02        	bcc :+
0017B6  3  E6 69        	inc z80_i
0017B8  3               :
0017B8  3  C6 rr        	dec sprcnt	 			; one less space in the table.
0017BA  3  D0 E1        	bne nspr0
0017BC  3  60           	rts
0017BD  3               nspr1:
0017BD  3  A9 FF        	lda #255
0017BF  3  A0 00        	ldy #0
0017C1  3  91 68        	sta (z80_ix),y 			; delete sprite.
0017C3  3               
0017C3  3  18           	clc	 			; point to next sprite.
0017C4  3  A5 68        	lda z80_x
0017C6  3  69 11        	adc #TABSIZ 			; distance to next odd/even entry.
0017C8  3  85 68        	sta z80_x
0017CA  3  90 02        	bcc :+
0017CC  3  E6 69        	inc z80_i
0017CE  3               :
0017CE  3  C6 rr        	dec sprcnt	 			; one less to do.
0017D0  3  D0 01        	bne nspr2
0017D2  3  60           	rts
0017D3  3               nspr2:
0017D3  3  A9 FF        	lda #255
0017D5  3  A0 00        	ldy #0
0017D7  3  91 68        	sta (z80_ix),y 			; delete sprite.
0017D9  3  A0 05        	ldy #5
0017DB  3  91 68        	sta (z80_ix),y 			; remove next type.
0017DD  3               
0017DD  3  18           	clc	 			; next sprite.
0017DE  3  A5 68        	lda z80_x
0017E0  3  69 11        	adc #TABSIZ 			; distance to next odd/even entry.
0017E2  3  85 68        	sta z80_x
0017E4  3  90 02        	bcc :+
0017E6  3  E6 69        	inc z80_i
0017E8  3               :
0017E8  3  C6 rr        	dec sprcnt	 			; one less space in table.
0017EA  3  D0 E7        	bne nspr2
0017EC  3  60           	rts
0017ED  3               
0017ED  3               ;----------------------------------------------------------
0017ED  3               ; Two initialisation routines.
0017ED  3               ; Initialise sprites - copy everything from list to table.
0017ED  3               ;
0017ED  3               ; global:	-
0017ED  3               ; local:	x,y,ix
0017ED  3               ; calls:	cpsp
0017ED  3               ;----------------------------------------------------------
0017ED  3               
0017ED  3               ispr:
0017ED  3  A9 0C        	lda #NUMSPR			; sprite slots in table.
0017EF  3  85 rr        	sta sprcnt
0017F1  3  A9 33        	lda #<sprtab			; sprite table.
0017F3  3  85 68        	sta z80_x
0017F5  3  A9 19        	lda #>sprtab
0017F7  3  85 69        	sta z80_i
0017F9  3               ispr2:
0017F9  3  A0 00        	ldy #0
0017FB  3  B1 66        	lda (z80_hl),y 			; fetch byte.
0017FD  3  C9 FF        	cmp #255 			; is it an end marker?
0017FF  3  D0 01        	bne :+
001801  3  60           	rts 				; yes, no more to do.
001802  3               :
001802  3               ispr1:
001802  3  A0 00        	ldy #0
001804  3  B1 68        	lda (z80_ix),y 			; fetch sprite type.
001806  3  C9 FF        	cmp #255 			; is it enabled yet?
001808  3  D0 08        	bne ispr4			; yes, try another slot.
00180A  3               
00180A  3  A0 05        	ldy #5
00180C  3  B1 68        	lda (z80_ix),y		 	; next type.
00180E  3  C9 FF        	cmp #255 			; is it enabled yet?
001810  3  F0 10        	beq ispr3 			; no, process this one.
001812  3               ispr4:
001812  3  18           	clc 				; next sprite.
001813  3  A5 68        	lda z80_x
001815  3  69 11        	adc #TABSIZ		 	; distance to next odd/even entry.
001817  3  85 68        	sta z80_x
001819  3  90 02        	bcc :+
00181B  3  E6 69        	inc z80_i
00181D  3               :
00181D  3  C6 rr        	dec sprcnt
00181F  3  D0 E1        	bne ispr1 			; repeat for remaining sprites.
001821  3  60           	rts  				; no more room in table.
001822  3               ispr3:
001822  3  20 75 18     	jsr cpsp			; initialise a sprite.
001825  3  C6 rr        	dec sprcnt			; one less space in the table.
001827  3  D0 D0        	bne ispr2
001829  3  60           	rts
00182A  3               
00182A  3               
00182A  3               ;-----------------------------------------------------------------------
00182A  3               ; Initialise sprites - but not player, we're keeping the old one.
00182A  3               ;
00182A  3               ; global:	-
00182A  3               ; local:	x,y,ix
00182A  3               ; calls:	cpsp
00182A  3               ;-----------------------------------------------------------------------
00182A  3               
00182A  3               kspr:
00182A  3  A2 0C        	ldx #NUMSPR			; sprite slots in table.
00182C  3  A9 33        	lda #<sprtab 			; sprite table.
00182E  3  85 68        	sta z80_x
001830  3  A9 19        	lda #>sprtab
001832  3  85 69        	sta z80_i
001834  3               kspr2:
001834  3  A0 00        	ldy #0
001836  3  B1 66        	lda (z80_hl),y 			; fetch byte.
001838  3  C9 FF        	cmp #255 			; is it an end marker?
00183A  3  D0 01        	bne :+
00183C  3  60           	rts 				; yes, no more to do.
00183D  3               :
00183D  3  C9 00        	cmp #0
00183F  3  D0 0E        	bne kspr1 			; no, add to table as normal.
001841  3               
001841  3  18           	clc 				; next sprite.
001842  3  A5 66        	lda z80_l
001844  3  69 04        	adc #NMESIZ		 	; distance to next odd/even entry.
001846  3  85 66        	sta z80_l
001848  3  90 02        	bcc :+
00184A  3  E6 67        	inc z80_h
00184C  3               :
00184C  3  4C 34 18     	jmp kspr2
00184F  3               kspr1:
00184F  3  A0 00        	ldy #0 				; fetch sprite type.
001851  3  B1 68        	lda (z80_ix),y
001853  3  C9 FF        	cmp #255 			; is it enabled yet?
001855  3  D0 08        	bne kspr4 			; yes, try another slot.
001857  3               
001857  3  A0 05        	ldy #5 				; next type.
001859  3  B1 68        	lda (z80_ix),y
00185B  3  C9 FF        	cmp #255 			; is it enabled yet?
00185D  3  F0 0F        	beq kspr3 			; no, process this one.
00185F  3               kspr4:
00185F  3  18           	clc 				; next sprite.
001860  3  A5 68        	lda z80_x
001862  3  69 11        	adc #TABSIZ		 	; distance to next odd/even entry.
001864  3  85 68        	sta z80_x
001866  3  90 02        	bcc :+
001868  3  E6 69        	inc z80_i
00186A  3               :
00186A  3  CA           	dex	 			; repeat for remaining sprites.
00186B  3  D0 E2        	bne kspr1
00186D  3  60           	rts  				; no more room in table.
00186E  3               kspr3:
00186E  3  20 75 18     	jsr cpsp 			; copy sprite to table.
001871  3  CA           	dex	 			; one less space in the table.
001872  3  D0 C0        	bne kspr2
001874  3  60           	rts
001875  3               
001875  3               ;----------------------------------------------
001875  3               ; Copy sprite from list to table.
001875  3               ;
001875  3               ; global:	hl,ix
001875  3               ; local:	y
001875  3               ; calls:	evnt09
001875  3               ;----------------------------------------------
001875  3               
001875  3               cpsp:
001875  3  A0 00        	ldy #0				; fetch byte from table.
001877  3  B1 66        	lda (z80_hl),y
001879  3  91 68        	sta (z80_ix),y			; set up type.
00187B  3  A0 05        	ldy #PAM1ST
00187D  3  91 68        	sta (z80_ix),y 			; set up type.
00187F  3               
00187F  3  E6 66        	inc z80_l 			; move to next byte.
001881  3  D0 02        	bne :+
001883  3  E6 67        	inc z80_h
001885  3               :
001885  3  A0 00        	ldy #0 				; fetch byte from table.
001887  3  B1 66        	lda (z80_hl),y
001889  3  A0 06        	ldy #6
00188B  3  91 68        	sta (z80_ix),y			; set up image.
00188D  3               
00188D  3  E6 66        	inc z80_l 			; move to next byte.
00188F  3  D0 02        	bne :+
001891  3  E6 67        	inc z80_h
001893  3               :
001893  3  A0 00        	ldy #0
001895  3  B1 66        	lda (z80_hl),y 			; fetch byte from table.
001897  3  A0 08        	ldy #8
001899  3  91 68        	sta (z80_ix),y 			; set up coordinate.
00189B  3               
00189B  3  A9 C8        	lda #200 			; set initial coordinate off screen.
00189D  3  A0 03        	ldy #3
00189F  3  91 68        	sta (z80_ix),y
0018A1  3               
0018A1  3  E6 66        	inc z80_l 			; move to next byte.
0018A3  3  D0 02        	bne :+
0018A5  3  E6 67        	inc z80_h
0018A7  3               :
0018A7  3  A0 00        	ldy #0 				; fetch byte from table.
0018A9  3  B1 66        	lda (z80_hl),y
0018AB  3  A0 09        	ldy #9
0018AD  3  91 68        	sta (z80_ix),y 			; set up coordinate.
0018AF  3               
0018AF  3  E6 66        	inc z80_l 			; move to next byte.
0018B1  3  D0 02        	bne :+
0018B3  3  E6 67        	inc z80_h
0018B5  3               :
0018B5  3  A9 00        	lda #0				; zeroes in accumulator.
0018B7  3  A0 07        	ldy #7 				; reset frame number.
0018B9  3  91 68        	sta (z80_ix),y
0018BB  3  A0 0A        	ldy #10 			; reset direction.
0018BD  3  91 68        	sta (z80_ix),y
0018BF  3  A0 0D        	ldy #13				; reset jump pointer low.
0018C1  3  91 68        	sta (z80_ix),y
0018C3  3  A0 0E        	ldy #14	 			; reset jump pointer high.
0018C5  3  91 68        	sta (z80_ix),y
0018C7  3               
0018C7  3  A9 FF        	lda #255 			; reset data pointer to auto-restore.
0018C9  3  A0 10        	ldy #16
0018CB  3  91 68        	sta (z80_ix),y
0018CD  3               evis0:
0018CD  3  A5 69        	lda z80_i
0018CF  3  48           	pha
0018D0  3  A5 68        	lda z80_x
0018D2  3  48           	pha
0018D3  3  A5 67        	lda z80_h
0018D5  3  48           	pha
0018D6  3  A5 66        	lda z80_l
0018D8  3  48           	pha
0018D9  3               
0018D9  3  20 4E 1A     	jsr evnt09 			; perform event.
0018DC  3               
0018DC  3  68           	pla
0018DD  3  85 66        	sta z80_l
0018DF  3  68           	pla
0018E0  3  85 67        	sta z80_h
0018E2  3  68           	pla
0018E3  3  85 68        	sta z80_x
0018E5  3  68           	pla
0018E6  3  85 69        	sta z80_i
0018E8  3               
0018E8  3  18           	clc
0018E9  3  A5 68        	lda z80_x 			; distance to next odd/even entry.
0018EB  3  69 11        	adc #TABSIZ		 	; next sprite.
0018ED  3  85 68        	sta z80_x
0018EF  3  90 02        	bcc :+
0018F1  3  E6 69        	inc z80_i
0018F3  3               :
0018F3  3  60           	rts
0018F4  3               
0018F4  3               
0018F4  3               ;-------------------------------------
0018F4  3               ; Clear the play area window.
0018F4  3               ;-------------------------------------
0018F4  3               
0018F4  3               clw:
0018F4  3  AD 49 06     	lda wintop			; get coordinates of window.
0018F7  3  85 rr        	sta dispy			; put into dispx for calculation.
0018F9  3  AD 4A 06     	lda winlft
0018FC  3  85 rr        	sta dispx
0018FE  3               
0018FE  3  AD 4B 06     	lda winhgt			; height of window.
001901  3  85 rr        	sta rrow			; copy to b register.
001903  3               clw3:
001903  3  AD 4C 06     	lda winwid 			; width of window.
001906  3  85 rr        	sta rcol
001908  3               clw2:
001908  3  20 11 0B     	jsr gprad 			; get print address.
00190B  3  A9 00        	lda #0				; zero byte to write.
00190D  3  A2 07        	ldx #7				; pixel height of each cell.
00190F  3               clw1:
00190F  3  BC 97 0B     	ldy scrtab,x
001912  3  91 rr        	sta (scraddr),y 			; copy to screen.
001914  3  CA           	dex				; next screen row down.
001915  3  10 F8        	bpl clw1
001917  3               
001917  3  E6 rr        	inc dispx			; next column.
001919  3  C6 rr        	dec rcol			; one less to do.
00191B  3  D0 EB        	bne clw2			; repeat for remaining columns.
00191D  3               
00191D  3  AD 4A 06     	lda winlft			; get left edge.
001920  3  85 rr        	sta dispx 			; reset x.
001922  3  E6 rr        	inc dispy 			; next line down.
001924  3               
001924  3  C6 rr        	dec rrow
001926  3  D0 DB        	bne clw3			; repeat down the screen.
001928  3               
001928  3  AD 49 06     	lda wintop			; get coordinates of window.
00192B  3  85 rr        	sta chary			; put into display position.
00192D  3  AD 4A 06     	lda winlft
001930  3  85 rr        	sta charx
001932  3  60           	rts
001933  3               
001933  3               
001933  3               ;----------------------------------------------------------
001933  3               ; Effects code.
001933  3               ; Ticker routine is called 25 times per second.
001933  3               ;
001933  3               ; HL = txtscr = left text screen address
001933  3               ; DE = txtscr+txtwid-1 = right text screen address
001933  3               ; BC = txtpos = text scroller position
001933  3               ;
001933  3               ;----------------------------------------------------------
001933  3               
001933  3               .if sflag
001933  3               scrly:
001933  3               	rts
001933  3               	.word txtscr         	; get left screen address.
001933  3               	sta scr_l
001933  3               	lda txtscr+1
001933  3               	sta scr_l+1
001933  3               	sta scr_r+1
001933  3               
001933  3               	stx xtmp
001933  3               
001933  3               	clc         		; get right screen address.
001933  3               	lda scr_l
001933  3               	adc txtwid
001933  3               	sta scr_r
001933  3               	dec scr_r
001933  3               scrly1:
001933  3               	ldy txtwid		; set txtwide
001933  3               	dey
001933  3               	clc
001933  3               scrly0:
001933  3               	lda (scr_l),y		; scroll 1 line
001933  3               	rol a
001933  3               	sta (scr_l),y
001933  3               	dey
001933  3               	bpl scrly0
001933  3               
001933  3               	clc			; point to next line
001933  3               	lda scr_l
001933  3               	adc #32
001933  3               	sta scr_l
001933  3               	bcc scrly1		; repeat 8 times
001933  3               
001933  3               	lda txtpos 		; get text pointer.
001933  3               	sta scr_txt
001933  3               	lda txtpos+1
001933  3               	sta scr_txt+1
001933  3               
001933  3               	ldy #0
001933  3               	lda (scr_txt),y 		; find character we're displaying.
001933  3               	and #127 		; remove end marker bit if applicable.
001933  3               	cmp #13			; is it newline?
001933  3               	bne scrly5 		; no, it's okay.
001933  3               	lda #32			; convert to a space instead.
001933  3               scrly5:
001933  3               	sta fntaddr		; calculate char address
001933  3               	lda #0
001933  3               	sta fntaddr+1
001933  3               	asl fntaddr  		; multiply char by 8.
001933  3               	rol fntaddr+1
001933  3               	asl fntaddr
001933  3               	rol fntaddr+1
001933  3               	asl fntaddr
001933  3               	rol fntaddr+1
001933  3               	lda fntaddr
001933  3               	clc
001933  3               	adc #<(FONT-256)
001933  3               	sta scrly3+1		; that's the low byte.
001933  3               	lda fntaddr+1
001933  3               	adc #>(FONT-256)
001933  3               	sta scrly3+2		; add displacement.
001933  3               
001933  3               	ldx #0
001933  3               scrly3:
001933  3               	lda $3333,x		; get image of char line.
001933  3               	and txtbit
001933  3               	beq scrly2		; don't plot pixel
001933  3               	ldy scrline,x
001933  3               	lda (scr_r),y
001933  3               	clc
001933  3               	ora #1
001933  3               	sta (scr_r),y		; plot pixel
001933  3               scrly2:
001933  3               	inx			; next line of char.
001933  3               	cpx #8
001933  3               	bne scrly3
001933  3               
001933  3               	lsr txtbit		; bit of text to display.
001933  3               	bcs :+
001933  3               	rts
001933  3               :
001933  3               	ldy #0
001933  3               	lda (scr_txt),y 	; what was the character?
001933  3               	asl a	  		; end of message?
001933  3               	bcs scrly4
001933  3               	inc txtpos
001933  3               	bne :+
001933  3               	inc txtpos+1
001933  3               :
001933  3               	jmp scrly6 		; not yet - continue.
001933  3               scrly4:
001933  3               	lda txtini 		; start of scrolling message.
001933  3               	sta txtpos
001933  3               	lda txtini+1
001933  3               	sta txtpos+1
001933  3               scrly6:
001933  3               	lda #128
001933  3               	sta txtbit
001933  3               	ldx xtmp
001933  3               	rts
001933  3               
001933  3               scrline:	.byte $00,$20,$40,$60,$80,$a0,$c0,$e0
001933  3               
001933  3               ;-------------------------------------------------------
001933  3               ; Entry TICKER command
001933  3               ;
001933  3               ; Entry:
001933  3               ;  z80_b = message nr
001933  3               ;  z80_c = width
001933  3               ;-------------------------------------------------------
001933  3               
001933  3               iscrly:
001933  3               	jsr prescr 		; set up display position.
001933  3               
001933  3               	lda #<msgdat 		; text messages.
001933  3               	sta z80_l
001933  3               	lda #>msgdat
001933  3               	sta z80_h
001933  3               
001933  3               	lda z80_c 		; width.
001933  3               	sec
001933  3               	sbc #1			; subtract one.
001933  3               	cmp #32 		; is it between 1 and 32?
001933  3               	bcc :+
001933  3               	lda #$60
001933  3               	jmp iscrl0		; no, disable messages.
001933  3               :
001933  3               	ldx z80_b		; message number.
001933  3               	jsr getwrd 		; find message start.
001933  3               
001933  3               	lda z80_l		; set initial text position.
001933  3               	sta txtini
001933  3               	lda z80_h
001933  3               	sta txtini+1
001933  3               
001933  3               	lda #$ad		; code for lda adrr
001933  3               iscrl0:
001933  3               	sta scrly		; enable/disable scrolling routine.
001933  3               
001933  3               	jsr prescr 		; set up display position.
001933  3               	jsr gprad 		; get print address.
001933  3               
001933  3               	lda scraddr 		; set text screen address.
001933  3               	sta txtscr
001933  3               	lda scraddr+1
001933  3               	sta txtscr+1
001933  3               
001933  3               	lda z80_c		; width.
001933  3               	sta txtwid		; set width in working storage.
001933  3               
001933  3               	lda #128 		; start with leftmost bit.
001933  3               	sta txtbit
001933  3               
001933  3               	jmp scrly4
001933  3               .endif
001933  3               
001933  3               ;------------------------------------------------------------------
001933  3               ; Dig routine, conditional assembly depending on dflag
001933  3               ;------------------------------------------------------------------
001933  3               .if dflag
001933  3               dig:
001933  3               	and #3
001933  3               	beq digr		; dig right
001933  3               	cmp #1
001933  3               	beq digl		; dig left
001933  3               	cmp #2
001933  3               	beq digd		; dig down
001933  3               
001933  3               ; Dig up.
001933  3               
001933  3               digu:				; dig up
001933  3               	ldy #8
001933  3               	lda (z80_ix),y
001933  3               	sec
001933  3               	sbc #2
001933  3               	sta dispy		; set y
001933  3               
001933  3               	iny
001933  3               	lda (z80_ix),y
001933  3               	sta dispx		; set x
001933  3               	jmp digv
001933  3               
001933  3               ; Dig down.
001933  3               
001933  3               digd:
001933  3               	ldy #9
001933  3               	lda (z80_ix),y
001933  3               	sta dispx		; set y
001933  3               
001933  3               	dey
001933  3               	clc
001933  3               	lda (z80_ix),y
001933  3               	adc #16
001933  3               	sta dispy		; set y
001933  3               	jmp digv
001933  3               
001933  3               ; Dig left.
001933  3               
001933  3               digl:
001933  3               	ldy #8
001933  3               	lda (z80_ix),y
001933  3               	sta dispy		; set y
001933  3               
001933  3               	iny
001933  3               	lda (z80_ix),y
001933  3               	sec
001933  3               	sbc #2			; x=x-2
001933  3               	sta dispx		; set x
001933  3               	jmp digh
001933  3               
001933  3               ; Dig right.
001933  3               
001933  3               digr:
001933  3               	ldy #8
001933  3               	lda (z80_ix),y
001933  3               	sta dispy		; set y
001933  3               
001933  3               	iny
001933  3               	lda (z80_ix),y
001933  3               	clc
001933  3               	adc #16
001933  3               	sta dispx		; set x+16
001933  3               	jmp digh
001933  3               
001933  3               ; Vertical digging
001933  3               
001933  3               digv:
001933  3               	jsr tstbl		; check blocktype in MAP
001933  3               	jsr fdchk		; test if FODDER
001933  3               
001933  3               	clc
001933  3               	lda dispx		; look 1 cell down
001933  3               	adc #8
001933  3               	sta dispx
001933  3               	jsr tstbl		; check blocktype in MAP
001933  3               	jsr fdchk
001933  3               	lda dispx
001933  3               	and #7
001933  3               	bne :+
001933  3               	rts
001933  3               :
001933  3               	clc
001933  3               	lda dispx		; look 1 cell down
001933  3               	adc #8
001933  3               	sta dispx
001933  3               	jsr tstbl		; check blocktype in MAP
001933  3               	jmp fdchk
001933  3               
001933  3               ; Horizontal digging
001933  3               
001933  3               digh:
001933  3               	jsr tstbl		; check blocktype in MAP
001933  3               	jsr fdchk		; test if FODDER
001933  3               
001933  3               	clc
001933  3               	lda dispy		; look 1 cell down
001933  3               	adc #8
001933  3               	sta dispy
001933  3               	jsr tstbl		; check blocktype in MAP
001933  3               	jsr fdchk
001933  3               	lda dispy
001933  3               	and #7
001933  3               	bne :+
001933  3               	rts
001933  3               :
001933  3               	clc
001933  3               	lda dispy		; look 1 cell down
001933  3               	adc #8
001933  3               	sta dispy
001933  3               	jsr tstbl		; check blocktype in MAP
001933  3               	jmp fdchk
001933  3               
001933  3               digcnt:	.byte 0
001933  3               
001933  3               .endif
001933  3               
001933  3               ;------------------------------------------------------------------
001933  3               ; Sprite table
001933  3               ;------------------------------------------------------------------
001933  3               
001933  3               
001933  3               ; ix+0  = type.
001933  3               ; ix+1  = sprite image number.
001933  3               ; ix+2  = frame.
001933  3               ; ix+3  = y coord.
001933  3               ; ix+4  = x coord.
001933  3               
001933  3               ; ix+5  = new type.
001933  3               ; ix+6  = new image number.
001933  3               ; ix+7  = new frame.
001933  3               ; ix+8  = new y coord.
001933  3               ; ix+9  = new x coord.
001933  3               
001933  3               ; ix+10 = direction.
001933  3               ; ix+11 = parameter 1.
001933  3               ; ix+12 = parameter 2.
001933  3               ; ix+13 = jump pointer low.
001933  3               ; ix+14 = jump pointer high.
001933  3               ; ix+15 = data pointer low.
001933  3               ; ix+16 = data pointer high.
001933  3               
001933  3               ; block NUMSPR * TABSIZ,255
001933  3               
001933  3  FF FF FF FF  sprtab:	.res NUMSPR*TABSIZ,255
001937  3  FF FF FF FF  
00193B  3  FF FF FF FF  
0019FF  3  FF FF FF FF  ssprit:	.byte 255,255,255,255,255,255,255,0,192,120,0,0,0,255,255,255,255
001A03  3  FF FF FF 00  
001A07  3  C0 78 00 00  
001A10  3  07           roomtb:	.byte 7                      ; start room map offset.
001A11  3               
001A11  3               ; User routine.  Put your own code in here to be called with USER instruction.
001A11  3               ; if USER has an argument it will be passed in the accumulator.
001A11  3               
001A11  3               user:
001A11  3               	.include "user.inc"
001A11  4  60           	rts
001A12  4               
001A12  3               
001A12  3               ;----------------------------------------------------
001A12  3               ; Missing vars
001A12  3               ;----------------------------------------------------
001A12  3               
001A12  3               MAP 		= $9800			; properties map buffer (3x256 bytes)
001A12  3               SCADTB_lb 	= MAP+3*256		; screen address table lo-byte (256 bytes)
001A12  3               SCADTB_hb 	= SCADTB_lb+256		; screen address table hi-byte (256 bytes)
001A12  3               SHRAPN 		= SCADTB_hb+256		; shrapnel table (55x6 bytes)
001A12  3               
001A12  3               ;Fontpointer:	.byte 0,0
001A12  3               ;TmpAddr:	.byte 0,0
001A12  3               
001A12  3               ;loopa:		.byte 0
001A12  3               ;loopb:		.byte 0
001A12  3               ;loopc:		.byte 0
001A12  3               
001A12  3               setfgcol:
001A12  3  29 03        	and #3
001A14  3  A8           	tay
001A15  3  B9 37 1A     	lda codcol,y
001A18  3  4C 2E 1A     	jmp calfgc
001A1B  3               
001A1B  3               setbgcol:
001A1B  3  29 03        	and #3
001A1D  3               calbgc:
001A1D  3  A8           	tay
001A1E  3  B9 37 1A     	lda codcol,y
001A21  3  48           	pha
001A22  3  AD 35 1A     	lda andeor
001A25  3  4D 36 1A     	eor andeor+1
001A28  3  AA           	tax
001A29  3  68           	pla
001A2A  3  8D 36 1A     	sta andeor+1
001A2D  3  8A           	txa
001A2E  3               calfgc:
001A2E  3  4D 36 1A     	eor andeor+1
001A31  3  8D 35 1A     	sta andeor
001A34  3               calex1:
001A34  3  60           	rts
001A35  3               
001A35  3  00 00        andeor:	.byte 0,0
001A37  3  00 55 AA FF  codcol:	.byte $00,$55,$aa,$ff
001A3B  3               
001A3B  3               ; Everything below here will be generated by the editors.
001A3B  3               
001A3B  3               WINDOWTOP = 1
001A3B  3               WINDOWLFT = 1
001A3B  3               WINDOWHGT = 22
001A3B  3               WINDOWWID = 30 ;a
001A3B  3               MAPWID = 3
001A3B  3  FF FF FF             .byte 255,255,255
001A3E  3               mapdat:
001A3E  3  FF 00 FF             .byte 255,0,255
001A41  3  FF FF FF             .byte 255,255,255
001A44  3  01           stmap:  .byte 1
001A45  3               
001A45  3               evnt00:
001A45  3  60                   rts
001A46  3               evnt01:
001A46  3  60                   rts
001A47  3               evnt02:
001A47  3  60                   rts
001A48  3               evnt03:
001A48  3  60                   rts
001A49  3               evnt04:
001A49  3  60                   rts
001A4A  3               evnt05:
001A4A  3  60                   rts
001A4B  3               evnt06:
001A4B  3  60                   rts
001A4C  3               evnt07:
001A4C  3  60                   rts
001A4D  3               evnt08:
001A4D  3  60                   rts
001A4E  3               evnt09:
001A4E  3  60                   rts
001A4F  3               evnt10:
001A4F  3  A9 00                lda #0		; AT
001A51  3  85 rr                sta chary
001A53  3  A9 01                lda #1
001A55  3  85 rr                sta charx
001A57  3  A9 01                lda #1		; PRINTMODE
001A59  3  85 rr                sta prtmod
001A5B  3  A9 00                lda #0		; PRINT
001A5D  3  20 96 10             jsr dmsg
001A60  3  A9 00                lda #0		; PRINTMODE
001A62  3  85 rr                sta prtmod
001A64  3  A9 03                lda #3		; AT
001A66  3  85 rr                sta chary
001A68  3  A9 01                lda #1
001A6A  3  85 rr                sta charx
001A6C  3  A9 01                lda #1		; PRINT
001A6E  3  20 96 10             jsr dmsg
001A71  3  A5 rr                lda clock	; DISPLAY
001A73  3  20 CC 15             jsr disply
001A76  3  A9 02                lda #2		; PRINT
001A78  3  20 96 10             jsr dmsg
001A7B  3  A9 06                lda #6		; AT
001A7D  3  85 rr                sta chary
001A7F  3  A9 01                lda #1
001A81  3  85 rr                sta charx
001A83  3  A9 03                lda #3		; PRINT
001A85  3  20 96 10             jsr dmsg
001A88  3  A5 rr                lda clock		; DISPLAYCLOCK
001A8A  3  85 65                sta z80_d
001A8C  3  A9 3C                lda #60
001A8E  3  85 64                sta z80_e
001A90  3  20 0B 09             jsr idiv
001A93  3  48                   pha
001A94  3  A5 65                lda z80_d
001A96  3  20 CC 15             jsr disply
001A99  3  E6 rr                inc charx
001A9B  3  A9 F4                lda #<displ0
001A9D  3  85 62                sta z80_c
001A9F  3  A9 15                lda #>displ0
001AA1  3  85 63                sta z80_b
001AA3  3  68                   pla
001AA4  3  20 BD 08             jsr num2dd
001AA7  3  20 DB 15             jsr displ1
001AAA  3  A9 04                lda #4		; PRINT
001AAC  3  20 96 10             jsr dmsg
001AAF  3  60                   rts
001AB0  3               evnt11:
001AB0  3  60                   rts
001AB1  3               evnt12:
001AB1  3  20 05 07             jsr cls		; CLS
001AB4  3  60                   rts
001AB5  3               evnt13:
001AB5  3  60                   rts
001AB6  3               evnt14:
001AB6  3  60                   rts
001AB7  3               evnt15:
001AB7  3  60                   rts
001AB8  3               evnt16:
001AB8  3  60                   rts
001AB9  3               evnt17:
001AB9  3  60                   rts
001ABA  3               evnt18:
001ABA  3  60                   rts
001ABB  3               evnt19:
001ABB  3  60                   rts
001ABC  3               evnt20:
001ABC  3  60                   rts
001ABD  3  60           ptcusr: rts
001ABE  3               msgdat:
001ABE  3  43 4C 4F 43          .byte "CLOCK TEST:",160
001AC2  3  4B 20 54 45  
001AC6  3  53 54 3A A0  
001ACA  3  43 55 52 52          .byte "CURRENT CLOCK:",160
001ACE  3  45 4E 54 20  
001AD2  3  43 4C 4F 43  
001AD9  3  20 A0                .byte " ",160
001ADB  3  43 55 52 52          .byte "CURRENT TIME:",160
001ADF  3  45 4E 54 20  
001AE3  3  54 49 4D 45  
001AE9  3  20 A0                .byte " ",160
001AEB  3               nummsg:
001AEB  3  05                   .byte 5
001AEC  3               chgfx:
001AEC  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0
001AF0  3  00 00 00 00  
001AF4  3               bprop:
001AF4  3  00                   .byte 0
001AF5  3               sprgfx:
001AF5  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
001AF9  3  00 00 00 00  
001AFD  3  00 00 00 00  
001B15  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
001B19  3  00 00 00 00  
001B1D  3  00 00 00 00  
001B35  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
001B39  3  00 00 00 00  
001B3D  3  00 00 00 00  
001B55  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
001B59  3  00 00 00 00  
001B5D  3  00 00 00 00  
001B75  3               
001B75  3               frmlst:
001B75  3  00 01 01 00          .byte 0,1,1,0
001B79  3               scdat:
001B79  3  09 00                .word 9
001B7B  3  FF 00 00 FF          .byte 255,0,0,255,0,0,255,0,148
001B7F  3  00 00 FF 00  
001B83  3  94           
001B84  3               numsc:
001B84  3  01                   .byte 1
001B85  3               nmedat:
001B85  3  00 00 58 80          .byte 0,0,88,128,255
001B89  3  FF           
001B8A  3               NUMOBJ = 1
001B8A  3               objdta:
001B8A  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,160,32,0,160,32
001B8E  3  00 00 00 00  
001B92  3  00 00 00 00  
001BB0  3               font:
001BB0  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0
001BB4  3  00 00 00 00  
001BB8  3  00 30 30 30          .byte 0,48,48,48,48,0,48,0
001BBC  3  30 00 30 00  
001BC0  3  00 6C 6C 00          .byte 0,108,108,0,0,0,0,0
001BC4  3  00 00 00 00  
001BC8  3  00 6C FE 6C          .byte 0,108,254,108,108,254,108,0
001BCC  3  6C FE 6C 00  
001BD0  3  00 18 7E 78          .byte 0,24,126,120,126,30,126,24
001BD4  3  7E 1E 7E 18  
001BD8  3  00 E6 EC 18          .byte 0,230,236,24,48,110,206,0
001BDC  3  30 6E CE 00  
001BE0  3  00 30 78 30          .byte 0,48,120,48,126,204,126,0
001BE4  3  7E CC 7E 00  
001BE8  3  00 18 30 00          .byte 0,24,48,0,0,0,0,0
001BEC  3  00 00 00 00  
001BF0  3  00 0C 18 18          .byte 0,12,24,24,24,24,12,0
001BF4  3  18 18 0C 00  
001BF8  3  00 60 30 30          .byte 0,96,48,48,48,48,96,0
001BFC  3  30 30 60 00  
001C00  3  00 00 3C 18          .byte 0,0,60,24,126,24,60,0
001C04  3  7E 18 3C 00  
001C08  3  00 00 18 18          .byte 0,0,24,24,126,24,24,0
001C0C  3  7E 18 18 00  
001C10  3  00 00 00 00          .byte 0,0,0,0,0,24,24,48
001C14  3  00 18 18 30  
001C18  3  00 00 00 00          .byte 0,0,0,0,126,0,0,0
001C1C  3  7E 00 00 00  
001C20  3  00 00 00 00          .byte 0,0,0,0,0,56,56,0
001C24  3  00 38 38 00  
001C28  3  00 00 06 0C          .byte 0,0,6,12,24,48,96,0
001C2C  3  18 30 60 00  
001C30  3  00 7C CE DE          .byte 0,124,206,222,246,230,124,0
001C34  3  F6 E6 7C 00  
001C38  3  00 38 78 18          .byte 0,56,120,24,24,24,126,0
001C3C  3  18 18 7E 00  
001C40  3  00 7C C6 06          .byte 0,124,198,6,124,192,254,0
001C44  3  7C C0 FE 00  
001C48  3  00 7C C6 1C          .byte 0,124,198,28,6,198,124,0
001C4C  3  06 C6 7C 00  
001C50  3  00 18 38 78          .byte 0,24,56,120,216,254,24,0
001C54  3  D8 FE 18 00  
001C58  3  00 FE C0 FC          .byte 0,254,192,252,6,198,124,0
001C5C  3  06 C6 7C 00  
001C60  3  00 7C C0 FC          .byte 0,124,192,252,198,198,124,0
001C64  3  C6 C6 7C 00  
001C68  3  00 FE 06 0C          .byte 0,254,6,12,24,48,48,0
001C6C  3  18 30 30 00  
001C70  3  00 7C C6 7C          .byte 0,124,198,124,198,198,124,0
001C74  3  C6 C6 7C 00  
001C78  3  00 7C C6 C6          .byte 0,124,198,198,126,6,124,0
001C7C  3  7E 06 7C 00  
001C80  3  00 00 00 30          .byte 0,0,0,48,0,0,48,0
001C84  3  00 00 30 00  
001C88  3  00 00 30 00          .byte 0,0,48,0,0,48,48,96
001C8C  3  00 30 30 60  
001C90  3  00 00 0C 18          .byte 0,0,12,24,48,24,12,0
001C94  3  30 18 0C 00  
001C98  3  00 00 00 7E          .byte 0,0,0,126,0,126,0,0
001C9C  3  00 7E 00 00  
001CA0  3  00 00 30 18          .byte 0,0,48,24,12,24,48,0
001CA4  3  0C 18 30 00  
001CA8  3  00 7C C6 0C          .byte 0,124,198,12,24,0,24,0
001CAC  3  18 00 18 00  
001CB0  3  00 7C DE FE          .byte 0,124,222,254,254,192,124,0
001CB4  3  FE C0 7C 00  
001CB8  3  00 7C C6 C6          .byte 0,124,198,198,254,198,198,0
001CBC  3  FE C6 C6 00  
001CC0  3  00 FC C6 FC          .byte 0,252,198,252,198,198,252,0
001CC4  3  C6 C6 FC 00  
001CC8  3  00 7C C6 C0          .byte 0,124,198,192,192,198,124,0
001CCC  3  C0 C6 7C 00  
001CD0  3  00 F8 CC C6          .byte 0,248,204,198,198,204,248,0
001CD4  3  C6 CC F8 00  
001CD8  3  00 FE C0 FC          .byte 0,254,192,252,192,192,254,0
001CDC  3  C0 C0 FE 00  
001CE0  3  00 FE C0 FC          .byte 0,254,192,252,192,192,192,0
001CE4  3  C0 C0 C0 00  
001CE8  3  00 7C C6 C0          .byte 0,124,198,192,222,198,124,0
001CEC  3  DE C6 7C 00  
001CF0  3  00 C6 C6 FE          .byte 0,198,198,254,198,198,198,0
001CF4  3  C6 C6 C6 00  
001CF8  3  00 7E 18 18          .byte 0,126,24,24,24,24,126,0
001CFC  3  18 18 7E 00  
001D00  3  00 06 06 06          .byte 0,6,6,6,198,198,124,0
001D04  3  C6 C6 7C 00  
001D08  3  00 CC D8 F0          .byte 0,204,216,240,216,204,198,0
001D0C  3  D8 CC C6 00  
001D10  3  00 C0 C0 C0          .byte 0,192,192,192,192,192,254,0
001D14  3  C0 C0 FE 00  
001D18  3  00 C6 EE FE          .byte 0,198,238,254,198,198,198,0
001D1C  3  C6 C6 C6 00  
001D20  3  00 C6 E6 F6          .byte 0,198,230,246,222,206,198,0
001D24  3  DE CE C6 00  
001D28  3  00 7C C6 C6          .byte 0,124,198,198,198,198,124,0
001D2C  3  C6 C6 7C 00  
001D30  3  00 FC C6 C6          .byte 0,252,198,198,252,192,192,0
001D34  3  FC C0 C0 00  
001D38  3  00 7C C6 C6          .byte 0,124,198,198,246,222,124,0
001D3C  3  F6 DE 7C 00  
001D40  3  00 FC C6 C6          .byte 0,252,198,198,252,204,198,0
001D44  3  FC CC C6 00  
001D48  3  00 7C C0 7C          .byte 0,124,192,124,6,198,124,0
001D4C  3  06 C6 7C 00  
001D50  3  00 FE 30 30          .byte 0,254,48,48,48,48,48,0
001D54  3  30 30 30 00  
001D58  3  00 C6 C6 C6          .byte 0,198,198,198,198,198,124,0
001D5C  3  C6 C6 7C 00  
001D60  3  00 C6 C6 C6          .byte 0,198,198,198,198,108,56,0
001D64  3  C6 6C 38 00  
001D68  3  00 C6 C6 C6          .byte 0,198,198,198,198,254,108,0
001D6C  3  C6 FE 6C 00  
001D70  3  00 C6 6C 38          .byte 0,198,108,56,56,108,198,0
001D74  3  38 6C C6 00  
001D78  3  00 86 CC 78          .byte 0,134,204,120,48,48,48,0
001D7C  3  30 30 30 00  
001D80  3  00 FE 0C 18          .byte 0,254,12,24,48,96,254,0
001D84  3  30 60 FE 00  
001D88  3  00 1E 18 18          .byte 0,30,24,24,24,24,30,0
001D8C  3  18 18 1E 00  
001D90  3  00 00 C0 60          .byte 0,0,192,96,48,24,12,0
001D94  3  30 18 0C 00  
001D98  3  00 F0 30 30          .byte 0,240,48,48,48,48,240,0
001D9C  3  30 30 F0 00  
001DA0  3  00 30 78 FC          .byte 0,48,120,252,48,48,48,0
001DA4  3  30 30 30 00  
001DA8  3  00 00 00 00          .byte 0,0,0,0,0,0,0,255
001DAC  3  00 00 00 FF  
001DB0  3  00 3C 66 F8          .byte 0,60,102,248,96,96,254,0
001DB4  3  60 60 FE 00  
001DB8  3  00 00 78 0C          .byte 0,0,120,12,124,204,124,0
001DBC  3  7C CC 7C 00  
001DC0  3  00 60 60 7C          .byte 0,96,96,124,102,102,124,0
001DC4  3  66 66 7C 00  
001DC8  3  00 00 3C 60          .byte 0,0,60,96,96,96,60,0
001DCC  3  60 60 3C 00  
001DD0  3  00 0C 0C 7C          .byte 0,12,12,124,204,204,124,0
001DD4  3  CC CC 7C 00  
001DD8  3  00 00 78 CC          .byte 0,0,120,204,248,192,124,0
001DDC  3  F8 C0 7C 00  
001DE0  3  00 1C 30 38          .byte 0,28,48,56,48,48,48,0
001DE4  3  30 30 30 00  
001DE8  3  00 00 7C CC          .byte 0,0,124,204,204,124,12,120
001DEC  3  CC 7C 0C 78  
001DF0  3  00 C0 C0 F8          .byte 0,192,192,248,204,204,204,0
001DF4  3  CC CC CC 00  
001DF8  3  00 30 00 70          .byte 0,48,0,112,48,48,120,0
001DFC  3  30 30 78 00  
001E00  3  00 0C 00 0C          .byte 0,12,0,12,12,12,108,56
001E04  3  0C 0C 6C 38  
001E08  3  00 60 78 70          .byte 0,96,120,112,112,120,108,0
001E0C  3  70 78 6C 00  
001E10  3  00 30 30 30          .byte 0,48,48,48,48,48,28,0
001E14  3  30 30 1C 00  
001E18  3  00 00 F8 FC          .byte 0,0,248,252,252,252,252,0
001E1C  3  FC FC FC 00  
001E20  3  00 00 F8 CC          .byte 0,0,248,204,204,204,204,0
001E24  3  CC CC CC 00  
001E28  3  00 00 78 CC          .byte 0,0,120,204,204,204,120,0
001E2C  3  CC CC 78 00  
001E30  3  00 00 F8 CC          .byte 0,0,248,204,204,248,192,192
001E34  3  CC F8 C0 C0  
001E38  3  00 00 7C CC          .byte 0,0,124,204,204,124,12,14
001E3C  3  CC 7C 0C 0E  
001E40  3  00 00 3C 60          .byte 0,0,60,96,96,96,96,0
001E44  3  60 60 60 00  
001E48  3  00 00 78 C0          .byte 0,0,120,192,120,12,248,0
001E4C  3  78 0C F8 00  
001E50  3  00 30 78 30          .byte 0,48,120,48,48,48,28,0
001E54  3  30 30 1C 00  
001E58  3  00 00 CC CC          .byte 0,0,204,204,204,204,120,0
001E5C  3  CC CC 78 00  
001E60  3  00 00 CC CC          .byte 0,0,204,204,120,120,48,0
001E64  3  78 78 30 00  
001E68  3  00 00 CC FC          .byte 0,0,204,252,252,252,120,0
001E6C  3  FC FC 78 00  
001E70  3  00 00 CC 78          .byte 0,0,204,120,48,120,204,0
001E74  3  30 78 CC 00  
001E78  3  00 00 CC CC          .byte 0,0,204,204,204,124,12,120
001E7C  3  CC 7C 0C 78  
001E80  3  00 00 FC 18          .byte 0,0,252,24,48,96,252,0
001E84  3  30 60 FC 00  
001E88  3  00 1E 18 70          .byte 0,30,24,112,24,24,30,0
001E8C  3  18 18 1E 00  
001E90  3  00 18 18 18          .byte 0,24,24,24,24,24,24,0
001E94  3  18 18 18 00  
001E98  3  00 F0 30 1C          .byte 0,240,48,28,48,48,240,0
001E9C  3  30 30 F0 00  
001EA0  3  00 3C 78 00          .byte 0,60,120,0,0,0,0,0
001EA4  3  00 00 00 00  
001EA8  3  7C C6 BB E3          .byte 124,198,187,227,227,187,198,124
001EAC  3  E3 BB C6 7C  
001EB0  3               jtab:
001EB0  3  63                   .byte 99
001EB1  3  35 15 93 22  keys:   .byte 53,21,147,34,144,4,20,33,17,1,146
001EB5  3  90 04 14 21  
001EB9  3  11 01 92     
001EBC  3               
001EBC  2               
001EBC  1               	.include "z80.asm"
001EBC  2               ;------------------------------------------------------
001EBC  2               ; z80.asm
001EBC  2               ; spectrum stuff
001EBC  2               ; adresses
001EBC  2               
001EBC  2               
001EBC  2               ; Contains seperatly 1 bit set
001EBC  2               
001EBC  2               _bitmem0	= $f8
001EBC  2               _bitmem1	= $f9
001EBC  2               _bitmem2	= $fa
001EBC  2               _bitmem3	= $fb
001EBC  2               _bitmem4	= $fc
001EBC  2               _bitmem5	= $fd
001EBC  2               _bitmem6	= $fe
001EBC  2               _bitmem7	= $ff
001EBC  2               
001EBC  2               ; constants
001EBC  2               _bitvalue0	= $01
001EBC  2               _bitvalue1	= $02
001EBC  2               _bitvalue2	= $04
001EBC  2               _bitvalue3	= $08
001EBC  2               _bitvalue4	= $10
001EBC  2               _bitvalue5	= $20
001EBC  2               _bitvalue6	= $40
001EBC  2               _bitvalue7	= $80
001EBC  2               
001EBC  2               _notbitvalue0	= $fe
001EBC  2               _notbitvalue1	= $fd
001EBC  2               _notbitvalue2	= $fb
001EBC  2               _notbitvalue3	= $f7
001EBC  2               _notbitvalue4	= $ef
001EBC  2               _notbitvalue5	= $df
001EBC  2               _notbitvalue6	= $bf
001EBC  2               _notbitvalue7	= $7f
001EBC  2               
001EBC  2               
001EBC  2               exx:
001EBC  2  A5 62        		lda z80_c
001EBE  2  A4 6E        		ldy z80_cp
001EC0  2  84 62        		sty z80_c
001EC2  2  85 6E        		sta z80_cp
001EC4  2  A5 63        		lda z80_b
001EC6  2  A4 6F        		ldy z80_bp
001EC8  2  84 63        		sty z80_b
001ECA  2  85 6F        		sta z80_bp
001ECC  2  A5 64        		lda z80_e
001ECE  2  A4 70        		ldy z80_ep
001ED0  2  84 64        		sty z80_e
001ED2  2  85 70        		sta z80_ep
001ED4  2  A5 65        		lda z80_d
001ED6  2  A4 71        		ldy z80_dp
001ED8  2  84 65        		sty z80_d
001EDA  2  85 71        		sta z80_dp
001EDC  2  A5 rr        		lda scraddr
001EDE  2  A4 72        		ldy z80_lp
001EE0  2  84 rr        		sty scraddr
001EE2  2  85 72        		sta z80_lp
001EE4  2  A5 rr        		lda scraddr+1
001EE6  2  A4 73        		ldy z80_hp
001EE8  2  84 rr        		sty scraddr+1
001EEA  2  85 73        		sta z80_hp
001EEC  2  60           		rts
001EED  2               
001EED  2               
001EED  1               eind_asm:
001EED  1               eop:					; End Of Program
001EED  1               
001EED  1               .out .sprintf("Gamecode size = %d bytes, free space = %d bytes", (eind_asm - start_asm),(32000-eind_asm + start_asm))
001EED  1               
